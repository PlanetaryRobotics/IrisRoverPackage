"""
Flashes the given image to the given target (or only target if none is
supplied and only one is in targetConfigs) using the given TI CCS installation.

@author: Connor W. Colombo (CMU)
@last-updated: 07/10/2022
"""

# Activate postponed annotations (for using classes as return type in their own methods):
from __future__ import annotations

import tiflash
import argparse

import os
import pprint
import logging
from pathlib import Path
from dataclasses import dataclass
import xml.etree.ElementTree as ET
from html.parser import HTMLParser
from typing import Any, Final, Dict

# Where the CCS config files are located relative to this file:
CONFIGS_DIR: Final[str] = '../targetConfigs'

# Setup logging:
console = logging.StreamHandler()
# set a format which is simpler for console use
formatter = logging.Formatter('%(asctime)-15s: %(levelname)-8s %(message)s')
console.setFormatter(formatter)
logging.getLogger().addHandler(console)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def pretty_dict(d: Dict[Any, Any]) -> str:
    """Returns a 'pretty' string of the given dict."""
    return pprint.pformat(
        d,
        indent=4,
        width=1,
        compact=False,
        sort_dicts=True
    )


def get_opts():
    """
    Return script settings wrapped in argparse.
    """
    parser = argparse.ArgumentParser(description='Iris Hercules Flasher â€” CLI')

    parser.add_argument('--img', type=str, default='', help=(
        "Path to the image file to flash."
    ))

    parser.add_argument('--target', type=str, default='', help=(
        "Name of target configuration to use (name of a `*.ccxml` file in the "
        "`targetConfigs` directory, generated by TI CCS). "
        "If you don't supply one and there's only one CCXML file in "
        "targetConfigs, that config will be used. Otherwise, no config will "
        "be used, flashing will be skipped, and all available configs will be "
        "listed."
    ))

    parser.add_argument('--ti-ccs-dir', type=str, default='~/ti/', help=(
        "Directory containing TI CCS"
        "(specifically, the version you want to use)."
    ))

    return parser.parse_args()


def get_node_attrib(
    file_path: str,
    root: ET.Element,
    xpath: str,
    attrib: str
) -> Any:
    """ Helper function for CCXML parsing.
    Returns the value of attribute `attrib` from the node at xpath `xpath`
    (assuming there's only one node there) from the XML tree originating at
    `root` found in the file at `file_path`.

    Raises exceptions if anything goes wrong.
    """
    nodes = root.findall(xpath)

    if len(nodes) == 0:
        raise Exception(
            f"{file_path} CCXML file appears to be malformed. "
            f"Could not find any nodes at xpath `{xpath}` "
            "relative to the root. "
            f"The root XML is: `{ET.tostring(root).decode('utf8')}`."
        )

    if len(nodes) > 1:
        nodes_msg = '\n\t'.join([ET.tostring(n).decode('utf8') for n in nodes])
        raise Exception(
            f"{file_path} CCXML file appears to be malformed. "
            f"Found multiple nodes at xpath `{xpath}` "
            f"relative to the root. There should be only one. "
            f"Found: \n\t{nodes_msg}\n"
            f"The root XML is: `{ET.tostring(root).decode('utf8')}`."
        )

    try:
        val = nodes[0].attrib[attrib]
    except KeyError:
        raise Exception(
            f"{file_path} CCXML file appears to be malformed. "
            f"Could not find attribute `{attrib}` in node at xpath `{xpath}` "
            f"relative to the root. "
            f"The node's XML is: `{ET.tostring(nodes[0]).decode('utf8')}`."
        )

    return val


@dataclass
class TargetConfig:
    file_path: str
    connection: str
    platform: str

    @classmethod
    def from_ccxml(cls, file_path: Path) -> TargetConfig:
        # Load XML:
        try:
            root = ET.parse(file_path).getroot()
        except Exception as e:
            raise Exception(
                f"Failed to load the XML tree of `{file_path}`. "
                "Is the file corrupted? Does it no longer exist? "
                "Is it actually (CC)XML? "
                f"Originated with exception: `{e}`."
            )

        # Grab data:
        connection = get_node_attrib(
            file_path, root,
            'configuration/connection', 'id')
        platform = get_node_attrib(
            file_path, root,
            'configuration/connection/platform/instance', 'id')

        return cls(str(file_path), connection, platform)


def find_all_targets() -> Dict[TargetConfig]:
    # Grab all CCXML files in the `CONFIGS_DIR` directory
    # (where CCS puts them):
    cfgs = [
        Path(os.path.join(CONFIGS_DIR, f)) for f in os.listdir(CONFIGS_DIR)
        if f.endswith('.ccxml')
    ]

    if len(cfgs) == 0:
        raise Exception(
            "No CCS target configuration files (*.ccxml) were found in the "
            f"`{CONFIGS_DIR}` directory. Open this project in TI CCS "
            "and use it to create a ccxml target configuration file."
        )

    # Extract high-level data from all TargetConfigs:
    # Return it as a dict mapping file name (ei)
    return {cfg.stem: TargetConfig.from_ccxml(cfg) for cfg in cfgs}


def list_targets(targets: Dict[TargetConfig]) -> str:
    targets_msg = '\n\t'.join([f'{k}: {v}' for k, v in targets.items()])
    return f"The following targets were found:\n\t{targets_msg}."


def get_target_config(target: str) -> TargetConfig:
    """Gets the `TargetConfig` associated with the CCXML target config file
    with the given name `target`.

    If target == '' (not given in opts), and only one CCXML file is in the
    `CONFIGS_DIR` directory. If there are multiple configs, one cannot be
    picked arbitrarily, so an exception will be thrown that lists all available
    configs.

    Raises:
        Exception: If there are no CCXML files in the `CONFIGS_DIR` directory.
        Exception: If `target` is not found in the `CONFIGS_DIR` directory.
        Exception: If no `target` is given and there are multiple configs in
            the `CONFIGS_DIR` directory so one can't be automatically picked.

    Returns:
        TargetConfig: The `TargetConfig` associated with the CCXML file of the
            given name `target`.
    """
    # Load CCXML Target Configuration files:
    targets = find_all_targets()

    if target == '':
        # No target was given...
        if len(targets) == 1:
            # if there's only one target anyway, just pick that one:
            target_config = [targets.keys()][0]
            logger.info(
                "No target was given but there's only one target in "
                f"`{CONFIGS_DIR}`, so that one was chosen. "
                f"Target is now `{target}`."
            )
        else:
            raise Exception(
                "No target was given and there a multiple targets in "
                f"`{CONFIGS_DIR}` so it would not be safe to just pick "
                "one arbitrarily as a default. Please provide a target using "
                "the `--target` argument. "
                f"The following targets can be chosen:\n {list_targets()}."
            )

    if target not in targets:
        raise Exception(
            f"The given target `{target}` was not found. "
            f"The following targets were found:\n {list_targets()}."
        )

    return target_config


if __name__ == "__main__":
    opts = get_opts()  # Parse CLI args
    # Resolve and expand paths (tiflash doesn't like `~`):
    ccs_dir = os.path.expanduser(opts.ti_ccs_dir)
    img_path = os.path.expanduser(opts.img)

    # Grab the target:
    target_config = get_target_config()
    logging.info(f"Using target: {target_config}.")

    # Build session args to pass to all tiflash functions:
    sargs = dict(
        ccs=ccs_dir,
        ccxml=target_config.file_path,
        fresh=False,
        debug=True,
        timeout=60,  # seconds
    )
    logging.info(
        "Connecting to TI CCS using the following settings:\n"
        f"{pretty_dict(sargs)}."
    )

    # Print TI CCS Info.
    info = tiflash.get_info(**sargs)
    logger.info(f"Connected to TI CCS with:\n\t{pretty_dict(info)}")

    # TODO: Load flash settings from .launches/FlightMCU.launch and pass as options
    # from /launchConfiguration/stringAttribute/@value
    # where @key contains FlightMCU/targetConfigs/RM46L852.ccxml (or whatever file we're using)
    # where @key ends with Blackhawk XDS560v2-USB System Trace Emulator_0/CortexR4 (or whatever probe we're using).
    # use HTMLParser.unescape()
    # When printing, compare against default from list_options.

    # Flash:
    tiflash.flash(opts.img_path, options=dict(), **sargs)
