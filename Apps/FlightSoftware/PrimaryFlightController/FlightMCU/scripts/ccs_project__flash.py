"""
Flashes the given image to the given target (or only target if none is
supplied and only one is in targetConfigs) using the given TI CCS installation.

@author: Connor W. Colombo (CMU)
@last-updated: 07/12/2022
"""

# Activate postponed annotations (for using classes as return type in their own methods):
from __future__ import annotations

import tiflash
import argparse

import re
import os
import pprint
import logging
from pathlib import Path
from dataclasses import dataclass
import xml.etree.ElementTree as ET
from html.parser import HTMLParser
from typing import Any, Final, Dict, List

# Name of the project (both the main directory and in CCS - they must match):
PROJ_NAME: Final[str] = 'FlightMCU'
# Where the root directory of the project is relative to the directory
# containing this file (all subsequent directories will be relative to this):
PROJ_ROOT_DIR: Final[str] = '../'
# Where the CCS config files are located relative to `PROJ_ROOT_DIR`:
CONFIGS_DIR: Final[str] = './targetConfigs'
# Where Project Launch Settings are stored (eclipse configuration used for
# debugging and flashing) relative to `PROJ_ROOT_DIR`:
PROJ_LAUNCH_FILE: Final[str] = f"./.launches/{PROJ_NAME}.launch"

# Setup logging:
console = logging.StreamHandler()
# set a format which is simpler for console use
formatter = logging.Formatter('%(asctime)-15s: %(levelname)-8s %(message)s')
console.setFormatter(formatter)
logging.getLogger().addHandler(console)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def pretty_dict(d: Dict[Any, Any]) -> str:
    """Returns a 'pretty' string of the given dict."""
    return pprint.pformat(
        d,
        indent=4,
        width=1,
        compact=False,
        sort_dicts=True
    )


def get_opts():
    """
    Return script settings wrapped in argparse.
    """
    parser = argparse.ArgumentParser(description='Iris Hercules Flasher â€” CLI')

    parser.add_argument('--img', type=str, default='', help=(
        "Path to the image file to flash."
    ))

    parser.add_argument('--target', type=str, default='', help=(
        "Name of target configuration to use (name of a `*.ccxml` file in the "
        "`targetConfigs` directory, generated by TI CCS). "
        "If you don't supply one and there's only one CCXML file in "
        "targetConfigs, that config will be used. Otherwise, no config will "
        "be used, flashing will be skipped, and all available configs will be "
        "listed."
    ))

    parser.add_argument('--ti-ccs-dir', type=str, default='~/ti/', help=(
        "Directory containing TI CCS"
        "(specifically, the version you want to use)."
    ))

    return parser.parse_args()


def get_node_attrib(
    file_path: str,
    root: ET.Element,
    xpath: str,
    attrib: str
) -> Any:
    """ Helper function for CCXML parsing.
    Returns the value of attribute `attrib` from the node at xpath `xpath`
    (assuming there's only one node there) from the XML tree originating at
    `root` found in the file at `file_path`.

    Raises exceptions if anything goes wrong.
    """
    nodes = root.findall(xpath)

    if len(nodes) == 0:
        raise Exception(
            f"{file_path} CCXML file appears to be malformed. "
            f"Could not find any nodes at xpath `{xpath}` "
            "relative to the root. "
            f"The root XML is: `{ET.tostring(root).decode('utf8')}`."
        )

    if len(nodes) > 1:
        nodes_msg = '\n\t'.join([ET.tostring(n).decode('utf8') for n in nodes])
        raise Exception(
            f"{file_path} CCXML file appears to be malformed. "
            f"Found multiple nodes at xpath `{xpath}` "
            f"relative to the root. There should be only one. "
            f"Found: \n\t{nodes_msg}\n"
            f"The root XML is: `{ET.tostring(root).decode('utf8')}`."
        )

    try:
        val = nodes[0].attrib[attrib]
    except KeyError:
        raise Exception(
            f"{file_path} CCXML file appears to be malformed. "
            f"Could not find attribute `{attrib}` in node at xpath `{xpath}` "
            f"relative to the root. "
            f"The node's XML is: `{ET.tostring(nodes[0]).decode('utf8')}`."
        )

    return val


@dataclass
class TargetConfig:
    file_path: str
    connection: str
    platform: str

    @classmethod
    def from_ccxml(cls, file_path: Path) -> TargetConfig:
        # Load XML:
        try:
            root = ET.parse(file_path).getroot()
        except Exception as e:
            raise Exception(
                f"Failed to load the XML tree of `{file_path}`. "
                "Is the file corrupted? Does it no longer exist? "
                "Is it actually (CC)XML? "
                f"Originated with exception: `{e}`."
            )

        # Grab data:
        connection = get_node_attrib(
            file_path, root,
            'configuration/connection', 'id')
        platform = get_node_attrib(
            file_path, root,
            'configuration/connection/platform/instance', 'id')

        return cls(str(file_path), connection, platform)


def find_all_targets() -> Dict[TargetConfig]:
    # Grab all CCXML files in the `CONFIGS_DIR` directory
    # (where CCS puts them):
    cfgs = [
        Path(os.path.join(PROJ_ROOT_DIR, CONFIGS_DIR, f))
        for f in os.listdir(CONFIGS_DIR)
        if f.endswith('.ccxml')
    ]

    if len(cfgs) == 0:
        raise Exception(
            "No CCS target configuration files (*.ccxml) were found in the "
            f"`{CONFIGS_DIR}` directory. Open this project in TI CCS "
            "and use it to create a ccxml target configuration file."
        )

    # Extract high-level data from all TargetConfigs:
    # Return it as a dict mapping file name (ei)
    return {cfg.stem: TargetConfig.from_ccxml(cfg) for cfg in cfgs}


def list_targets(targets: Dict[TargetConfig]) -> str:
    targets_msg = '\n\t'.join([f'{k}: {v}' for k, v in targets.items()])
    return f"The following targets were found:\n\t{targets_msg}."


def get_target_config(target: str) -> TargetConfig:
    """Gets the `TargetConfig` associated with the CCXML target config file
    with the given name `target`.

    If target == '' (not given in opts), and only one CCXML file is in the
    `CONFIGS_DIR` directory. If there are multiple configs, one cannot be
    picked arbitrarily, so an exception will be thrown that lists all available
    configs.

    Raises:
        Exception: If there are no CCXML files in the `CONFIGS_DIR` directory.
        Exception: If `target` is not found in the `CONFIGS_DIR` directory.
        Exception: If no `target` is given and there are multiple configs in
            the `CONFIGS_DIR` directory so one can't be automatically picked.

    Returns:
        TargetConfig: The `TargetConfig` associated with the CCXML file of the
            given name `target`.
    """
    # Load CCXML Target Configuration files:
    targets = find_all_targets()

    if target == '':
        # No target was given...
        if len(targets) == 1:
            # if there's only one target anyway, just pick that one:
            target, target_config = [*targets.items()][0]
            logger.info(
                "No target was given but there's only one target in "
                f"`{CONFIGS_DIR}`, so that one was chosen. "
                f"Target is now `{target}`."
            )
        else:
            raise Exception(
                "No target was given and there a multiple targets in "
                f"`{CONFIGS_DIR}` so it would not be safe to just pick "
                "one arbitrarily as a default. Please provide a target using "
                "the `--target` argument. "
                "The following targets can be chosen:\n"
                f"{list_targets(targets)}."
            )
    else:
        if target not in targets:
            raise Exception(
                f"The given target `{target}` was not found. "
                f"The following targets were found:\n {list_targets(targets)}."
            )

        target_config = targets[target]

    return target_config


FlashingOptions = Dict[str, Any]


def get_flashing_options(target_config: TargetConfig) -> FlashingOptions:
    """Loads the options to use while flashing that correspond to the given
    `target_config` (if any). These settings are loaded from the
    `PROJ_LAUNCH_FILE` `.launch` file.

    If no attribute in `PROJ_LAUNCH_FILE` matches the given TargetConfig,
    it's assumed default settings will be used and an empty dict will be
    returned.
    """

    # Grab every `StringAttribute` from `PROJ_LAUNCH_FILE`:
    launch_file_addr = os.path.join(PROJ_ROOT_DIR, PROJ_LAUNCH_FILE)
    root = ET.parse(launch_file_addr).getroot()
    string_attrs = root.findall('stringAttribute')

    # Loop over each one and only keep it if the key maps to `file_name` and
    # `connection` given in `target_config`:

    # The StringAttributes use a key that's part path, part configuration
    # information. For the debug strings, it follows the pattern:
    #
    # "{internal_eclipse_uri_to_an_attribute}
    # .{absolute_path_to_a_target_config_on_whatever_machine_made_the_config}
    # .{target_config_connection}
    # /{connection_driver_name}"
    #
    # The StringAttributes that matter to us will be the ones that:
    #   - have an attribute uri of:
    #       `com.ti.ccstudio.debug.debugModel.ATTR_DEBUGGER_PROPERTIES`
    #       (what CCS uses for debugger and programming settings, the debug
    #       options will just get ignored by tiflash).
    #   - reference our target config file in our project directory
    #       (but we only care that the local/relative path matches, not the
    #       full absolute path).
    #   - match the connection used by our target_config.
    # So, we need to filter and grab only the StringAttributes that fit these
    # criteria:
    attr_uri = "com.ti.ccstudio.debug.debugModel.ATTR_DEBUGGER_PROPERTIES"
    local_config_path = os.path.normpath(os.path.join(
        PROJ_NAME,
        CONFIGS_DIR,
        Path(target_config.file_path).name)
    )
    # Regex pattern to match against (keep if StringAttribute/@key matches):
    uri_pattern = re.compile(
        f'^{re.escape(attr_uri)}'
        f'.*{re.escape(local_config_path)}'
        f'\.{re.escape(target_config.connection)}'
        r'.*$'
    )

    # Grab and unescape the value (escaped options xml) for all
    # StringAttributes where the key matches the regex pattern:
    options_xmls: List[str] = [
        HTMLParser().unescape(sa.attrib['value'])
        for sa in string_attrs
        if uri_pattern.match(sa.attrib['key'])
    ]

    # Extract all options from each XML tree into a dictionary:
    # (this is a list of all options for each matching CCS configuration)
    options_list = []
    for ox in options_xmls:
        opts = {}
        for property in ET.fromstring(ox).findall('property'):
            val = property.find('curValue').text
            # Convert to number if possible:
            try:
                val = float(val)
            except:
                pass  # can't convert to float, just leave as string
            opts[property.attrib['id']] = val
        options_list.append(opts)

    if len(options_list) == 0:
        logger.info(
            "No special project debug (and flashing) options were found "
            f"for the target `{target_config}` "
            f"in the project launch file `{launch_file_addr}`. "
            "Assuming all default options. "
        )

    if len(options_list) > 1:
        # if multiple option sets, make sure there's no overlap:
        # Make sure:
        #   - Either every options set configures different options.
        #   - Or, if multiple options sets configure the same option, make sure
        #     they have the same value for that option.
        # Collect all options configured in any options set:
        all_option_names = {x for os in options_list for x in os.keys()}
        # Make sure those options:

    return options_list


if __name__ == "__main__":
    opts = get_opts()  # Parse CLI args
    # Resolve and expand paths (tiflash doesn't like `~`):
    ccs_dir = os.path.expanduser(opts.ti_ccs_dir)
    img_path = os.path.expanduser(opts.img)

    # Grab the target:
    target_config = get_target_config()
    logging.info(f"Using target: {target_config}.")

    # Build session args to pass to all tiflash functions:
    sargs = dict(
        ccs=ccs_dir,
        ccxml=target_config.file_path,
        fresh=False,
        debug=True,
        timeout=60,  # seconds
    )
    logging.info(
        "Connecting to TI CCS using the following settings:\n"
        f"{pretty_dict(sargs)}."
    )

    # Print TI CCS Info.
    info = tiflash.get_info(**sargs)
    logger.info(f"Connected to TI CCS with:\n\t{pretty_dict(info)}")

    # ! When printing, compare against default from list_options.

    # Flash:
    tiflash.flash(opts.img_path, options=dict(), **sargs)
