# Contains procedures to handle anomalous (untriggered, unrequested, or
# unexpected) events:

## WIFI DISCONNECT
# Wifi Network Disconnected (after a connection was previously established):
const ANOM__WIFI_CONNECTION_LOST__TIMER_HANDLE = $A1  # Handle is only uint8
event sme_disconnected(reason, hw_interface)
    if hw_interface = 0 then
        # TODO: Let Watchdog know (Hercules will know automatically)
        # Log as Hercules Direct Message Error too (just in case):
        call HR_ERROR_DISCONNECT()
        # Turn off wifi:
        call sme_wifi_off()
        # Let hercules know we plan on fixing this (once wifi is off):
        call HR_WAITING_THEN_CORRECTING()
    end if
end
event sme_wifi_is_off(result)
	# If Wi-Fi is OFF
	if result = 0 then
        # If WiFi has turned off anomalously (or we turned it off above)...
        # Wait 0.5s, then retry the state driver:
        call hardware_set_soft_timer(500, ANOM__WIFI_CONNECTION_LOST__TIMER_HANDLE, 1)
	end if
end
event hardware_soft_timer(handle)
    if handle = ANOM__WIFI_CONNECTION_LOST__TIMER_HANDLE then
        # Since wifi is off, go back to the INIT state (state before wifi-on):
        call SET_STATE_INIT()
        # don't worry, if WIFI_ON fails, it will eventually give up and restart the radio
    end if
end


## UDP CLOSURE
# Listen for UDP closures (this really shouldn't happen so let)
const ANOM__UDP_CLOSURE__TIMER_HANDLE = $A2  # Handle is only uint8
event endpoint_closing(reason, endpoint)
    if endpoint != UDP_NULL_ENDPOINT then
        if endpoint = udp_client_endpoint || endpoint = udp_server_endpoint then
            # Log as Hercules Direct Message Error:
            call HR_ERROR_UDP_LOST()
            # Let hercules know we plan on fixing this:
            call HR_WAITING_THEN_CORRECTING()
            # Wait 1s, then try reopening:
            call hardware_set_soft_timer(1000, ANOM__UDP_CLOSURE__TIMER_HANDLE, 1)
        end if
    end if
end
event hardware_soft_timer(handle)
    if handle = ANOM__UDP_CLOSURE__TIMER_HANDLE then
        # Since UDP is disconnected, go back to the CONNECTED state (pre-UDP_CONNECTED):
        call SET_STATE_CONNECTED()  # tries to set up the UDP connection again
        # don't worry, if START_UDP fails, it will eventually give up and restart the radio
    end if
end
