# Contains procedures to handle anomalous (untriggered, unrequested, or
# unexpected) events:

##
# SETUP
##
# Important error codes to look out for:
# BGAPI Errors:
const BG_ERROR_OUT_OF_MEMORY = $0182 # This error indicates that the device has run out of memory
const BG_ERROR_HW_FAILURE = $0187 # This error code is generated when a hardware failure is detected.
const BG_ERROR_BUFFERS_FULL = $0188 # This error code is generated the a command was not accepted due to full internal buffers.
const BG_ERROR_TOO_MANY_REQUESTS = $018A # This error code is generated when there are too many simultaneous requests.
const BG_ERROR_OVERFLOW = $018E # This error code is generated when an overflow has been detected.
# TCP/IP Errors:
const TCPIP_ERROR_OUT_OF_MEMORY = $0201 # This error code is generated when the system has run out of memory.
const TCPIP_ERROR_BUFFER_ERROR = $0202 # This error code is generated when handling of buffers has failed.


##
# HELPER FUNCTIONS / ATOMIC-BEHAVIORS:
##

# Reset the device if the reason given for a failure was very bad (unrecoverable) and we need to reset:
export procedure critical_reset_if_bad_reason(reason)
    if reason = BG_ERROR_OUT_OF_MEMORY || reason = BG_ERROR_HW_FAILURE || reason = BG_ERROR_BUFFERS_FULL || reason = BG_ERROR_OVERFLOW || reason = TCPIP_ERROR_OUT_OF_MEMORY || reason = TCPIP_ERROR_BUFFER_ERROR then
        # oh no, something very bad happened...
        # if connected, let ground know (in some cases of "very bad", this
        # might not be possible but we should at least try):
        if status__wifi_connected != 0 then # compare as != 0 instead of = 1 since more bit-flip resistant to telling us if we might be connected:
            call RADIO_GND_CRITICAL_RESET_REASON(reason)
        end if

        # Let Hercules know:
        call HR_FATAL_CRITICAL_RESET_REASON(reason)

        # We've gone critical. Reset:
        call system_reset(0)
    end if
end


##
# WIFI DISCONNECT
##
# Wifi Network Disconnected (after a connection was previously established):
const ANOM__WIFI_CONNECTION_LOST__TIMER_HANDLE = $A1  # Handle is only uint8
event sme_disconnected(reason, hw_interface)
    if hw_interface = 0 then
        # Tell WD we're no longer connected:
        call WD_WIFI_NOT_CONNECTED()
        # Log as Hercules Direct Message Error too (just in case):
        call HR_ERROR_DISCONNECT()
        # Turn off wifi:
        call sme_wifi_off()
        # Let hercules know we plan on fixing this (once wifi is off):
        call HR_WAITING_THEN_CORRECTING()
    end if
end
event sme_wifi_is_off(result)
	# If Wi-Fi is OFF
	if result = 0 then
        # If WiFi has turned off anomalously (or we turned it off above)...
        # Wait 0.5s, then retry the state driver:
        call hardware_set_soft_timer(500, ANOM__WIFI_CONNECTION_LOST__TIMER_HANDLE, 1)
	end if
end
event hardware_soft_timer(handle)
    if handle = ANOM__WIFI_CONNECTION_LOST__TIMER_HANDLE then
        # Since wifi is off, go back to the INIT state (state before wifi-on):
        call SET_STATE_INIT()
        # don't worry, if WIFI_ON fails, it will eventually give up and restart the radio
    end if
end


##
# UDP CLOSURE
##
# Listen for UDP closures (this really shouldn't happen so let)
const ANOM__UDP_CLOSURE__TIMER_HANDLE = $A2  # Handle is only uint8
event endpoint_closing(reason, endpoint)
    if endpoint != UDP_NULL_ENDPOINT then
        if endpoint = udp_client_endpoint || endpoint = udp_server_endpoint then
            # Log as Hercules Direct Message Error:
            call HR_ERROR_UDP_LOST()
            # Let hercules know we plan on fixing this:
            call HR_WAITING_THEN_CORRECTING()
            # Wait 1s, then try reopening:
            call hardware_set_soft_timer(1000, ANOM__UDP_CLOSURE__TIMER_HANDLE, 1)
        end if
    end if
end
event hardware_soft_timer(handle)
    if handle = ANOM__UDP_CLOSURE__TIMER_HANDLE then
        # Since UDP is disconnected, go back to the CONNECTED state (pre-UDP_CONNECTED):
        call SET_STATE_CONNECTED()  # tries to set up the UDP connection again
        # don't worry, if START_UDP fails, it will eventually give up and restart the radio
    end if
end

##
# BAD UDP METADATA:
##
dim bad_addr, bad_port
event tcpip_udp_data(endpoint, source_address, source_port, data_len, data_data)
    if endpoint = udp_server_endpoint then
        if source_address = NETWORK__SPACECRAFT_ADDRESS then
            bad_addr = 0
        else
            bad_addr = 1
        end if

        if source_port = NETWORK__SPACECRAFT_UDP_PORT then
            bad_port = 0
        else
            bad_port = 1
        end if

        if bad_addr = 1 || bad_port = 1 then
            call RADIO_GND_ERR_BAD_UDP(bad_addr, bad_port, source_address, source_port)
        end if
    end if
end


##
# GARBAGE DATA / ENDPOINT ISSUES:
##

# We got a BGAPI command we didn't recognize (NOTE: UART to Hercules is the
# only BGAPI endpoint):
event endpoint_syntax_error(result, endpoint)
    if endpoint = HERCULES_ENDPOINT then
        # If we're connected to WiFi, tattle to the Earthlings:
        if status__wifi_connected != 0 then # compare as != 0 instead of = 1 since more bit-flip resistant to telling us if we might be connected:
            call RADIO_GND_ERR_BAD_HERC(result)
        end if
    end if
end

# An issue came up with an endpoint:
event endpoint_error(reason, endpoint)
    # If we're connected to WiFi, let Earth know:
    if status__wifi_connected != 0 then # compare as != 0 instead of = 1 since more bit-flip resistant to telling us if we might be connected:
        call RADIO_GND_ERR_BAD_ENDPOINT(reason, endpoint)
    end if
end


##
# CRITICAL ERROR CODES / REASONS
# (thrown from anywhere we might use)
##
event sme_wifi_is_on(result)
    call critical_reset_if_bad_reason(result)
end
event sme_wifi_is_off(result)
    call critical_reset_if_bad_reason(result)
end
event sme_disconnected(reason, hw_interface)
    call critical_reset_if_bad_reason(reason)
end
event sme_connect_failed(reason, hw_interface)
    call critical_reset_if_bad_reason(reason)
end
event endpoint_syntax_error(result, endpoint)
    call critical_reset_if_bad_reason(result)
end
event endpoint_closing(reason, endpoint)
    call critical_reset_if_bad_reason(reason)
end
event endpoint_error(reason, endpoint)
    call critical_reset_if_bad_reason(reason)
end