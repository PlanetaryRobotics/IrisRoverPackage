# Heartbeat (fixed recurring timer) services:
#
# NOTE: There can only be one fixed continuous timer running at a time.
#
# NOTE: All timer-driven recurrent events (those that use heartbeat services)
# will happen at the next `HEARTBEAT_INTERVAL_MS` if their period isn't a round
# multiple of `HEARTBEAT_INTERVAL_MS`.

const TIMER_HANDLE = $8B # Handle is only uint8
const HEARTBEAT_INTERVAL_MS = 5000 # every 5s

# Number of milliseconds between each Heartbeat message sent over the wifi radio
# (won't be faster than `HEARTBEAT_INTERVAL_MS`):
const WIFI_HEARTBEAT_PERIOD_MS = 90000
dim ticks_since_last_wifi_heartbeat
dim sent_at_least_one_wifi_heartbeat # whether we've ever sent a WiFi heartbeat (we want to send the first one ASAP and then start counting from there)

# Number of milliseconds between each Heartbeat message sent to Hercules
# (won't be faster than `HEARTBEAT_INTERVAL_MS`):
const HERCULES_HEARTBEAT_PERIOD_MS = 10000
dim ticks_since_last_hercules_heartbeat

# Regularly send connection connection data updates to hercules (if connected):
const HERCULES_UPDATE_PERIOD_MS = 5000
dim ticks_since_last_hercules_update

# SELF_WD_CHECK (a catch-all-halts reboot):
# If we're not in "good state" by this time, just reboot the whole radio.
# - (We have this because **once** it was observed that an `sme_connected` event
# appeared to be somehow missed and didn't trigger the state driver to the next
# state, leading to a hang. So, to prevent this and any other potential hang
# issues, just have the Radio lightly "watchdog" itself and make sure it's in
# good state at a certain time after boot).
# -This should be set to a pretty long interval to allow all normal catches
#  the chance to perform their own catches.
#   - For safety, make this value several cosmic-ray bit flips away from being
#     converted to a small number.
# - Do this repeatedly (not just once) in case a hang state is entered due to a
#  disconnect while on the surface after we're long into the mission.
#
# TL;DR: Once every long while, we're going to do an *extra* safety check to
# make sure we're in "good state", if not (even if it just happened), too bad
# we're going to assume something's bad and just reset the radio to be safe.
#
# Period is 0x7FFFF. This is 524,287ms (8m44.29s), which is the first number
# greater than 5 mins (the lowest we wanted to accept) whose binary is all ones
# (to be more resilient to cosmic ray flips).
const SELF_WD_CHECK_PERIOD_MS = $7FFFF # Should be at least several minutes. See notes above.
dim ticks_since_last_self_wd_check

# Initialize heartbeat services:
export procedure HEARTBEAT_INIT()
    # Init variables:
    sent_at_least_one_wifi_heartbeat = 0 # we haven't sent one before
    ticks_since_last_wifi_heartbeat = 0
    ticks_since_last_hercules_heartbeat = 0
    ticks_since_last_hercules_update = 0
    ticks_since_last_self_wd_check = 0

    # Kick off the heartbeat timer:
    call hardware_set_soft_timer(HEARTBEAT_INTERVAL_MS, TIMER_HANDLE, 0)
end

##
# RSSI Handling
##
# We need special handling for RSSI (signal_quality) because we both request it
# normally (as part of heartbeat services here) and hijacked it to allow
# Hercules to signal us to release its UDP interlock (see `ground_reports` for
# more details about the insanity for why we need to do this).
# We only want to release the interlock in response to an RSSI command that we
# didn't expect, so Heartbeat services needs to maintain a flag telling us
# whether or not we expected this RSSI (signal_quality) event.
procedure request_rssi_update()
    expecting_rssi_update = 1
    call sme_get_signal_quality()
end

# Monitor the event to clear the flag:
event sme_signal_quality(rssi, hw_interface)
    # To be a bit more bit-flip resilient, clear the flag no matter what,
    # even if it's not currently set since, no matter what, if we get this
    # event, we're no longer expecting an update:
    expecting_rssi_update = 0
    # NOTE: This *has* to be called after the one in `ground_reports` which
    # checks `expecting_rssi_update`. Fortunately, `heartbeat.bgs` comes after
    # `ground_reports` by necessity so this will necessarily happen afterwards.
    # So, DON'T MOVE THIS TO BEFORE `ground_reports`.
end


##
# Actual timer handling (administer all heartbeat services):
##
event hardware_soft_timer(handle)
    # Send a message on every timer expiry (for debugging timers):
    if DEBUG = 1 then
        call hercules_compile_dm__new()
        call hercules_compile_dm__append_message(6, "timer:")
        call hercules_compile_dm__append_hex_buffer(1, handle) # handle is only 1B
        call hercules_compile_dm__send()
    end if

    if handle = TIMER_HANDLE then
        # Update uptime statistic:
        status__heartbeat_timer_tick_uptime = status__heartbeat_timer_tick_uptime + 1

        # Update tick counters (even if we can't send right now):
        ticks_since_last_wifi_heartbeat = ticks_since_last_wifi_heartbeat + 1
        ticks_since_last_hercules_heartbeat = ticks_since_last_hercules_heartbeat + 1
        ticks_since_last_hercules_update = ticks_since_last_hercules_update + 1
        ticks_since_last_self_wd_check = ticks_since_last_self_wd_check + 1

        # Check if we can and should send a WiFi heartbeat:
        # Either:
        # - Wifi is connected and it's time to send another
        # - Wifi is connected (just connected) and we haven't sent anything yet *but* we do have an RSSI value so we now can craft a packet
        if status__wifi_connected != 0 && ((sent_at_least_one_wifi_heartbeat = 0 && status__last_rssi != 0) || (ticks_since_last_wifi_heartbeat * HEARTBEAT_INTERVAL_MS >= WIFI_HEARTBEAT_PERIOD_MS)) then
            call RADIO_GND_HEARTBEAT()
            ticks_since_last_wifi_heartbeat = 0
            sent_at_least_one_wifi_heartbeat = 1
        end if

        # Check if we need to send a heartbeat to Hercules:
        if ticks_since_last_hercules_heartbeat * HEARTBEAT_INTERVAL_MS >= HERCULES_HEARTBEAT_PERIOD_MS then
            call HR_HEARTBEAT()
            ticks_since_last_hercules_heartbeat = 0
        end if

        # Check if we can and should send a connection data update to Hercules:
        if status__wifi_connected != 0 && ticks_since_last_hercules_update * HEARTBEAT_INTERVAL_MS >= HERCULES_UPDATE_PERIOD_MS then
            # Request an RSSI (signal quality) update:
            call request_rssi_update()
            ticks_since_last_hercules_update = 0
        end if

        # Self-WD Check:
        if ticks_since_last_self_wd_check * HEARTBEAT_INTERVAL_MS >= SELF_WD_CHECK_PERIOD_MS then
            if (status__wifi_radio_is_on = 0 || status__wifi_connected = 0 || status__udp_client_active = 0 || status__udp_server_active = 0) then
                # We're not in good state :< ... Reboot!
                call HR_FATAL_SELF_WD_NOT_IN_GOOD_STATE()
                call system_reset(0)
            end if
            ticks_since_last_self_wd_check = 0
        end if
    end if
end