# Heartbeat (fixed recurring timer) services:
#
# NOTE: There can only be one fixed continuous timer running at a time.
#
# NOTE: All timer-driven recurrent events (those that use heartbeat services)
# will happen at the next `HEARTBEAT_INTERVAL_MS` if their period isn't a round
# multiple of `HEARTBEAT_INTERVAL_MS`.

const TIMER_HANDLE = $8B # Handle is only uint8
const HEARTBEAT_INTERVAL_MS = 5000 # every 5s

# Number of milliseconds between each Heartbeat message sent over the wifi radio
# (won't be faster than `HEARTBEAT_INTERVAL_MS`):
const WIFI_HEARTBEAT_PERIOD_MS = 90000
dim ticks_since_last_wifi_heartbeat

# Number of milliseconds between each Heartbeat message sent to Hercules
# (won't be faster than `HEARTBEAT_INTERVAL_MS`):
const HERCULES_HEARTBEAT_PERIOD_MS = 10000
dim ticks_since_last_hercules_heartbeat

# Regularly send connection connection data updates to hercules (if connected):
const HERCULES_UPDATE_PERIOD_MS = 5000
dim ticks_since_last_hercules_update

# SELF_WD_CHECK (a catch-all-halts reboot):
# If we're not in "good state" by this time, just reboot the whole radio.
# - (We have this because **once** it was observed that an `sme_connected` event
# appeared to be somehow missed and didn't trigger the state driver to the next
# state, leading to a hang. So, to prevent this and any other potential hang
# issues, just have the Radio lightly "watchdog" itself and make sure it's in
# good state at a certain time after boot).
# -This should be set to a pretty long interval to allow all normal catches
#  the chance to perform their own catches.
#   - For safety, make this value several cosmic-ray bit flips away from being
#     converted to a small number.
# - Do this repeatedly (not just once) in case a hang state is entered due to a
#  disconnect while on the surface after we're long into the mission.
#
# TL;DR: Once every long while, we're going to do an *extra* safety check to
# make sure we're in "good state", if not (even if it just happened), too bad
# we're going to assume something's bad and just reset the radio to be safe.
#
# Period is 0x7FFFF. This is 524,287ms (8m44.29s), which is the first number
# greater than 5 mins (the lowest we wanted to accept) whose binary is all ones
# (to be more resilient to cosmic ray flips).
const SELF_WD_CHECK_PERIOD_MS = $7FFFF # Should be at least several minutes. See notes above.
dim ticks_since_last_self_wd_check

const RADIO_GND_HB_HEADER_LEN = 8  # "RADIO:R-"
const RADIO_GND_HB_LEN = 22  # Fixed length (unfortunately we can't just add consts): RADIO_GND_HB_HEADER_LEN + RSSI (3) + 1 + State abbr (4) + 2 + Raw hex of bad syntax count (4)
dim radio_gnd_hb_buffer(22)  # Must be same as above (unfortunately, we can't allocate with a const variable)


# Initialize heartbeat services:
export procedure HEARTBEAT_INIT()
    # Init variables:
    ticks_since_last_wifi_heartbeat = 0
    ticks_since_last_hercules_heartbeat = 0
    ticks_since_last_hercules_update = 0
    ticks_since_last_self_wd_check = 0

    # Prepopulate the RADIO_HEARTBEAT HEADER (since it never changes):
    radio_gnd_hb_buffer(0:RADIO_GND_HB_HEADER_LEN) = "RADIO:R-"
    # Also prepopulate the fixed separators:
    radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN+3:1) = "|"
    radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN+3+1+4:2) = "|h"

    # Kick off the heartbeat timer:
    call hardware_set_soft_timer(HEARTBEAT_INTERVAL_MS, TIMER_HANDLE, 0)
end


## RADIO-GND HEARTBEAT:
# Crafts and issues a Radio-Ground Heartbeat
# (tells Earth that the radio is alive, even if something may have happened to
# the other components ... or potentially if Herc's TX buffer got screwed but
# its RX may still be working).
dim tmp
procedure RADIO_GND_HEARTBEAT()
    # Add RSSI information as ASCII (3 digits):
    tmp = -1 * status__last_rssi # convert to positive int
    radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN:1) = (tmp / 100) + 48
    radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN+1:1) = ((tmp / 10) - (tmp/100)*10) + 48
    radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN+2:1) = (tmp - (tmp/10)*10) + 48

    # Copy over state abbreviation buffer:
    memcpy(radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN+4), state_4B_abbr(0), 4)

    # Copy over raw hex of the hercules syntax fault count:
    radio_gnd_hb_buffer(RADIO_GND_HB_HEADER_LEN+10:4) = status__hercules_syntax_err_count

    # Send heartbeat to Earth:
    call endpoint_send(udp_client_endpoint, RADIO_GND_HB_LEN, radio_gnd_hb_buffer(0:RADIO_GND_HB_LEN))
end


##
# Actual timer handling (administer all heartbeat services):
##
event hardware_soft_timer(handle)
    # Send a message on every timer expiry (for debugging timers):
    if DEBUG = 1 then
        call hercules_compile_dm__new()
        call hercules_compile_dm__append_message(6, "timer:")
        call hercules_compile_dm__append_hex_buffer(1, handle) # handle is only 1B
        call hercules_compile_dm__send()
    end if

    if handle = TIMER_HANDLE then
        # Update tick counters (even if we can't send right now):
        ticks_since_last_wifi_heartbeat = ticks_since_last_wifi_heartbeat + 1
        ticks_since_last_hercules_heartbeat = ticks_since_last_hercules_heartbeat + 1
        ticks_since_last_hercules_update = ticks_since_last_hercules_update + 1
        ticks_since_last_self_wd_check = ticks_since_last_self_wd_check + 1

        # Check if we can and should send a WiFi heartbeat:
        if status__wifi_connected = 1 && ticks_since_last_wifi_heartbeat * HEARTBEAT_INTERVAL_MS >= WIFI_HEARTBEAT_PERIOD_MS then
            call RADIO_GND_HEARTBEAT()
            ticks_since_last_wifi_heartbeat = 0
        end if

        # Check if we need to send a heartbeat to Hercules:
        if ticks_since_last_hercules_heartbeat * HEARTBEAT_INTERVAL_MS >= HERCULES_HEARTBEAT_PERIOD_MS then
            call HR_HEARTBEAT()
            ticks_since_last_hercules_heartbeat = 0
        end if

        # Check if we can and should send a connection data update to Hercules:
        if status__wifi_connected = 1 && ticks_since_last_hercules_update * HEARTBEAT_INTERVAL_MS >= HERCULES_UPDATE_PERIOD_MS then
            # Request a signal quality update:
            call sme_get_signal_quality()
            ticks_since_last_hercules_update = 0
        end if

        # Self-WD Check:
        if ticks_since_last_self_wd_check * HEARTBEAT_INTERVAL_MS >= SELF_WD_CHECK_PERIOD_MS then
            if (status__wifi_radio_is_on = 0 || status__wifi_connected = 0 || status__udp_client_active = 0 || status__udp_server_active = 0) then
                # We're not in good state :< ... Reboot!
                call HR_FATAL_SELF_WD_NOT_IN_GOOD_STATE()
                call system_reset(0)
            end if
            ticks_since_last_self_wd_check = 0
        end if
    end if
end