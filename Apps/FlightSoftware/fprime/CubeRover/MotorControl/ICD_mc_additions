// --- ICD_MotorControl.h

uint32_t regSizeMap(MC_ICD_RegAddr reg);
void getReg(MC_ICD_RegStruct *mc, MC_ICD_RegAddr reg, void *data);
void setReg(MC_ICD_RegStruct *mc, MC_ICD_RegAddr reg, void *data);

// --- ICD_MotorControl.c

uint32_t regSizeMap(MC_ICD_RegAddr reg)
{
    switch (reg)
    {
        case MC_REG_I2C_ADDRESS:
        case MC_REG_TARGET_SPEED:
        case MC_REG_MC_CTRL:
        case MC_REG_MC_FAULT:
        case MC_REG_MC_STATUS:
            return 1;
        case MC_REG_P_CURRENT:
        case MC_REG_I_CURRENT:
        case MC_REG_P_SPEED:
        case MC_REG_I_SPEED:
        case MC_REG_ACC_RATE:
        case MC_REG_DEC_RATE:
            return 2;
        case MC_REG_TARGET_POSITION:
        case MC_REG_CURRENT_POSITION:
        case MC_REG_MOTOR_CURRENT: // TODO: CHeck if this retuns 2 byts or 4!? 2 from thismethod 4 from micheal's update current tlm code
            return 4;
        default:
            return 0;
    }
}

void getReg(MC_ICD_RegStruct *mc, MC_ICD_RegAddr reg, void *data)
{
    switch(reg)
    {
    case MC_REG_TARGET_POSITION:
        data = &(mcReg->mc_target_pos);
        break;
    case MC_REG_TARGET_SPEED:
        data = &(mcReg->mc_target_speed);
        break;
    case MC_REG_CURRENT_POSITION:
        data = &(mcReg->mc_curr_pos);
        break;
    case MC_REG_CURRENT_SPEED:
        data = &(mcReg->mc_curr_speed);
        break;
    case MC_REG_MOTOR_CURRENT:
        data = &(mcReg->mc_curr_current);
        break;
    case MC_REG_P_CURRENT:
        data = &(mcReg->mc_current_p_val);
        break;
    case MC_REG_I_CURRENT:
        data = &(mcReg->mc_current_i_val);
        break;
    case MC_REG_P_SPEED:
        data = &(mcReg->mc_speed_p_val);
        break;
    case MC_REG_I_SPEED:
        data = &(mcReg->mc_speed_i_val);
        break;
    case MC_REG_ACC_RATE:
        data = &(mcReg->mc_acc_val);
        break;
    case MC_REG_DEC_RATE:
        data = &(mcReg->mc_dec_val);
        break;
    case MC_REG_MC_CTRL:
        data = &(mcReg->mc_ctrlReg);
        break;
    case MC_REG_MC_STATUS:
        data = &(mcReg->mc_stateReg);
        break;
    case MC_REG_MC_FAULT:
        data = &(mcReg->mc_faultReg);
        break;
    default:
        data = NULL;
        break;
    }
}

void setReg(MC_ICD_RegStruct *mc, MC_ICD_RegAddr reg, void *data)
{
    switch(reg)
    {
    case MC_REG_TARGET_POSITION:
        mcReg->mc_target_pos = *(int32_t *)data;
        break;
    case MC_REG_TARGET_SPEED:
        mcReg->mc_target_speed = *(uint8_t *)data;
        break;
    case MC_REG_CURRENT_POSITION:
        mcReg->mc_curr_pos = *(int32_t *)data;
        break;
    case MC_REG_CURRENT_SPEED:
        mcReg->mc_curr_speed = *(uint8_t *)data;
        break;
    case MC_REG_MOTOR_CURRENT:
        mcReg->mc_curr_current = *(int16_t *)data;
        break;
    case MC_REG_P_CURRENT:
        mcReg->mc_current_p_val = *(uint16_t *)data;
        break;
    case MC_REG_I_CURRENT:
        mcReg->mc_current_i_val = *(uint16_t *)data;
        break;
    case MC_REG_P_SPEED:
        mcReg->mc_speed_p_val = *(uint16_t *)data;
        break;
    case MC_REG_I_SPEED:
        mcReg->mc_speed_i_val = *(uint16_t *)data;
        break;
    case MC_REG_ACC_RATE:
        mcReg->mc_acc_val = *(uint16_t *)data;
        break;
    case MC_REG_DEC_RATE:
        mcReg->mc_dec_val = *(uint16_t *)data;
        break;
    case MC_REG_MC_CTRL:
        mcReg->mc_ctrlReg = *(uint8_t *)data;
        break;
    case MC_REG_MC_STATUS:
        mcReg->mc_stateReg = *(uint8_t *)data;
        break;
    case MC_REG_MC_FAULT:
        mcReg->mc_faultReg = *(uint8_t *)data;
        break;
    default:
        break;
    }
}
