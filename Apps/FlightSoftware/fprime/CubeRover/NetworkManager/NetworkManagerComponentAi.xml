<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="file:../xml/ISF_Component_Schema.rnc" type="compact"?>

<component name="NetworkManager" kind="passive" namespace="CubeRover" modeler="true">
    <import_port_type>Fw/Buffer/BufferSendPortAi.xml</import_port_type>
    <import_port_type>Fw/Log/LogPortAi.xml</import_port_type>
    <import_port_type>Fw/Log/LogTextPortAi.xml</import_port_type>
    <import_port_type>Fw/Cmd/CmdPortAi.xml</import_port_type>
    <import_port_type>Fw/Cmd/CmdRegPortAi.xml</import_port_type>
    <import_port_type>Fw/Cmd/CmdResponsePortAi.xml</import_port_type>
    <import_port_type>Fw/Time/TimePortAi.xml</import_port_type>
    <import_port_type>Svc/Sched/SchedPortAi.xml</import_port_type>
    <import_port_type>CubeRover/CubeRoverPorts/WatchdogResetRequest/WatchdogResetRequestPortAi.xml</import_port_type>
    <ports>

        <!-- Input ports -->
        <port name="downlink" data_type="Fw::BufferSend" kind="guarded_input" max_number="2">
            <comment>GroundInterface sends packets to NM for downlink</comment>
        </port>

        <port name="schedIn" data_type="Svc::Sched" kind="guarded_input" max_number="1">
            <comment>Clock from RateGroupMedFreq. Every clock tick need to interllay check:
                RSSI, downlink queue, uplink (command) queue
            </comment>
        </port>

        <!-- Command Ports -->
        <port name="CmdReg" data_type="Fw::CmdReg" kind="output" role="CmdRegistration" max_number="1">
            <comment>
            Command Registration Port
            </comment>
        </port>

        <port name="CmdStatus" data_type="Fw::CmdResponse" kind="output" role="CmdResponse" max_number="1">
            <comment>
            Command Response Port
            </comment>
        </port>

        <port name="CmdDisp" data_type="Fw::Cmd" kind="input" role="Cmd" max_number="1">
            <comment>
            Command Input Port
            </comment>
        </port>

        <!-- Output ports -->
        <port name="uplink" data_type="Fw::BufferSend" kind="output" max_number="1">
            <comment>NM sends received packets to GroundInterface</comment>
        </port>
            
        <port name="WatchdogResetRequest" data_type="CubeRoverPorts::WatchdogResetRequest" kind="output">
            <comment>
                This allows other components to request the Watchdog interface to reset some hardware
            </comment>
        </port>


        <!-- TODO: MODE -->

        <!-- Standard F prime ports -->
        <port name="Log" data_type="Fw::Log"  kind="output" role="LogEvent"    max_number="1">
        </port>

        <port name="LogText" data_type="Fw::LogText"  kind="output" role="LogTextEvent"    max_number="1">
        </port>

        <port name="Time" data_type="Time"  kind="output" role="TimeGet"    max_number="1">
        </port>

        <!-- TODO: HEALTH -->

    </ports>

    <commands>
        <command kind="sync" opcode="0x0" mnemonic="Set_Radio_Communications_Mode">
            <comment>
                Sets the Radio communications mode. For Radio debugging and UART/DFU programming.
            </comment>
            <args>
                <arg name="mode" type="ENUM">
                    <enum name="nm_radio_communications_mode">
                        <item name="HERCULES" value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="EXTERNAL" value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
            </args>
        </command>
    </commands>

    <telemetry>
        <channel id="0" name="RSSI" data_type="I8">
            <comment>Received Signal Strength Indication abt WF121 connection to AP in dB</comment>
        </channel>
        <channel id="1" name="SNR" data_type="I8">
            <comment>Signal to noise radio</comment>
        </channel>
        <channel id="2" name="PktRecv" data_type="U32">
            <comment>Number of packets received (uplink)</comment>
        </channel>
        <channel id="3" name="PktSent" data_type="U32">
            <comment>Number of packets sent (downlink)</comment>
        </channel>
		<channel id="4" name="WIFIErrorStatus" data_type="ENUM">
		    <comment>Returned Error code of WIFI chip</comment>
		    <!-- Matches `ErrorCode` from `Wf121.hpp` -->
		    <enum name="WIFIErrorCode">
				<item name="wec_NO_ERROR" value="0" />
				<item name="wec_TRY_AGAIN" value="1" />
				<item name="wec_INVALID_PARAMETER" value="384" comment="This error code indicates that a command contained an invalid parameter" />
				<item name="wec_DEVICE_WRONG_STATE" value="385" comment="This error code indicates that the device is in wrong state to accept commands." />
				<item name="wec_OUT_OF_MEMORY" value="386" comment="This error indicates that the device has run out of memory." />
				<item name="wec_FEATURE_NOT_IMPLEMENTED" value="387" comment="This error indicates that the feature in question has not been implemented." />
				<item name="wec_COMMAND_NOT_RECOGNIZED" value="388" comment="This error indicates that the issued command was not recognized." />
				<item name="wec_TIMEOUT" value="389" comment="This error indicates that a command or procedure failed due to timeout.This error code is generated e.g. if you send an incomplete command to the Wi-Fi module - after the timeout of 1 second this error code is sent to the host transported by the event .endpoint_syntax_errorThis error code is generated also e.g. when the maximum number of retry attempts (10) to try to connect to a wireless network have been executed. A typical example of such a case might be when the issued password is invalid, in which case the error code is transported by the event .wifi_evt_sme_connect_failed" />
				<item name="wec_UNSPECIFIED_ERROR" value="390" comment="This error code is generated when an unspecified error is detected." />
				<item name="wec_HARDWARE_FAILURE" value="391" comment="This error code is generated when a hardware failure is detected." />
				<item name="wec_INTERNAL_BUFFER_FULL" value="392" comment="This error code is generated the a command was not accepted due to full internal buffers." />
				<item name="wec_DISCONNECTED" value="393" comment="This error code is generated when a command or procedure has failed due to disconnection." />
				<item name="wec_TOO_MANY_REQUEST" value="394" comment="This error code is generated when there are too many simultaneous requests." />
				<item name="wec_ACCESS_POINT_NOT_IN_SCANLIST" value="395" comment="This error code is generated when the defined Access Point is not found from the scanlist." />
				<item name="wec_INVALID_PASSWORD" value="396" comment="This error code is generated in the following cases:1) you try to connect to a secured network without setting the password or the password is too short2) you try to start a secured AP without setting the password or the password is too short3) you try to set a 64-character PSK with non-hex characters4) you try to set an invalid WEP key (invalid characters or invalid length)Notice that WPA does not contain any standard way for the Access Point to communicate to the station that the password is invalid. The Access Point just disconnects the client during authentication if the password is found invalid. Some stations take an educated guess that this probably means the password is incorrect. WF121 simply retries the authentication until it exceeds the maximum amount of retries (10) which then causes the 0x0185 Timeout Error." />
				<item name="wec_AUTHENTIFICATION_FAILURE" value="397" comment="This error code is generated when the WPA/WPA2 authentication has failed." />
				<item name="wec_OVERFLOW" value="398" comment="This error code is generated when an overflow has been detected." />
				<item name="wec_MULTIPLE_PBC_SESSIONS" value="399" comment="This error code is generated when multiple PBC (Push Button Configuration) sessions have been detected." />
				<item name="wec_ETHERNET_NOT_CONNECTED" value="400" comment="This error code is generated when the Ethernet cable is not connected" />
				<item name="wec_ETHERNET_ROUTE_NOT_SET" value="401" comment="This error code is generated if the Ethernet route is not set" />
				<item name="wec_WRONG_OPERATING_MODE" value="402" comment="This error code is generated if the operating mode is wrong for the issued command" />
				<item name="wec_WIFI_NOT_FOUND" value="403" comment="This error code is generated if the requested resource was not found." />
				<item name="wec_WIFI_NOT_ALREADY_EXIST" value="404" comment="This error is generated if the requested resource already exists." />
				<item name="wec_WIFI_INVALID_CONFIGURATION" value="405" comment="This error code is generated if the current configuration is invalid." />
				<item name="wec_WIFI_ACCESS_POINT_LOST" value="406" comment="This error code is generated if the connection to an Access Point is lost." />
				<item name="wec_PS_STORE_FULL" value="769" comment="This error is generated if the Flash which is reserved for the PS (Persistent Store) is full." />
				<item name="wec_PS_KEY_NOT_FOUND" value="770" comment="This error is generated if the PS key (Persistent Store key) was not found." />
				<item name="wec_I2C_WRITE_ALREADY_IN_PROGRESS" value="771" comment="This error is generated if I2C transmission was initiated while a transmission was already in progress." />
				<item name="wec_I2C_ACK_MISSING" value="772" comment="This error is generated if an acknowledgement for I2C was not received." />
				<item name="wec_FLASH_WRITE_FAILED" value="776" comment="This error code is generated if writing to Flash failed." />
				<item name="wec_FILE_NOT_OPENED" value="773" comment="This error code is generated if an access was attempted to an unopened file." />
				<item name="wec_FILE_NOT_FOUND" value="774" comment="This error code is generated if the requested file was not found in the SD card." />
				<item name="wec_DISK_ERROR" value="775" comment="This error code is generated if an SD card error was detected of if the SD card is full" />
				<item name="wec_TCP_IP_SUCCESS" value="512" comment="This code indicates that no error was detected." />
				<item name="wec_TCP_IP_OUT_OF_MEMORY" value="513" comment="This error code is generated when the system has run out of memory." />
				<item name="wec_TCP_IP_BUFFER_ERROR" value="514" comment="This error code is generated when handling of buffers has failed" />
				<item name="wec_TCP_IP_TIMEOUT" value="515" comment="This error code is generated when a timeout has been detected." />
				<item name="wec_TCP_IP_ROUTING" value="516" comment="This error code is generated when a route could not be found." />
				<item name="wec_TCP_IP_IN_PROGRESS" value="517" comment="This error code is generated when an operation is in progress" />
				<item name="wec_TCP_IP_ILLEGAL_VALUE" value="518" comment="This error code is generated when the issued value is deemed illegal." />
				<item name="wec_TCP_IP_WOULD_BLOCK" value="519" comment="This error code is generated when an operation blocks." />
				<item name="wec_TCP_IP_ADDRESS_IN_USE" value="520" comment="This error code is generated when the issued address is already in use" />
				<item name="wec_TCP_IP_ALREADY_CONNECTED" value="521" comment="This error code is generated when the Wi-Fi module is already connected" />
				<item name="wec_TCP_IP_CONNECTION_ABORTED" value="522" comment="This error code is generated when a connection is aborted." />
				<item name="wec_TCP_IP_CONNECTION_RESET" value="523" comment="This error code is generated when a connection has been reset" />
				<item name="wec_TCP_IP_CONNECTION_CLOSED" value="524" comment="This error code is generated when a connection has been closed." />
				<item name="wec_TCP_IP_NOT_CONNECTED" value="525" comment="This error code is generated when the Wi-Fi module is not connected." />
				<item name="wec_TCP_IP_ILLEGAL_ARGUMENT" value="526" comment="This error code is generated if an illegal argument was issued." />
				<item name="wec_TCP_IP_INTERFACE_LEVEL_ERROR" value="527" comment="This error code is generated if an interface error was detected" />
				<item name="wec_TCP_IP_UNKNOWN_HOST" value="640" comment="This error is generated if an unknown host is detected." />
				<item name="wec_SERVICE_NOT_RUNNING" value="528" comment="This error code is generated if the specified service is not running." />
				<item name="wec_SERVICE_RUNNING" value="529" comment="This error code is generated if the specified service is already running" />
				<item name="wec_HOSTNAME_NOT_SET" value="530" comment="This error code is generated if the hostname has not been set" />
				<item name="wec_HOSTNAME_CONFLICT" value="531" comment="This error code is generated if a hostname conflict was detected." />
        	</enum>
        </channel>
         <channel id="5" name="WIFIStateStatus" data_type="ENUM">
            <comment>Returned State Transition code of WIFI chip</comment>
                <enum name="WIFIState">
                    <!--This enum should be synced up with Wf121::DirectMessage::RadioSwState. Actual conversion to this downlink-type happens in `NetworkManagerComponentImpl::convertRadioState2WifiState` though.-->
                    <item name="nm_NONE" value="0x00" comment="None (we haven't received any state update yet)." />
                    <item name="nm_BAD_MESSAGE" value="0x0F" comment="The last state update from the Radio contained a valid message header but the body was corrupted (didn't match any known message). Bad state message was received (we don't know what's really going on inside the Radio rn)." />
                    <item name="nm_BOOT" value="0x10" comment="Booted but hasn't initialized its state_driver yet." />
                    <item name="nm_INIT" value="0x20" comment="In the initial state but WiFi radio isn't powered up yet." />
                    <item name="nm_WIFI_ON" value="0x30" comment="Radio hardware (power amplifier) has turned on successfully - radio has enough power to work." />
                    <item name="nm_CONNECTED" value="0x40" comment="Radio is connected to the network (ARP, etc) but UDP client &amp; socket aren't active yet." />
                    <item name="nm_UDP_CONNECTED" value="0x50" comment="UDP client &amp; socket are active. Radio is ready to communicate." />
                </enum>
        </channel>
    </telemetry>

    <events>
        <event id="0" name="StateChange" severity="ACTIVITY_HI" format_string="WF121 State Changed %d -> %d">
            <comment>Emit event when ever a state transition occurs within the WF121</comment>
            <args>
                <arg name="from_state" type="ENUM">
                    <enum name="networkmanager_state_from">
                        <!--NOTE: This enum NEEDS to be synced up with WIFIState enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="from_NONE" value="0x00" comment="None (we haven't received any state update yet)." />
                        <item name="from_BAD_MESSAGE" value="0x0F" comment="The last state update from the Radio contained a valid message header but the body was corrupted (didn't match any known message). Bad state message was received (we don't know what's really going on inside the Radio rn)." />
                        <item name="from_BOOT" value="0x10" comment="Booted but hasn't initialized its state_driver yet." />
                        <item name="from_INIT" value="0x20" comment="In the initial state but WiFi radio isn't powered up yet." />
                        <item name="from_WIFI_ON" value="0x30" comment="Radio hardware (power amplifier) has turned on successfully - radio has enough power to work." />
                        <item name="from_CONNECTED" value="0x40" comment="Radio is connected to the network (ARP, etc) but UDP client &amp; socket aren't active yet." />
                        <item name="from_UDP_CONNECTED" value="0x50" comment="UDP client &amp; socket are active. Radio is ready to communicate." />
                    </enum>
                </arg>
                <arg name="to_state" type="ENUM">
                    <enum name="networkmanager_state_to">
                        <!--NOTE: This enum NEEDS to be synced up with WIFIState enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="to_NONE" value="0x00" comment="None (we haven't received any state update yet)." />
                        <item name="to_BAD_MESSAGE" value="0x0F" comment="The last state update from the Radio contained a valid message header but the body was corrupted (didn't match any known message). Bad state message was received (we don't know what's really going on inside the Radio rn)." />
                        <item name="to_BOOT" value="0x10" comment="Booted but hasn't initialized its state_driver yet." />
                        <item name="to_INIT" value="0x20" comment="In the initial state but WiFi radio isn't powered up yet." />
                        <item name="to_WIFI_ON" value="0x30" comment="Radio hardware (power amplifier) has turned on successfully - radio has enough power to work." />
                        <item name="to_CONNECTED" value="0x40" comment="Radio is connected to the network (ARP, etc) but UDP client &amp; socket aren't active yet." />
                        <item name="to_UDP_CONNECTED" value="0x50" comment="UDP client &amp; socket are active. Radio is ready to communicate." />
                    </enum>
                </arg>
            </args>
        </event>
        <event id="1" name="ExecuteCallbackError" severity="WARNING_HI" format_string="ExecuteCallBackError %d">
            <comment>Emit event when there is an error executing a WF121 callback</comment>
            <args>
                <arg name="ErrorCode" type="U16"/>
            </args>
        </event>
        <event id="2" name="WF121InitializationFailed" severity="FATAL" format_string="WF121 Failed to initialize">
            <comment>Emit event when there is an error executing a WF121 callback</comment>
        </event>

        <event id="3" name="RadioCommunicationsModeChange" severity="ACTIVITY_HI" format_string="Radio Communications Mode Changed %s -> %s">
            <comment>Emit event whenever the radio communications mode is changed.</comment>
            <args>
                <arg name="from_mode" type="ENUM">
                    <enum name="nm_radio_communications_mode_from">
                        <!--NOTE: This enum NEEDS to be synced up with nm_radio_communications_mode enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="from_HERCULES"  value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="from_EXTERNAL"  value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
                <arg name="to_mode" type="ENUM">
                    <enum name="nm_radio_communications_mode_to">
                        <!--NOTE: This enum NEEDS to be synced up with nm_radio_communications_mode enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="to_HERCULES"  value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="to_EXTERNAL"  value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
            </args>
        </event>

        <event id="4" name="RadioCommunicationsModeState" severity="ACTIVITY_LO" format_string="Radio Communications Mode now: %s">
            <comment>Current state of the Radio Communications mode. Emitted anytime a change is requested, even if a change isn't performed because the radio is already in the desired mode.</comment>
            <args>
                <arg name="mode" type="ENUM">
                    <enum name="nm_radio_communications_mode_now">
                        <!--NOTE: This enum NEEDS to be synced up with nm_radio_communications_mode enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="now_HERCULES"  value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="now_EXTERNAL"  value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
            </args>
        </event>
    </events>



</component>
