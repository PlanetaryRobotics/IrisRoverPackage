<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="file:../xml/ISF_Component_Schema.rnc" type="compact"?>

<component name="NetworkManager" kind="passive" namespace="CubeRover" modeler="true">
    <import_port_type>Fw/Buffer/BufferSendPortAi.xml</import_port_type>
    <import_port_type>Fw/Log/LogPortAi.xml</import_port_type>
    <import_port_type>Fw/Log/LogTextPortAi.xml</import_port_type>
    <import_port_type>Fw/Cmd/CmdPortAi.xml</import_port_type>
    <import_port_type>Fw/Cmd/CmdRegPortAi.xml</import_port_type>
    <import_port_type>Fw/Cmd/CmdResponsePortAi.xml</import_port_type>
    <import_port_type>Fw/Time/TimePortAi.xml</import_port_type>
    <import_port_type>Svc/Sched/SchedPortAi.xml</import_port_type>
    <import_port_type>CubeRover/CubeRoverPorts/WatchdogResetRequest/WatchdogResetRequestPortAi.xml</import_port_type>
    <ports>

        <!-- Input ports -->
        <port name="downlink" data_type="Fw::BufferSend" kind="guarded_input" max_number="2">
            <comment>GroundInterface sends packets to NM for downlink</comment>
        </port>

        <port name="schedIn" data_type="Svc::Sched" kind="guarded_input" max_number="1">
            <comment>Clock from RateGroupMedFreq. Every clock tick need to interllay check:
                RSSI, downlink queue, uplink (command) queue
            </comment>
        </port>

        <!-- Command Ports -->
        <port name="CmdReg" data_type="Fw::CmdReg" kind="output" role="CmdRegistration" max_number="1">
            <comment>
            Command Registration Port
            </comment>
        </port>

        <port name="CmdStatus" data_type="Fw::CmdResponse" kind="output" role="CmdResponse" max_number="1">
            <comment>
            Command Response Port
            </comment>
        </port>

        <port name="CmdDisp" data_type="Fw::Cmd" kind="input" role="Cmd" max_number="1">
            <comment>
            Command Input Port
            </comment>
        </port>

        <!-- Output ports -->
        <port name="uplink" data_type="Fw::BufferSend" kind="output" max_number="1">
            <comment>NM sends received packets to GroundInterface</comment>
        </port>
            
        <port name="WatchdogResetRequest" data_type="CubeRoverPorts::WatchdogResetRequest" kind="output">
            <comment>
                This allows other components to request the Watchdog interface to reset some hardware
            </comment>
        </port>


        <!-- TODO: MODE -->

        <!-- Standard F prime ports -->
        <port name="Log" data_type="Fw::Log"  kind="output" role="LogEvent"    max_number="1">
        </port>

        <port name="LogText" data_type="Fw::LogText"  kind="output" role="LogTextEvent"    max_number="1">
        </port>

        <port name="Time" data_type="Time"  kind="output" role="TimeGet"    max_number="1">
        </port>

        <!-- TODO: HEALTH -->

    </ports>

    <commands>
        <command kind="sync" opcode="0x00" mnemonic="Set_Radio_Communications_Mode">
            <comment>
                Sets the Radio communications mode. For Radio debugging and UART/DFU programming.
            </comment>
            <args>
                <arg name="mode" type="ENUM">
                    <enum name="nm_radio_communications_mode">
                        <item name="HERCULES" value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="EXTERNAL" value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
            </args>
        </command>
        <command kind="sync" opcode="0x01" mnemonic="Set_Radio_Uart_Baud">
            <comment>
            Sets the (peristent) baud rate for UART communication with the 
            WF121 Radio. Note: if Radio-Hercules comms appear not to work 
            properly after issuing this command, you may have to reboot. 
            
            A `RadioUartBaudRateChange` event is emitted when 
            called (if no change was made, `changeMade=FALSE`).
            </comment>
            <args>
                <arg name="newBaud" type="U32" />
            </args>
        </command>
        <command kind="sync" opcode="0x02" mnemonic="Set_Radio_BgApi_Passthrough">
            <comment>
                If TRUE: 
                Turns off the state machine in Hercules managing UART BGAPI 
                communications with the WF121 Radio and begins forwarding all 
                BGAPI responses and events to Ground via the 
                `WatchDog DebugPrintf` pipeline. 
                During this time, the `Send_BgApi_Command` CAN be used to send 
                BGAPI commands to the Radio.

                If FALSE: 
                Turns back on and resets the state machine in Hercules managing 
                UART BGAPI communications with the WF121 Radio and stops 
                forwarding all BGAPI responses and events to Ground via the 
                `WatchDog DebugPrintf` pipeline. 
                During this time, the `Send_BgApi_Command` CANNOT be used to 
                send BGAPI commands to the Radio.

                Changes are only made if the passthrough mode is being changed. 
            
                A `RadioBgApiPassthroughChange` event is emitted when 
                called (if no change was made, `changeMade=FALSE`).
            </comment>
            <args>
                <arg name="passthrough" type="bool" />
            </args>
        </command>

        <command kind="sync" opcode="0x03" mnemonic="Send_BgApi_Command">
            <comment>
                Forwards the given BGAPI command (packed as binary) to the 
                Radio. 
                A `RadioSendBgApiCommandAck` event is emitted when this command is received
            </comment>
            <args>
                <arg name="crc32" type="U32">
                    <comment>
                        CRC32 of the packed BGAPI packet, as a uint32.
                    </comment>
                </arg>
                <arg name="packetId" type="U32">
                    <comment>
                        ID of the packet, assigned by ground. This is just 
                        included in the response event so ground can know what 
                        packet to resend if it needs to resend a packet.
                    </comment>
                </arg>
                <arg name="expectResponse" type="ENUM">
                    <comment>
                        Whether or not we should expect (and wait for) a BGAPI 
                        response from the Radio after sending this command 
                        (certain BGAPI DFU flashing operations don't return a 
                        response). Setting this correctly will ensure fast and
                        reliable data transfers. Using an enum here instead of
                        a bool because it's easier to detect corruption with
                    </comment>
                    <enum name="nm_radio_send_bgapi_command_expect_response">
                        <item name="nm_bgapi_cmd_EXPECT_RESPONSE"  value="0xFFFF9E59" comment="Hercules SHOULD expect the Radio to return a response to this command." />
                        <item name="nm_bgapi_cmd_DONT_EXPECT_RESPONSE"  value="0xBA1D0000" comment="Hercules SHOULD NOT expect the Radio to return a response to this command." />
                    </enum>
                </arg>
                <arg name="bgapiPacket" type="Fw::IrisCmdByteStringArg" size="134">
                    <comment>
                        The data as a 'byte string', with a MAX length of 134B 
                        (4B of BGAPI header + 1B 'BGAPI uint8array' length byte 
                        + 128B of data + 1B null termination). To increase this 
                        limit, you'll likely need to bump up 
                        'FW_COM_BUFFER_MAX_SIZE' and 'FW_CMD_STRING_MAX_SIZE' 
                        in 'fprime/Fw/Cfg/Config.hpp' (read the notes there for 
                        more information about required padding). Note that 
                        increasing the max string size has a pretty big effect 
                        on the total program size in memory.
 
 
                        Here string here just means a null terminated char 
                        array. To be specific, the NULL termination is EXCLUDED 
                        from the length and does NOT need to be (and should not 
                        be) included in the data sent. That is, if length is 3, 
                        the data sent would be [0x00, 0x03, byte0, byte1, byte2] 
                        and the memory in the `CmdStringArg->m_buf` inside 
                        Hercules would look like: [byte0, byte1, byte2, NULL].
                    </comment>
                </arg>
            </args>
        </command>

        <command kind="sync" opcode="0x04" mnemonic="Downlink_BgApi_Command_Records">
            <comment>
                Triggers a `RadioBgApiCommandRecords` event to see what BgApi
                packets have been processed recently and what the outcomes were.
            </comment>
        </command>
    </commands>

    <telemetry>
        <channel id="0" name="RSSI" data_type="I8">
            <comment>Received Signal Strength Indication abt WF121 connection to AP in dB</comment>
        </channel>
        <channel id="1" name="NumCompleteDirectMessages" data_type="U8">
            <!-- This channel spot used to be SNR but we don't actually have live access to that.
            We only get it when scanning for networks which is now handled internally by the Radio. -->
            <comment>Number of Successfully Parsed Direct Messages from the Radio (a basic vital for if Radio-Herc comms are still working).</comment>
        </channel>
        <channel id="2" name="PktRecv" data_type="U32">
            <comment>Number of packets received (uplink)</comment>
        </channel>
        <channel id="3" name="PktSent" data_type="U32">
            <comment>Number of packets sent (downlink)</comment>
        </channel>
        <!-- DEPRECTATED to make room for more telem. Don't actually use this channel anymore since BGAPI errors are handled internally by NetworkInterface.
		<channel id="4" name="WIFIErrorStatus" data_type="ENUM">
		    <comment>Returned Error code of WIFI chip</comment>
		    --><!-- Matches `ErrorCode` from `Wf121.hpp` --><!--
		    <enum name="WIFIErrorCode">
				<item name="wec_NO_ERROR" value="0" />
				<item name="wec_TRY_AGAIN" value="1" />
				<item name="wec_INVALID_PARAMETER" value="384" comment="This error code indicates that a command contained an invalid parameter" />
				<item name="wec_DEVICE_WRONG_STATE" value="385" comment="This error code indicates that the device is in wrong state to accept commands." />
				<item name="wec_OUT_OF_MEMORY" value="386" comment="This error indicates that the device has run out of memory." />
				<item name="wec_FEATURE_NOT_IMPLEMENTED" value="387" comment="This error indicates that the feature in question has not been implemented." />
				<item name="wec_COMMAND_NOT_RECOGNIZED" value="388" comment="This error indicates that the issued command was not recognized." />
				<item name="wec_TIMEOUT" value="389" comment="This error indicates that a command or procedure failed due to timeout.This error code is generated e.g. if you send an incomplete command to the Wi-Fi module - after the timeout of 1 second this error code is sent to the host transported by the event .endpoint_syntax_errorThis error code is generated also e.g. when the maximum number of retry attempts (10) to try to connect to a wireless network have been executed. A typical example of such a case might be when the issued password is invalid, in which case the error code is transported by the event .wifi_evt_sme_connect_failed" />
				<item name="wec_UNSPECIFIED_ERROR" value="390" comment="This error code is generated when an unspecified error is detected." />
				<item name="wec_HARDWARE_FAILURE" value="391" comment="This error code is generated when a hardware failure is detected." />
				<item name="wec_INTERNAL_BUFFER_FULL" value="392" comment="This error code is generated the a command was not accepted due to full internal buffers." />
				<item name="wec_DISCONNECTED" value="393" comment="This error code is generated when a command or procedure has failed due to disconnection." />
				<item name="wec_TOO_MANY_REQUEST" value="394" comment="This error code is generated when there are too many simultaneous requests." />
				<item name="wec_ACCESS_POINT_NOT_IN_SCANLIST" value="395" comment="This error code is generated when the defined Access Point is not found from the scanlist." />
				<item name="wec_INVALID_PASSWORD" value="396" comment="This error code is generated in the following cases:1) you try to connect to a secured network without setting the password or the password is too short2) you try to start a secured AP without setting the password or the password is too short3) you try to set a 64-character PSK with non-hex characters4) you try to set an invalid WEP key (invalid characters or invalid length)Notice that WPA does not contain any standard way for the Access Point to communicate to the station that the password is invalid. The Access Point just disconnects the client during authentication if the password is found invalid. Some stations take an educated guess that this probably means the password is incorrect. WF121 simply retries the authentication until it exceeds the maximum amount of retries (10) which then causes the 0x0185 Timeout Error." />
				<item name="wec_AUTHENTIFICATION_FAILURE" value="397" comment="This error code is generated when the WPA/WPA2 authentication has failed." />
				<item name="wec_OVERFLOW" value="398" comment="This error code is generated when an overflow has been detected." />
				<item name="wec_MULTIPLE_PBC_SESSIONS" value="399" comment="This error code is generated when multiple PBC (Push Button Configuration) sessions have been detected." />
				<item name="wec_ETHERNET_NOT_CONNECTED" value="400" comment="This error code is generated when the Ethernet cable is not connected" />
				<item name="wec_ETHERNET_ROUTE_NOT_SET" value="401" comment="This error code is generated if the Ethernet route is not set" />
				<item name="wec_WRONG_OPERATING_MODE" value="402" comment="This error code is generated if the operating mode is wrong for the issued command" />
				<item name="wec_WIFI_NOT_FOUND" value="403" comment="This error code is generated if the requested resource was not found." />
				<item name="wec_WIFI_NOT_ALREADY_EXIST" value="404" comment="This error is generated if the requested resource already exists." />
				<item name="wec_WIFI_INVALID_CONFIGURATION" value="405" comment="This error code is generated if the current configuration is invalid." />
				<item name="wec_WIFI_ACCESS_POINT_LOST" value="406" comment="This error code is generated if the connection to an Access Point is lost." />
				<item name="wec_PS_STORE_FULL" value="769" comment="This error is generated if the Flash which is reserved for the PS (Persistent Store) is full." />
				<item name="wec_PS_KEY_NOT_FOUND" value="770" comment="This error is generated if the PS key (Persistent Store key) was not found." />
				<item name="wec_I2C_WRITE_ALREADY_IN_PROGRESS" value="771" comment="This error is generated if I2C transmission was initiated while a transmission was already in progress." />
				<item name="wec_I2C_ACK_MISSING" value="772" comment="This error is generated if an acknowledgement for I2C was not received." />
				<item name="wec_FLASH_WRITE_FAILED" value="776" comment="This error code is generated if writing to Flash failed." />
				<item name="wec_FILE_NOT_OPENED" value="773" comment="This error code is generated if an access was attempted to an unopened file." />
				<item name="wec_FILE_NOT_FOUND" value="774" comment="This error code is generated if the requested file was not found in the SD card." />
				<item name="wec_DISK_ERROR" value="775" comment="This error code is generated if an SD card error was detected of if the SD card is full" />
				<item name="wec_TCP_IP_SUCCESS" value="512" comment="This code indicates that no error was detected." />
				<item name="wec_TCP_IP_OUT_OF_MEMORY" value="513" comment="This error code is generated when the system has run out of memory." />
				<item name="wec_TCP_IP_BUFFER_ERROR" value="514" comment="This error code is generated when handling of buffers has failed" />
				<item name="wec_TCP_IP_TIMEOUT" value="515" comment="This error code is generated when a timeout has been detected." />
				<item name="wec_TCP_IP_ROUTING" value="516" comment="This error code is generated when a route could not be found." />
				<item name="wec_TCP_IP_IN_PROGRESS" value="517" comment="This error code is generated when an operation is in progress" />
				<item name="wec_TCP_IP_ILLEGAL_VALUE" value="518" comment="This error code is generated when the issued value is deemed illegal." />
				<item name="wec_TCP_IP_WOULD_BLOCK" value="519" comment="This error code is generated when an operation blocks." />
				<item name="wec_TCP_IP_ADDRESS_IN_USE" value="520" comment="This error code is generated when the issued address is already in use" />
				<item name="wec_TCP_IP_ALREADY_CONNECTED" value="521" comment="This error code is generated when the Wi-Fi module is already connected" />
				<item name="wec_TCP_IP_CONNECTION_ABORTED" value="522" comment="This error code is generated when a connection is aborted." />
				<item name="wec_TCP_IP_CONNECTION_RESET" value="523" comment="This error code is generated when a connection has been reset" />
				<item name="wec_TCP_IP_CONNECTION_CLOSED" value="524" comment="This error code is generated when a connection has been closed." />
				<item name="wec_TCP_IP_NOT_CONNECTED" value="525" comment="This error code is generated when the Wi-Fi module is not connected." />
				<item name="wec_TCP_IP_ILLEGAL_ARGUMENT" value="526" comment="This error code is generated if an illegal argument was issued." />
				<item name="wec_TCP_IP_INTERFACE_LEVEL_ERROR" value="527" comment="This error code is generated if an interface error was detected" />
				<item name="wec_TCP_IP_UNKNOWN_HOST" value="640" comment="This error is generated if an unknown host is detected." />
				<item name="wec_SERVICE_NOT_RUNNING" value="528" comment="This error code is generated if the specified service is not running." />
				<item name="wec_SERVICE_RUNNING" value="529" comment="This error code is generated if the specified service is already running" />
				<item name="wec_HOSTNAME_NOT_SET" value="530" comment="This error code is generated if the hostname has not been set" />
				<item name="wec_HOSTNAME_CONFLICT" value="531" comment="This error code is generated if a hostname conflict was detected." />
        	</enum>
        </channel> -->
         <channel id="5" name="WIFIStateStatus" data_type="ENUM">
            <comment>Returned State Transition code of WIFI chip</comment>
                <enum name="WIFIState">
                    <!--This enum should be synced up with Wf121::DirectMessage::RadioSwState. Actual conversion to this downlink-type happens in `NetworkManagerComponentImpl::convertRadioState2WifiState` though.-->
                    <item name="nm_NONE" value="0x00" comment="None (we haven't received any state update yet)." />
                    <item name="nm_BAD_MESSAGE" value="0x0F" comment="The last state update from the Radio contained a valid message header but the body was corrupted (didn't match any known message). Bad state message was received (we don't know what's really going on inside the Radio rn)." />
                    <item name="nm_BOOT" value="0x10" comment="Booted but hasn't initialized its state_driver yet." />
                    <item name="nm_INIT" value="0x20" comment="In the initial state but WiFi radio isn't powered up yet." />
                    <item name="nm_WIFI_ON" value="0x30" comment="Radio hardware (power amplifier) has turned on successfully - radio has enough power to work." />
                    <item name="nm_CONNECTED" value="0x40" comment="Radio is connected to the network (ARP, etc) but UDP client &amp; socket aren't active yet." />
                    <item name="nm_UDP_CONNECTED" value="0x50" comment="UDP client &amp; socket are active. Radio is ready to communicate." />
                </enum>
        </channel>
        <!-- DEPRECATED: Never ended up using this channel. Need more space.
        <channel id="6" name="UartBytesReceived" data_type="U32">
            <comment>Number of raw bytes received over UART from the Radio (valid or invalid - used for diagnostics).</comment>
        </channel> -->
    </telemetry>

    <events>
        <event id="0" name="StateChange" severity="ACTIVITY_HI" format_string="WF121 State Changed %d -> %d">
            <comment>Emit event when ever a state transition occurs within the WF121</comment>
            <args>
                <arg name="from_state" type="ENUM">
                    <enum name="networkmanager_state_from">
                        <!--NOTE: This enum NEEDS to be synced up with WIFIState enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="from_NONE" value="0x00" comment="None (we haven't received any state update yet)." />
                        <item name="from_BAD_MESSAGE" value="0x0F" comment="The last state update from the Radio contained a valid message header but the body was corrupted (didn't match any known message). Bad state message was received (we don't know what's really going on inside the Radio rn)." />
                        <item name="from_BOOT" value="0x10" comment="Booted but hasn't initialized its state_driver yet." />
                        <item name="from_INIT" value="0x20" comment="In the initial state but WiFi radio isn't powered up yet." />
                        <item name="from_WIFI_ON" value="0x30" comment="Radio hardware (power amplifier) has turned on successfully - radio has enough power to work." />
                        <item name="from_CONNECTED" value="0x40" comment="Radio is connected to the network (ARP, etc) but UDP client &amp; socket aren't active yet." />
                        <item name="from_UDP_CONNECTED" value="0x50" comment="UDP client &amp; socket are active. Radio is ready to communicate." />
                    </enum>
                </arg>
                <arg name="to_state" type="ENUM">
                    <enum name="networkmanager_state_to">
                        <!--NOTE: This enum NEEDS to be synced up with WIFIState enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="to_NONE" value="0x00" comment="None (we haven't received any state update yet)." />
                        <item name="to_BAD_MESSAGE" value="0x0F" comment="The last state update from the Radio contained a valid message header but the body was corrupted (didn't match any known message). Bad state message was received (we don't know what's really going on inside the Radio rn)." />
                        <item name="to_BOOT" value="0x10" comment="Booted but hasn't initialized its state_driver yet." />
                        <item name="to_INIT" value="0x20" comment="In the initial state but WiFi radio isn't powered up yet." />
                        <item name="to_WIFI_ON" value="0x30" comment="Radio hardware (power amplifier) has turned on successfully - radio has enough power to work." />
                        <item name="to_CONNECTED" value="0x40" comment="Radio is connected to the network (ARP, etc) but UDP client &amp; socket aren't active yet." />
                        <item name="to_UDP_CONNECTED" value="0x50" comment="UDP client &amp; socket are active. Radio is ready to communicate." />
                    </enum>
                </arg>
            </args>
        </event>
        <event id="1" name="ExecuteCallbackError" severity="WARNING_HI" format_string="ExecuteCallBackError %d">
            <comment>Emit event when there is an error executing a WF121 callback</comment>
            <args>
                <arg name="ErrorCode" type="U16"/>
            </args>
        </event>
        <event id="2" name="WF121InitializationFailed" severity="FATAL" format_string="WF121 Failed to initialize">
            <comment>Emit event when there is an error executing a WF121 callback</comment>
        </event>

        <event id="3" name="RadioCommunicationsModeChange" severity="ACTIVITY_HI" format_string="Radio Communications Mode Changed %s -> %s">
            <comment>Emit event whenever the radio communications mode is changed.</comment>
            <args>
                <arg name="from_mode" type="ENUM">
                    <enum name="nm_radio_communications_mode_from">
                        <!--NOTE: This enum NEEDS to be synced up with nm_radio_communications_mode enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="from_HERCULES"  value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="from_EXTERNAL"  value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
                <arg name="to_mode" type="ENUM">
                    <enum name="nm_radio_communications_mode_to">
                        <!--NOTE: This enum NEEDS to be synced up with nm_radio_communications_mode enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="to_HERCULES"  value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="to_EXTERNAL"  value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
            </args>
        </event>

        <event id="4" name="RadioCommunicationsModeState" severity="ACTIVITY_LO" format_string="Radio Communications Mode now: %s">
            <comment>Current state of the Radio Communications mode. Emitted anytime a change is requested, even if a change isn't performed because the radio is already in the desired mode.</comment>
            <args>
                <arg name="mode" type="ENUM">
                    <enum name="nm_radio_communications_mode_now">
                        <!--NOTE: This enum NEEDS to be synced up with nm_radio_communications_mode enum (same values for each concept, names can be and need to be different). If it's not, Ground won't be able to parse these messages.-->
                        <item name="now_HERCULES"  value="0x00" comment="Normal mode. Hercules-Radio UART is ON inside Hercules and Hercules is the one talking to the Radio. Returning to this mode *might* not work, in which case you'll need to just send a reset-herc command to the WatchDog." />
                        <item name="now_EXTERNAL"  value="0x01" comment="External mode. Hercules-Radio UART is turned OFF inside Hercules allowing an external device to talk to the Radio via J33. Used for debugging and programming the Radio. NOTE: in this mode, Hercules's RTS (which is connected to the Radio's CTS) is kept in the active/ready mode (LOW) so that the Radio feels free to send data whenever. This effectively deactivates control flow, though an external device can still listen to the Radio's RTS if needed - though this wasn't needed in development." />
                    </enum>
                </arg>
            </args>
        </event>

        <event id="5" name="RadioUartBaudRateChange" severity="ACTIVITY_HI" format_string="Hercules' Radio UART Baud Rate changed (%d) %d -> %d">
            <comment>
                Fired in response to a `Set_Radio_Uart_Baud` command.
                `fromBaud` will always be the baud rate before the command. 
                `toBaud` will always be the actual baud rate after running this command. 
                `changeMade` indicates whether the change was actually 
                (successfully) changed. It can be false because either the 
                change was not able to be made or because it didn't need to be 
                made (requested baud rate is the current baud rate). 
 
                This event will also be fired once upon boot with 
                `changeMade=FALSE` and `fromBaud=toBaud` to indicate the 
                current value of the persistent baud rate.
            </comment>
            <args>
                <arg name="changeMade" type="bool" />
                <arg name="fromBaud" type="U32" />
                <arg name="toBaud" type="U32" />
            </args>
        </event>

        <event id="6" name="RadioBgApiPassthroughChange" severity="ACTIVITY_HI" format_string="BGAPI Passthrough Mode changed (%d) %d -> %d">
            <comment>
                Fired in response to a `Set_Radio_BgApi_Passthrough` command. 
                `from` will always be the state before the command. 
                `to` will always be the actual state after running this command. 
                `changeMade` indicates whether the change was actually 
                (successfully) changed. It can be false because either the 
                change was not able to be made or because it didn't need to be 
                made (requested state is the current state). 

                This event will also be fired once upon boot with 
                `changeMade=FALSE` and `from=to` to indicate the 
                current value of the passthrough state.
            </comment>
            <args>
                <arg name="changeMade" type="bool" />
                <arg name="from" type="bool" />
                <arg name="to" type="bool" />
            </args>
        </event>

        <event id="7" name="RadioSendBgApiCommandAck" severity="WARNING_LO" format_string="Got BGAPI Command Send #%d. Target CRC: 0x%08X. Computed CRC: 0x%08X. Status: %s.">
            <comment>
                Fired in response to a `Send_BgApi_Command` command.

                Not actually a warning but sent using the `WARNING_LO` queue 
                because it has high importance, a (comparatively) large buffer, 
                and not many events use the `WARNING_LO` queue.

                NOTE: CRC values will only be populated if command FAILED
                validation (for any reason, including CRC failure). If status
                indicates there was no validation error, both CRCs will be
                `0xFF'FF'FF'FF`.
            </comment>
            <args>
                <arg name="packetId" type="U32">
                    <comment>
                        Packet ID given from ground.
                    </comment>
                </arg>
                <arg name="targetCrc32" type="U32">
                    <comment>
                        Uplinked CRC32 (as received), or `0xFF'FF'FF'FF` if no validation error.
                    </comment>
                </arg>
                <arg name="computedCrc32" type="U32">
                    <comment>
                        CRC32 of the `bgapiPacket` received, as a uint32, or `0xFF'FF'FF'FF` if no validation error.
                    </comment>
                </arg>
                <arg name="status" type="ENUM">
                    <comment>
                        Status of the `Send_BgApi_Command`.
                    </comment>
                    <enum name="nm_radio_send_bgapi_command_ack_status">
                        <item name="nm_bgapi_send_BAD_EXPECT_RESPONSE_VAL"  value="0x0BADDA77" comment="Value for `expectResponse` didn't match any of the acceptable enum values. Suggests data corruption. Nothing will be sent to the Radio." />
                        <item name="nm_bgapi_send_BAD_LEN"  value="0x0BADDA77" comment="Bad length received (decoded). Nothing was sent to the Radio. Either 0 or bigger than max possible size: WF121_BGAPI_PASSTHROUGH_MAX_MESSAGE_SIZE." />
                        <item name="nm_bgapi_send_CRC_FAIL"  value="0xC9C0FA11" comment="Computed CRC of data received did not match target CRC received. Nothing was sent to the Radio." />
                        <item name="nm_bgapi_send_UART_SEND_FAILED"  value="0xDA7AFA11" comment="All given data was valid but failed to send the packet to the Radio over UART. Try again?" />
                        <item name="nm_bgapi_send_BAD_STATE"  value="0xBAD57A7E"  comment="Hercules is in the wrong state to do this (not in passthrough mode - need to send `Set_Radio_BgApi_Passthrough[passthrough=TRUE]` first)." />
                        <item name="nm_bgapi_send_SUCCESS_NO_RESP"  value="0x0005097A"  comment="Data passed all validation and was sent to the Radio successfully over UART but no response was received from the radio (this can be expected some BGAPI DFU flashing commands)." />
                        <item name="nm_bgapi_send_SUCCESS"  value="0x600DDA7A"  comment="Data passed all validation and was sent to the Radio successfully over UART and a response was received from the radio (this doesn't necessarily happen for some BGAPI DFU flashing commands)." />
                    </enum>
                </arg>
            </args>
        </event>

        <event id="8" name="RadioBgApiCommandRecords" severity="WARNING_LO" format_string="BGAPI Command Records (ID -> Result): \n\tLatest:(%d -> %s), \n\t2nd Latest:(%d -> %s), \n\tOldest:(%d -> %s)">
            <comment>
                Fired in response to a `Downlink_BgApi_Command_Records` command. 
                Downlinks the GSW-Assigned `PacketId` of the last 3 
                `Send_BgApi_Command` s processed by the NetworkManager as well 
                as what the resulting status of that downlink was (used for 
                ensuring all packets in a programming sequence are uplinked 
                correctly and in the correct order).
 
                Technically it's a bit hacky to just have three args with 
                manually synced enums and, instead, this should be using an 
                FPrime Array of custom serializables but we don't have that 
                serialization built in our GDS and don't have time to add it 
                since it would be non-trivial.
 
                Not actually a warning but sent using the `WARNING_LO` queue 
                because it has high importance, a (comparatively) large buffer, 
                and not many events use the `WARNING_LO` queue.
            </comment>
            <args>
                <arg name="packetId0" type="U32">
                    <comment>
                        GSW-Assigned Packet ID of the most recently processed BgApi Packet.
                    </comment>
                </arg>
                <arg name="result0" type="ENUM">
                    <comment>
                        Result of processing the most recently processed BgApi Packet.
                        NOTE: This enum needs to EXACTLY match 
                        `nm_radio_send_bgapi_command_ack_status` in `status` of 
                        `RadioSendBgApiCommandAck` (with the exception of 
                        `_EMPTY_RECORD` which is used to indicate
                        that the record is empty).
                    </comment>
                    <enum name="nm_radio_rec0_bgapi_command_ack_status">
                        <item name="nm_bgapi_rec0_EMPTY_RECORD"  value="0x0000BA1D" comment="This record is empty (we haven't actually processed this many commands yet)." />
                        <item name="nm_bgapi_rec0_BAD_EXPECT_RESPONSE_VAL"  value="0x0BADDA77" comment="Value for `expectResponse` didn't match any of the acceptable enum values. Suggests data corruption. Nothing will be sent to the Radio." />
                        <item name="nm_bgapi_rec0_BAD_LEN"  value="0x0BADDA77" comment="Bad length received (decoded). Nothing was sent to the Radio. Either 0 or bigger than max possible size: WF121_BGAPI_PASSTHROUGH_MAX_MESSAGE_SIZE." />
                        <item name="nm_bgapi_rec0_CRC_FAIL"  value="0xC9C0FA11" comment="Computed CRC of data received did not match target CRC received. Nothing was sent to the Radio." />
                        <item name="nm_bgapi_rec0_UART_SEND_FAILED"  value="0xDA7AFA11" comment="All given data was valid but failed to send the packet to the Radio over UART. Try again?" />
                        <item name="nm_bgapi_rec0_BAD_STATE"  value="0xBAD57A7E"  comment="Hercules is in the wrong state to do this (not in passthrough mode - need to send `Set_Radio_BgApi_Passthrough[passthrough=TRUE]` first)." />
                        <item name="nm_bgapi_rec0_SUCCESS_NO_RESP"  value="0x0005097A"  comment="Data passed all validation and was sent to the Radio successfully over UART but no response was received from the radio, or we didn't look for a response if the command was flagged as `DONT_EXPECT_RESPONSE` (this can be expected for some BGAPI DFU flashing commands)." />
                        <item name="nm_bgapi_rec0_SUCCESS"  value="0x600DDA7A"  comment="Data passed all validation and was sent to the Radio successfully over UART and a response was received from the radio (this doesn't necessarily happen for some BGAPI DFU flashing commands)." />
                    </enum>
                </arg>

                <arg name="packetId1" type="U32">
                    <comment>
                        GSW-Assigned Packet ID of the 2nd most recently processed BgApi Packet.
                    </comment>
                </arg>
                <arg name="result1" type="ENUM">
                    <comment>
                        Result of processing the 2nd most recently processed BgApi Packet.
                        NOTE: This enum needs to EXACTLY match 
                        `nm_radio_send_bgapi_command_ack_status` in `status` of 
                        `RadioSendBgApiCommandAck` (with the exception of 
                        `_EMPTY_RECORD` which is used to indicate
                        that the record is empty).
                    </comment>
                    <enum name="nm_radio_rec1_bgapi_command_ack_status">
                        <item name="nm_bgapi_rec1_EMPTY_RECORD"  value="0x0000BA1D" comment="This record is empty (we haven't actually processed this many commands yet)." />
                        <item name="nm_bgapi_rec1_BAD_EXPECT_RESPONSE_VAL"  value="0x0BADDA77" comment="Value for `expectResponse` didn't match any of the acceptable enum values. Suggests data corruption. Nothing will be sent to the Radio." />
                        <item name="nm_bgapi_rec1_BAD_LEN"  value="0x0BADDA77" comment="Bad length received (decoded). Nothing was sent to the Radio. Either 0 or bigger than max possible size: WF121_BGAPI_PASSTHROUGH_MAX_MESSAGE_SIZE." />
                        <item name="nm_bgapi_rec1_CRC_FAIL"  value="0xC9C0FA11" comment="Computed CRC of data received did not match target CRC received. Nothing was sent to the Radio." />
                        <item name="nm_bgapi_rec1_UART_SEND_FAILED"  value="0xDA7AFA11" comment="All given data was valid but failed to send the packet to the Radio over UART. Try again?" />
                        <item name="nm_bgapi_rec1_BAD_STATE"  value="0xBAD57A7E"  comment="Hercules is in the wrong state to do this (not in passthrough mode - need to send `Set_Radio_BgApi_Passthrough[passthrough=TRUE]` first)." />
                        <item name="nm_bgapi_rec1_SUCCESS_NO_RESP"  value="0x0005097A"  comment="Data passed all validation and was sent to the Radio successfully over UART but no response was received from the radio, or we didn't look for a response if the command was flagged as `DONT_EXPECT_RESPONSE` (this can be expected for some BGAPI DFU flashing commands)." />
                        <item name="nm_bgapi_rec1_SUCCESS"  value="0x600DDA7A"  comment="Data passed all validation and was sent to the Radio successfully over UART and a response was received from the radio (this doesn't necessarily happen for some BGAPI DFU flashing commands)." />
                    </enum>
                </arg>

                <arg name="packetId2" type="U32">
                    <comment>
                        GSW-Assigned Packet ID of the 3rd most recently processed BgApi Packet.
                    </comment>
                </arg>
                <arg name="result2" type="ENUM">
                    <comment>
                        Result of processing the 3rd most recently processed BgApi Packet.
                        NOTE: This enum needs to EXACTLY match 
                        `nm_radio_send_bgapi_command_ack_status` in `status` of 
                        `RadioSendBgApiCommandAck` (with the exception of 
                        `_EMPTY_RECORD` which is used to indicate
                        that the record is empty).
                    </comment>
                    <enum name="nm_radio_rec2_bgapi_command_ack_status">
                        <item name="nm_bgapi_rec2_EMPTY_RECORD"  value="0x0000BA1D" comment="This record is empty (we haven't actually processed this many commands yet)." />
                        <item name="nm_bgapi_rec2_BAD_EXPECT_RESPONSE_VAL"  value="0x0BADDA77" comment="Value for `expectResponse` didn't match any of the acceptable enum values. Suggests data corruption. Nothing will be sent to the Radio." />
                        <item name="nm_bgapi_rec2_BAD_LEN"  value="0x0BADDA77" comment="Bad length received (decoded). Nothing was sent to the Radio. Either 0 or bigger than max possible size: WF121_BGAPI_PASSTHROUGH_MAX_MESSAGE_SIZE." />
                        <item name="nm_bgapi_rec2_CRC_FAIL"  value="0xC9C0FA11" comment="Computed CRC of data received did not match target CRC received. Nothing was sent to the Radio." />
                        <item name="nm_bgapi_rec2_UART_SEND_FAILED"  value="0xDA7AFA11" comment="All given data was valid but failed to send the packet to the Radio over UART. Try again?" />
                        <item name="nm_bgapi_rec2_BAD_STATE"  value="0xBAD57A7E"  comment="Hercules is in the wrong state to do this (not in passthrough mode - need to send `Set_Radio_BgApi_Passthrough[passthrough=TRUE]` first)." />
                        <item name="nm_bgapi_rec2_SUCCESS_NO_RESP"  value="0x0005097A"  comment="Data passed all validation and was sent to the Radio successfully over UART but no response was received from the radio, or we didn't look for a response if the command was flagged as `DONT_EXPECT_RESPONSE` (this can be expected for some BGAPI DFU flashing commands)." />
                        <item name="nm_bgapi_rec2_SUCCESS"  value="0x600DDA7A"  comment="Data passed all validation and was sent to the Radio successfully over UART and a response was received from the radio (this doesn't necessarily happen for some BGAPI DFU flashing commands)." />
                    </enum>
                </arg>
            </args>
        </event>
    </events>



</component>
