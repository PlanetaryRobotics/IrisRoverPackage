

// Block here if a rx is already underway
while (--tries && !sciIsRxReady(comp->m_sci))
    ;

// Blocking until timeout or data available
stat = sciReceiveWithTimeout(comp->m_sci,
                             buff.getsize(),
                             reinterpret_cast<unsigned char *>(buff.getdata()),
                             0xffffffff); /*Max timeout */

Might have to make sure DMA isn't on for SCI interface (WF121), only SCILIN (WD)

    sciREG->SETINT = (uint32)SCI_RX_INT; (?) from  scilinREG->SETINT = (uint32) SCI_RX_INT;

Check that CTS / RTS lines up correctly in schematic.

                 // How do we handle getting out of sync?

!! Wait for command response before sending anything else. (or wait for timeout -- if we fail to get a response for too many commands in a row, ask WD reset the radio)
// create system for flagginf=g which callback to expect next
// Use this to our advantage to make sure sends go through (keep them around and retry X times if fail)

// Add callbacks to catch exceptions/warnings like `system_sw_exception`

// ! NOTE:
// SCI ISR gets called *AFTER* data has been added to whatever buffer you signaled in sciReceive

// CREATE a separate header + packet scheme for BGScript -> UART comms (since it doesn't seem like there's a way to just pass a BGAPI packet with a message)
// Make sure this header will be mutually exclusive with BGApiHeader (no overlapping bits).

// Test UART sync-loss by having radio send some garbage to the UART endpoint (with `send_endpoint` not `hercules_direct_messge_ascii`) and make sure it still works.

// Allow for querying Herc from ground for all info it has about Radio (e.g. last received error).

// ! TODO: (WORKING-HERE): [CWC] Process callback and dispatch to appropriate NetworkInterface functions. Then:
// - Finish DirectMessageDriver.
// - Update state inside network interface
// - Create callback hooks for BGAPI CBs we care about (incl. Signal Quality)
// - Create Queue to pipe datagrams from callbacks to network manager (or whoever else).
//    https://www.freertos.org/Inter-Task-Communication.html
//    https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-5-freertos-queue-example/72d2b361f7b94e0691d947c7c29a03c9
// - Reset radio if no heartbeat for some multiple of expected time?
//
// - Lastly go back and review diffs from checkpoint commit (specifically notifications.c)
//    - Make sure those changes match with the current DMA-ISR system.
// ^ Copy this over to _wifi_todo.md

// ** Check fixed strings in DirectMessageDriver and heartbeatMessage structure

// update transmitCommand
//  - Add timeout to m_processingCmd (also mutex it)
// add mutex for BGAPI information.
// Update RadioDriver callback len (now only needs to be 1 long)

// Look into how NM used to tell WD to reset the Radio (and do that for NM-WD comms)

// ! TODO: (WORKING-HERE) Next thing to do is bring in all the cb_ callbacks from CRNM into NI.

// Add stack overflow detection and reset on overflow.
// Make sure WD reset Herc if it hangs.


// - DMA TX OUT
// - TX TASK
// - BGAPI OUT (with mutex and timeout on awaiting command response).



// Merge RadioDriver into NetworkInterface (basically just a wrapper?) and let
// everything ext. be handled through Wf121::NetworkInterface (?)
// ... TX Task will need to be owned by NI, so RX Task probably should be too.
// ... SerialInterface is separate through and owned by RD. Is there a way to
// keep TXT owned by RD and just driven by NI? (so far, we kept low-level comms
// logic out of NI. would be nice to keep it that way)

// NM update checks Radio heartbeat timeout

// reimpl debugPrintfToWatchdog for passing radio messages to WD RS422

// Strip all the `transmitCommand` calls out of BgApiCommands

// Co-opt a command to make a NM echo command?

// Determine if we need taskENTER_CRITICAL()/taskEXIT_CRITICAL() around certain write operations to prevent them from being interrupted? (only do this if it looks like we're getting garbled data due to interruptions)

// Check if stack size needs to be at least as big as all variables in the task. If so, update this. Note: this would apply to WatchDogRxTask too (it has a 650B buffer but 256word stack)
// Yeah, probably... just add sizeof(Task)/4 (bytes->words) to the stack size.
// ... switch to xTaskCreateStatic (so no memory leaks or surprises)
// There's 768B of overhead per Task?

// ! Adjust KRAM to free up more RAM: https://e2e.ti.com/support/microcontrollers/arm-based-microcontrollers-group/arm-based-microcontrollers/f/arm-based-microcontrollers-forum/949585/compiler-rm46l852-can-i-resize-kram

// Determine task size for idle task (fprime) - almost certainly needs to be bigger than 128.
//   (NULL)
// xPortGetFreeHeapSize as the contrast
// ! ^ Add both of these as a telemetry item for FPrime (detect memory leaks)
// Can we also add a jitter/overdue-clock item? (determine if the scheduler is being overwhelmed)

// Make sure RadioDriver is statically allocated in NetworkManager (1 and only 1, and it's in static memory)

// If buffer copy times end up being too laggy, switch from static to careful dynamic allocation as used in the FreeRTOS+UDP layer and described here: https://www.freertos.org/FreeRTOS_Support_Forum_Archive/March_2013/freertos_Safe_passing_of_buffers_through_a_queue_7177431.html
// ^ rem. we're still talking <1ms every couple seconds here. Probably fine for this application. Only redo if determined necessary by testing.

// ! TODO: Refactor Wf121Serial::dmaSend to use a binary semaphore + time delays so the writing task blocks but doesn't halt the system while waiting for previous write to complete.
// ^ while you're at it, protect the dmaSend resource with a mutex.

// ! TODO: Auto-uplink a hello-from-herc as soon as connection is found (first thing in the tx task?)
// ^ Grab this before grabbing anything from the queue