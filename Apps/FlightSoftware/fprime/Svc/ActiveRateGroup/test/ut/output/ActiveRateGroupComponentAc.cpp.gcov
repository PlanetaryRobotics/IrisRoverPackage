        -:    0:Source:/home/tcanham/source/isf/Svc/ActiveRateGroup/ActiveRateGroupComponentAc.cpp
        -:    0:Programs:10
        -:    1:// ====================================================================== 
        -:    2:// \title  ActiveRateGroupComponentAc.hpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for ActiveRateGroup component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   11:// 
        -:   18:// ====================================================================== 
        -:   19:
        -:   20:#include <stdio.h>
        -:   21:#include <Fw/Cfg/Config.hpp>
        -:   22:#include <Svc/ActiveRateGroup/ActiveRateGroupComponentAc.hpp>
        -:   23:#include <Fw/Types/Assert.hpp>
        -:   24:#if FW_ENABLE_TEXT_LOGGING
        -:   25:#include <Fw/Types/EightyCharString.hpp>
        -:   26:#endif
        -:   27:
        -:   28:
        -:   29:namespace Svc {
        -:   30:
        -:   31:  // ----------------------------------------------------------------------
        -:   32:  // Anonymous namespace to prevent name collisions
        -:   33:  // ----------------------------------------------------------------------
        -:   34:
        -:   35:  namespace {
        -:   36:
        -:   37:    typedef enum {
        -:   38:      ACTIVERATEGROUP_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   39:      CYCLEIN_CYCLE
        -:   40:    } MsgTypeEnum;
        -:   41:
        -:   42:    // Get the max size by doing a union of the input port serialization sizes.
        -:   43:
        -:   44:    typedef union {
        -:   45:      BYTE port1[Svc::InputCyclePort::SERIALIZED_SIZE];
        -:   46:    } BuffUnion;
        -:   47:
        -:   48:    // Define a message buffer class large enough to handle all the
        -:   49:    // asynchronous inputs to the component
        -:   50:
      750:   51:    class ComponentIpcSerializableBuffer : 
        -:   52:      public Fw::SerializeBufferBase
        -:   53:    {
        -:   54:
        -:   55:      public:
        -:   56:
        -:   57:        enum {
        -:   58:          // Max. message size = size of data + message id + port
        -:   59:          SERIALIZATION_SIZE =
        -:   60:            sizeof(BuffUnion) +
        -:   61:            sizeof(NATIVE_INT_TYPE) +
        -:   62:            sizeof(NATIVE_INT_TYPE)
        -:   63:        };
        -:   64:
     1230:   65:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
     1230:   66:          return sizeof(m_buff);
        -:   67:        }
        -:   68:
     7635:   69:        U8* getBuffAddr(void) {
     7635:   70:          return m_buff;
        -:   71:        }
        -:   72:
      240:   73:        const U8* getBuffAddr(void) const {
      240:   74:          return m_buff;
        -:   75:        }
        -:   76:
        -:   77:      private:
        -:   78:        // Should be the max of all the input ports serialized sizes...
        -:   79:        U8 m_buff[SERIALIZATION_SIZE];
        -:   80:
        -:   81:    };
        -:   82:
        -:   83:  }
        -:   84:
        -:   85:  // ----------------------------------------------------------------------
        -:   86:  // Getters for numbers of input ports
        -:   87:  // ----------------------------------------------------------------------
        -:   88:
       30:   89:  Svc::InputCyclePort *ActiveRateGroupComponentBase ::
        -:   90:    get_CycleIn_InputPort(NATIVE_INT_TYPE portNum)
        -:   91:  {
       30:   92:    FW_ASSERT(portNum < this->getNum_CycleIn_InputPorts());
       30:   93:    return &this->m_CycleIn_InputPort[portNum];
        -:   94:  }
        -:   95:
        -:   96:  // ----------------------------------------------------------------------
        -:   97:  // Typed connectors for output ports
        -:   98:  // ----------------------------------------------------------------------
        -:   99:
      150:  100:  void ActiveRateGroupComponentBase ::
        -:  101:    set_RateGroupMemberOut_OutputPort(
        -:  102:        NATIVE_INT_TYPE portNum,
        -:  103:        Svc::InputSchedPort* port
        -:  104:    )
        -:  105:  {
      150:  106:    FW_ASSERT(portNum < this->getNum_RateGroupMemberOut_OutputPorts());
      150:  107:    this->m_RateGroupMemberOut_OutputPort[portNum].addCallPort(port);
      150:  108:  }
        -:  109:
       30:  110:  void ActiveRateGroupComponentBase ::
        -:  111:    set_Tlm_OutputPort(
        -:  112:        NATIVE_INT_TYPE portNum,
        -:  113:        Fw::InputTlmPort* port
        -:  114:    )
        -:  115:  {
       30:  116:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts());
       30:  117:    this->m_Tlm_OutputPort[portNum].addCallPort(port);
       30:  118:  }
        -:  119:
       30:  120:  void ActiveRateGroupComponentBase ::
        -:  121:    set_Time_OutputPort(
        -:  122:        NATIVE_INT_TYPE portNum,
        -:  123:        Fw::InputTimePort* port
        -:  124:    )
        -:  125:  {
       30:  126:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts());
       30:  127:    this->m_Time_OutputPort[portNum].addCallPort(port);
       30:  128:  }
        -:  129:
       30:  130:  void ActiveRateGroupComponentBase ::
        -:  131:    set_Log_OutputPort(
        -:  132:        NATIVE_INT_TYPE portNum,
        -:  133:        Fw::InputLogPort* port
        -:  134:    )
        -:  135:  {
       30:  136:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts());
       30:  137:    this->m_Log_OutputPort[portNum].addCallPort(port);
       30:  138:  }
        -:  139:
        -:  140:#if FW_ENABLE_TEXT_LOGGING == 1
       30:  141:  void ActiveRateGroupComponentBase ::
        -:  142:    set_LogText_OutputPort(
        -:  143:        NATIVE_INT_TYPE portNum,
        -:  144:        Fw::InputLogTextPort* port
        -:  145:    )
        -:  146:  {
       30:  147:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts());
       30:  148:    this->m_LogText_OutputPort[portNum].addCallPort(port);
       30:  149:  }
        -:  150:#endif
        -:  151:
        -:  152:  // ----------------------------------------------------------------------
        -:  153:  // Serialization connectors for output ports
        -:  154:  // ----------------------------------------------------------------------
        -:  155:
        -:  156:#if FW_PORT_SERIALIZATION
        -:  157:
    #####:  158:  void ActiveRateGroupComponentBase ::
        -:  159:    set_RateGroupMemberOut_OutputPort(
        -:  160:        NATIVE_INT_TYPE portNum,
        -:  161:        Fw::InputSerializePort *port
        -:  162:    )
        -:  163:  {
    #####:  164:    FW_ASSERT(portNum < this->getNum_RateGroupMemberOut_OutputPorts());
    #####:  165:    return this->m_RateGroupMemberOut_OutputPort[portNum].registerSerialPort(port);
        -:  166:  }
        -:  167:
    #####:  168:  void ActiveRateGroupComponentBase ::
        -:  169:    set_Tlm_OutputPort(
        -:  170:        NATIVE_INT_TYPE portNum,
        -:  171:        Fw::InputSerializePort *port
        -:  172:    )
        -:  173:  {
    #####:  174:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts());
    #####:  175:    return this->m_Tlm_OutputPort[portNum].registerSerialPort(port);
        -:  176:  }
        -:  177:
    #####:  178:  void ActiveRateGroupComponentBase ::
        -:  179:    set_Time_OutputPort(
        -:  180:        NATIVE_INT_TYPE portNum,
        -:  181:        Fw::InputSerializePort *port
        -:  182:    )
        -:  183:  {
    #####:  184:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts());
    #####:  185:    return this->m_Time_OutputPort[portNum].registerSerialPort(port);
        -:  186:  }
        -:  187:
    #####:  188:  void ActiveRateGroupComponentBase ::
        -:  189:    set_Log_OutputPort(
        -:  190:        NATIVE_INT_TYPE portNum,
        -:  191:        Fw::InputSerializePort *port
        -:  192:    )
        -:  193:  {
    #####:  194:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts());
    #####:  195:    return this->m_Log_OutputPort[portNum].registerSerialPort(port);
        -:  196:  }
        -:  197:
        -:  198:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  199:  void ActiveRateGroupComponentBase ::
        -:  200:    set_LogText_OutputPort(
        -:  201:        NATIVE_INT_TYPE portNum,
        -:  202:        Fw::InputSerializePort *port
        -:  203:    )
        -:  204:  {
    #####:  205:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts());
    #####:  206:    return this->m_LogText_OutputPort[portNum].registerSerialPort(port);
        -:  207:  }
        -:  208:#endif
        -:  209:
        -:  210:#endif
        -:  211:
        -:  212:  // ----------------------------------------------------------------------
        -:  213:  // Component construction, initialization, and destruction
        -:  214:  // ----------------------------------------------------------------------
        -:  215:
       30:  216:  ActiveRateGroupComponentBase ::
        -:  217:#if FW_OBJECT_NAMES == 1
        -:  218:    ActiveRateGroupComponentBase(const char* compName) :
       30:  219:      Fw::ActiveComponentBase(compName)
        -:  220:#else
        -:  221:    ActiveRateGroupComponentBase() :
        -:  222:      Fw::ActiveComponentBase()
        -:  223:#endif
        -:  224:  {
        -:  225:
        -:  226:    // Initialize telemetry channel RgMaxTime
       30:  227:    this->m_first_update_RgMaxTime = true;
       30:  228:    this->m_last_RgMaxTime = 0;
        -:  229:
        -:  230:    // Initialize telemetry channel RgCycleSlips
       30:  231:    this->m_first_update_RgCycleSlips = true;
       30:  232:    this->m_last_RgCycleSlips = 0;
        -:  233:
       30:  234:  }
        -:  235:
       30:  236:  void ActiveRateGroupComponentBase ::
        -:  237:    init(
        -:  238:        NATIVE_INT_TYPE queueDepth,
        -:  239:        NATIVE_INT_TYPE instance
        -:  240:    )
        -:  241:  {
        -:  242:
        -:  243:    // Initialize base class
       30:  244:    Fw::ActiveComponentBase::init(instance);
        -:  245:
        -:  246:    // Connect input port CycleIn
      120:  247:    for (
       30:  248:        NATIVE_INT_TYPE port = 0;
       60:  249:        port < this->getNum_CycleIn_InputPorts();
        -:  250:        port++
        -:  251:    ) {
        -:  252:
       30:  253:      this->m_CycleIn_InputPort[port].init();
        -:  254:      this->m_CycleIn_InputPort[port].addCallComp(
        -:  255:          this,
        -:  256:          m_p_CycleIn_in
       30:  257:      );
       30:  258:      this->m_CycleIn_InputPort[port].setPortNum(port);
        -:  259:
        -:  260:#if FW_OBJECT_NAMES == 1
        -:  261:      char portName[80];
        -:  262:      (void) snprintf(
        -:  263:          portName,
        -:  264:          sizeof(portName),
        -:  265:          "%s_CycleIn_InputPort[%d]",
        -:  266:          this->m_objName,
        -:  267:          port
       30:  268:      );
       30:  269:      this->m_CycleIn_InputPort[port].setObjName(portName);
        -:  270:#endif
        -:  271:
        -:  272:    }
        -:  273:
        -:  274:    // Initialize output port RateGroupMemberOut
      360:  275:    for (
       30:  276:        NATIVE_INT_TYPE port = 0;
      180:  277:        port < this->getNum_RateGroupMemberOut_OutputPorts();
        -:  278:        port++
        -:  279:    ) {
      150:  280:      this->m_RateGroupMemberOut_OutputPort[port].init();
        -:  281:
        -:  282:#if FW_OBJECT_NAMES == 1
        -:  283:      char portName[80];
        -:  284:      (void) snprintf(
        -:  285:          portName,
        -:  286:          sizeof(portName),
        -:  287:          "%s_RateGroupMemberOut_OutputPort[%d]",
        -:  288:          this->m_objName,
        -:  289:          port
      150:  290:      );
      150:  291:      this->m_RateGroupMemberOut_OutputPort[port].setObjName(portName);
        -:  292:#endif
        -:  293:
        -:  294:    }
        -:  295:
        -:  296:    // Initialize output port Tlm
      120:  297:    for (
       30:  298:        NATIVE_INT_TYPE port = 0;
       60:  299:        port < this->getNum_Tlm_OutputPorts();
        -:  300:        port++
        -:  301:    ) {
       30:  302:      this->m_Tlm_OutputPort[port].init();
        -:  303:
        -:  304:#if FW_OBJECT_NAMES == 1
        -:  305:      char portName[80];
        -:  306:      (void) snprintf(
        -:  307:          portName,
        -:  308:          sizeof(portName),
        -:  309:          "%s_Tlm_OutputPort[%d]",
        -:  310:          this->m_objName,
        -:  311:          port
       30:  312:      );
       30:  313:      this->m_Tlm_OutputPort[port].setObjName(portName);
        -:  314:#endif
        -:  315:
        -:  316:    }
        -:  317:
        -:  318:    // Initialize output port Time
      120:  319:    for (
       30:  320:        NATIVE_INT_TYPE port = 0;
       60:  321:        port < this->getNum_Time_OutputPorts();
        -:  322:        port++
        -:  323:    ) {
       30:  324:      this->m_Time_OutputPort[port].init();
        -:  325:
        -:  326:#if FW_OBJECT_NAMES == 1
        -:  327:      char portName[80];
        -:  328:      (void) snprintf(
        -:  329:          portName,
        -:  330:          sizeof(portName),
        -:  331:          "%s_Time_OutputPort[%d]",
        -:  332:          this->m_objName,
        -:  333:          port
       30:  334:      );
       30:  335:      this->m_Time_OutputPort[port].setObjName(portName);
        -:  336:#endif
        -:  337:
        -:  338:    }
        -:  339:
        -:  340:    // Initialize output port Log
      120:  341:    for (
       30:  342:        NATIVE_INT_TYPE port = 0;
       60:  343:        port < this->getNum_Log_OutputPorts();
        -:  344:        port++
        -:  345:    ) {
       30:  346:      this->m_Log_OutputPort[port].init();
        -:  347:
        -:  348:#if FW_OBJECT_NAMES == 1
        -:  349:      char portName[80];
        -:  350:      (void) snprintf(
        -:  351:          portName,
        -:  352:          sizeof(portName),
        -:  353:          "%s_Log_OutputPort[%d]",
        -:  354:          this->m_objName,
        -:  355:          port
       30:  356:      );
       30:  357:      this->m_Log_OutputPort[port].setObjName(portName);
        -:  358:#endif
        -:  359:
        -:  360:    }
        -:  361:
        -:  362:    // Initialize output port LogText
        -:  363:#if FW_ENABLE_TEXT_LOGGING == 1
      120:  364:    for (
       30:  365:        NATIVE_INT_TYPE port = 0;
       60:  366:        port < this->getNum_LogText_OutputPorts();
        -:  367:        port++
        -:  368:    ) {
       30:  369:      this->m_LogText_OutputPort[port].init();
        -:  370:
        -:  371:#if FW_OBJECT_NAMES == 1
        -:  372:      char portName[80];
        -:  373:      (void) snprintf(
        -:  374:          portName,
        -:  375:          sizeof(portName),
        -:  376:          "%s_LogText_OutputPort[%d]",
        -:  377:          this->m_objName,
        -:  378:          port
       30:  379:      );
       30:  380:      this->m_LogText_OutputPort[port].setObjName(portName);
        -:  381:#endif
        -:  382:
        -:  383:    }
        -:  384:#endif
        -:  385:
        -:  386:    Os::Queue::QueueStatus qStat =
        -:  387:    this->createQueue(
        -:  388:        queueDepth,
        -:  389:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
       30:  390:    );
       30:  391:    FW_ASSERT(
        -:  392:        Os::Queue::QUEUE_OK == qStat,
        -:  393:        static_cast<NATIVE_INT_TYPE>(qStat)
       60:  394:    );
        -:  395:
       30:  396:  }
        -:  397:
       30:  398:  ActiveRateGroupComponentBase::
       30:  399:    ~ActiveRateGroupComponentBase() {
        -:  400:
       30:  401:  }
        -:  402:
        -:  403:  // ----------------------------------------------------------------------
        -:  404:  // Invocation functions for output ports
        -:  405:  // ----------------------------------------------------------------------
        -:  406:
      675:  407:  void ActiveRateGroupComponentBase ::
        -:  408:    RateGroupMemberOut_out(
        -:  409:        NATIVE_INT_TYPE portNum,
        -:  410:        NATIVE_UINT_TYPE context
        -:  411:    )
        -:  412:  {
      675:  413:    FW_ASSERT(portNum < this->getNum_RateGroupMemberOut_OutputPorts());
      675:  414:    m_RateGroupMemberOut_OutputPort[portNum].invoke(context);
      675:  415:  }
        -:  416:
        -:  417:  // ----------------------------------------------------------------------
        -:  418:  // Getters for numbers of ports
        -:  419:  // ----------------------------------------------------------------------
        -:  420:
      330:  421:  NATIVE_INT_TYPE ActiveRateGroupComponentBase ::
        -:  422:    getNum_CycleIn_InputPorts(void)
        -:  423:  {
      330:  424:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  425:        this->m_CycleIn_InputPort
        -:  426:    );
        -:  427:  }
        -:  428:
     2730:  429:  NATIVE_INT_TYPE ActiveRateGroupComponentBase ::
        -:  430:    getNum_RateGroupMemberOut_OutputPorts(void)
        -:  431:  {
     2730:  432:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  433:        this->m_RateGroupMemberOut_OutputPort
        -:  434:    );
        -:  435:  }
        -:  436:
       90:  437:  NATIVE_INT_TYPE ActiveRateGroupComponentBase ::
        -:  438:    getNum_Tlm_OutputPorts(void)
        -:  439:  {
       90:  440:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  441:        this->m_Tlm_OutputPort
        -:  442:    );
        -:  443:  }
        -:  444:
       90:  445:  NATIVE_INT_TYPE ActiveRateGroupComponentBase ::
        -:  446:    getNum_Time_OutputPorts(void)
        -:  447:  {
       90:  448:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  449:        this->m_Time_OutputPort
        -:  450:    );
        -:  451:  }
        -:  452:
       90:  453:  NATIVE_INT_TYPE ActiveRateGroupComponentBase ::
        -:  454:    getNum_Log_OutputPorts(void)
        -:  455:  {
       90:  456:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  457:        this->m_Log_OutputPort
        -:  458:    );
        -:  459:  }
        -:  460:
        -:  461:#if FW_ENABLE_TEXT_LOGGING == 1
       90:  462:  NATIVE_INT_TYPE ActiveRateGroupComponentBase ::
        -:  463:    getNum_LogText_OutputPorts(void)
        -:  464:  {
       90:  465:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  466:        this->m_LogText_OutputPort
        -:  467:    );
        -:  468:  }
        -:  469:#endif
        -:  470:
        -:  471:  // ----------------------------------------------------------------------
        -:  472:  // Port connection status queries
        -:  473:  // ----------------------------------------------------------------------
        -:  474:
      675:  475:  bool ActiveRateGroupComponentBase ::
        -:  476:    isConnected_RateGroupMemberOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  477:  {
     1350:  478:     FW_ASSERT(
        -:  479:        portNum < this->getNum_RateGroupMemberOut_OutputPorts(),
        -:  480:        portNum
     1350:  481:     );
      675:  482:     return this->m_RateGroupMemberOut_OutputPort[portNum].isConnected();
        -:  483:  }
        -:  484:
    #####:  485:  bool ActiveRateGroupComponentBase ::
        -:  486:    isConnected_Tlm_OutputPort(NATIVE_INT_TYPE portNum)
        -:  487:  {
    #####:  488:     FW_ASSERT(
        -:  489:        portNum < this->getNum_Tlm_OutputPorts(),
        -:  490:        portNum
    #####:  491:     );
    #####:  492:     return this->m_Tlm_OutputPort[portNum].isConnected();
        -:  493:  }
        -:  494:
    #####:  495:  bool ActiveRateGroupComponentBase ::
        -:  496:    isConnected_Time_OutputPort(NATIVE_INT_TYPE portNum)
        -:  497:  {
    #####:  498:     FW_ASSERT(
        -:  499:        portNum < this->getNum_Time_OutputPorts(),
        -:  500:        portNum
    #####:  501:     );
    #####:  502:     return this->m_Time_OutputPort[portNum].isConnected();
        -:  503:  }
        -:  504:
    #####:  505:  bool ActiveRateGroupComponentBase ::
        -:  506:    isConnected_Log_OutputPort(NATIVE_INT_TYPE portNum)
        -:  507:  {
    #####:  508:     FW_ASSERT(
        -:  509:        portNum < this->getNum_Log_OutputPorts(),
        -:  510:        portNum
    #####:  511:     );
    #####:  512:     return this->m_Log_OutputPort[portNum].isConnected();
        -:  513:  }
        -:  514:
        -:  515:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  516:  bool ActiveRateGroupComponentBase ::
        -:  517:    isConnected_LogText_OutputPort(NATIVE_INT_TYPE portNum)
        -:  518:  {
    #####:  519:     FW_ASSERT(
        -:  520:        portNum < this->getNum_LogText_OutputPorts(),
        -:  521:        portNum
    #####:  522:     );
    #####:  523:     return this->m_LogText_OutputPort[portNum].isConnected();
        -:  524:  }
        -:  525:#endif
        -:  526:
        -:  527:  // ----------------------------------------------------------------------
        -:  528:  // Telemetry write functions
        -:  529:  // ----------------------------------------------------------------------
        -:  530:
      135:  531:  void ActiveRateGroupComponentBase ::
        -:  532:    tlmWrite_RgMaxTime(U32& arg)
        -:  533:  {
        -:  534:
        -:  535:    // Check to see if it is the first time
      135:  536:    if (not this->m_first_update_RgMaxTime) {
        -:  537:      // Check to see if value has changed. If not, don't write it.
      105:  538:      if (arg == this->m_last_RgMaxTime) {
      180:  539:        return;
        -:  540:      } else {
       60:  541:        this->m_last_RgMaxTime = arg;
        -:  542:      }
        -:  543:    }
        -:  544:    else {
       30:  545:      this->m_first_update_RgMaxTime = false;
       30:  546:      this->m_last_RgMaxTime = arg;
        -:  547:    }
        -:  548:
       90:  549:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       90:  550:      Fw::Time _timeTag = this->getTime();
      180:  551:      Fw::TlmBuffer _tlmBuff;
       90:  552:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
       90:  553:      FW_ASSERT(
        -:  554:          _stat == Fw::FW_SERIALIZE_OK,
        -:  555:          static_cast<NATIVE_INT_TYPE>(_stat)
      180:  556:      );
        -:  557:      
        -:  558:      FwChanIdType _id;
        -:  559:      
       90:  560:      switch (this->getInstance()) {
        -:  561:          case 0:
       30:  562:            _id = CHANNELID_RGMAXTIME_0;
       30:  563:            break;
        -:  564:          case 1:
       30:  565:            _id = CHANNELID_RGMAXTIME_1;
       30:  566:            break;
        -:  567:          case 2:
       30:  568:            _id = CHANNELID_RGMAXTIME_2;
       30:  569:            break;
        -:  570:          default:
    #####:  571:            FW_ASSERT(0,this->getInstance());
    #####:  572:            break;
        -:  573:      }
        -:  574:      
        -:  575:      this->m_Tlm_OutputPort[0].invoke(
        -:  576:          _id,
        -:  577:          _timeTag,
        -:  578:          _tlmBuff
      180:  579:      );
        -:  580:    }
        -:  581:
        -:  582:  }
        -:  583:
      105:  584:  void ActiveRateGroupComponentBase ::
        -:  585:    tlmWrite_RgCycleSlips(U32& arg)
        -:  586:  {
        -:  587:
        -:  588:    // Check to see if it is the first time
      105:  589:    if (not this->m_first_update_RgCycleSlips) {
        -:  590:      // Check to see if value has changed. If not, don't write it.
       90:  591:      if (arg == this->m_last_RgCycleSlips) {
      105:  592:        return;
        -:  593:      } else {
       90:  594:        this->m_last_RgCycleSlips = arg;
        -:  595:      }
        -:  596:    }
        -:  597:    else {
       15:  598:      this->m_first_update_RgCycleSlips = false;
       15:  599:      this->m_last_RgCycleSlips = arg;
        -:  600:    }
        -:  601:
      105:  602:    if (this->m_Tlm_OutputPort[0].isConnected()) {
      105:  603:      Fw::Time _timeTag = this->getTime();
      210:  604:      Fw::TlmBuffer _tlmBuff;
      105:  605:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
      105:  606:      FW_ASSERT(
        -:  607:          _stat == Fw::FW_SERIALIZE_OK,
        -:  608:          static_cast<NATIVE_INT_TYPE>(_stat)
      210:  609:      );
        -:  610:      
        -:  611:      FwChanIdType _id;
        -:  612:      
      105:  613:      switch (this->getInstance()) {
        -:  614:          case 0:
       35:  615:            _id = CHANNELID_RGCYCLESLIPS_0;
       35:  616:            break;
        -:  617:          case 1:
       35:  618:            _id = CHANNELID_RGCYCLESLIPS_1;
       35:  619:            break;
        -:  620:          case 2:
       35:  621:            _id = CHANNELID_RGCYCLESLIPS_2;
       35:  622:            break;
        -:  623:          default:
    #####:  624:            FW_ASSERT(0,this->getInstance());
    #####:  625:            break;
        -:  626:      }
        -:  627:      
        -:  628:      this->m_Tlm_OutputPort[0].invoke(
        -:  629:          _id,
        -:  630:          _timeTag,
        -:  631:          _tlmBuff
      210:  632:      );
        -:  633:    }
        -:  634:
        -:  635:  }
        -:  636:
        -:  637:  // ----------------------------------------------------------------------
        -:  638:  // Time
        -:  639:  // ----------------------------------------------------------------------
        -:  640:
      195:  641:  Fw::Time ActiveRateGroupComponentBase ::
        -:  642:    getTime(void) 
        -:  643:  {
      195:  644:    if (this->m_Time_OutputPort[0].isConnected()) {
      195:  645:      return this->m_Time_OutputPort[0].invoke();
        -:  646:    } else {
    #####:  647:      return Fw::Time(TB_NONE,0,0);
        -:  648:    }
        -:  649:  }
        -:  650:
        -:  651:  // ----------------------------------------------------------------------
        -:  652:  // Event handling functions
        -:  653:  // ----------------------------------------------------------------------
        -:  654:
       30:  655:  void ActiveRateGroupComponentBase ::
        -:  656:    log_DIAGNOSTIC_RateGroupStarted(
        -:  657:        void
        -:  658:    )
        -:  659:  {
        -:  660:
        -:  661:    // Get the time
       30:  662:    Fw::Time _logTime;
       30:  663:    if (this->m_Time_OutputPort[0].isConnected()) {
       30:  664:      _logTime = this->m_Time_OutputPort[0].invoke();
        -:  665:    }
        -:  666:    
        -:  667:    FwEventIdType _id;
        -:  668:    
       30:  669:    switch (this->getInstance()) {
        -:  670:      case 0:
       10:  671:        _id = EVENTID_RATEGROUPSTARTED_0;
       10:  672:        break;
        -:  673:      case 1:
       10:  674:        _id = EVENTID_RATEGROUPSTARTED_1;
       10:  675:        break;
        -:  676:      case 2:
       10:  677:        _id = EVENTID_RATEGROUPSTARTED_2;
       10:  678:        break;
        -:  679:      default:
    #####:  680:        FW_ASSERT(0,this->getInstance());
    #####:  681:        break;
        -:  682:    };
        -:  683:
        -:  684:    // Emit the event on the log port
       30:  685:    if (this->m_Log_OutputPort[0].isConnected()) {
        -:  686:
       30:  687:      Fw::LogBuffer _logBuff;
        -:  688:
        -:  689:
        -:  690:      this->m_Log_OutputPort[0].invoke(
        -:  691:          _id,
        -:  692:          _logTime,Fw::LOG_DIAGNOSTIC,
        -:  693:          _logBuff
       30:  694:      );
        -:  695:
        -:  696:    }
        -:  697:
        -:  698:    // Emit the event on the text log port
        -:  699:#if FW_ENABLE_TEXT_LOGGING
       30:  700:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -:  701:
        -:  702:#if FW_OBJECT_NAMES == 1
        -:  703:      const char* _formatString =
       30:  704:        "(%s) %s: Rate group started.";
        -:  705:#else
        -:  706:      const char* _formatString =
        -:  707:        "%s: Rate group started.";
        -:  708:#endif
        -:  709:
        -:  710:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -:  711:
        -:  712:      (void) snprintf(
        -:  713:          _textBuffer,
        -:  714:          FW_LOG_TEXT_BUFFER_SIZE,
        -:  715:          _formatString,
        -:  716:#if FW_OBJECT_NAMES == 1
        -:  717:          this->m_objName,
        -:  718:#endif
        -:  719:          "RateGroupStarted "
       30:  720:      );
        -:  721:
        -:  722:      // Null terminate
       30:  723:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       30:  724:      Fw::TextLogString _logString = _textBuffer;
        -:  725:      this->m_LogText_OutputPort[0].invoke(
        -:  726:          _id,
        -:  727:          _logTime,Fw::TEXT_LOG_DIAGNOSTIC,
        -:  728:          _logString
       30:  729:      );
        -:  730:
       30:  731:    }
        -:  732:#endif
        -:  733:
       30:  734:  }
        -:  735:
       90:  736:  void ActiveRateGroupComponentBase ::
        -:  737:    log_WARNING_HI_RateGroupCycleSlip(
        -:  738:        U32 cycle
        -:  739:    )
        -:  740:  {
        -:  741:
        -:  742:    // Get the time
       90:  743:    Fw::Time _logTime;
       90:  744:    if (this->m_Time_OutputPort[0].isConnected()) {
       90:  745:      _logTime = this->m_Time_OutputPort[0].invoke();
        -:  746:    }
        -:  747:    
        -:  748:    FwEventIdType _id;
        -:  749:    
       90:  750:    switch (this->getInstance()) {
        -:  751:      case 0:
       30:  752:        _id = EVENTID_RATEGROUPCYCLESLIP_0;
       30:  753:        break;
        -:  754:      case 1:
       30:  755:        _id = EVENTID_RATEGROUPCYCLESLIP_1;
       30:  756:        break;
        -:  757:      case 2:
       30:  758:        _id = EVENTID_RATEGROUPCYCLESLIP_2;
       30:  759:        break;
        -:  760:      default:
    #####:  761:        FW_ASSERT(0,this->getInstance());
    #####:  762:        break;
        -:  763:    };
        -:  764:
        -:  765:    // Emit the event on the log port
       90:  766:    if (this->m_Log_OutputPort[0].isConnected()) {
        -:  767:
       90:  768:      Fw::LogBuffer _logBuff;
        -:  769:      Fw::SerializeStatus _status;
        -:  770:
        -:  771:#if FW_AMPCS_COMPATIBLE
        -:  772:      // Serialize the number of arguments
        -:  773:      _status = _logBuff.serialize(static_cast<U8>(1));
        -:  774:      FW_ASSERT(
        -:  775:          _status == Fw::FW_SERIALIZE_OK,
        -:  776:          static_cast<NATIVE_INT_TYPE>(_status)
        -:  777:      );
        -:  778:#endif
        -:  779:
        -:  780:#if FW_AMPCS_COMPATIBLE
        -:  781:      // Serialize the argument size
        -:  782:      _status = _logBuff.serialize(
        -:  783:          static_cast<U8>(sizeof(cycle))
        -:  784:      );
        -:  785:      FW_ASSERT(
        -:  786:          _status == Fw::FW_SERIALIZE_OK,
        -:  787:          static_cast<NATIVE_INT_TYPE>(_status)
        -:  788:      );
        -:  789:#endif
        -:  790:
       90:  791:      _status = _logBuff.serialize(cycle);
       90:  792:      FW_ASSERT(
        -:  793:          _status == Fw::FW_SERIALIZE_OK,
        -:  794:          static_cast<NATIVE_INT_TYPE>(_status)
      180:  795:      );
        -:  796:
        -:  797:
        -:  798:      this->m_Log_OutputPort[0].invoke(
        -:  799:          _id,
        -:  800:          _logTime,Fw::LOG_WARNING_HI,
        -:  801:          _logBuff
       90:  802:      );
        -:  803:
        -:  804:    }
        -:  805:
        -:  806:    // Emit the event on the text log port
        -:  807:#if FW_ENABLE_TEXT_LOGGING
       90:  808:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -:  809:
        -:  810:#if FW_OBJECT_NAMES == 1
        -:  811:      const char* _formatString =
       90:  812:        "(%s) %s: Rate group cycle slipped on cycle %d";
        -:  813:#else
        -:  814:      const char* _formatString =
        -:  815:        "%s: Rate group cycle slipped on cycle %d";
        -:  816:#endif
        -:  817:
        -:  818:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -:  819:
        -:  820:      (void) snprintf(
        -:  821:          _textBuffer,
        -:  822:          FW_LOG_TEXT_BUFFER_SIZE,
        -:  823:          _formatString,
        -:  824:#if FW_OBJECT_NAMES == 1
        -:  825:          this->m_objName,
        -:  826:#endif
        -:  827:          "RateGroupCycleSlip "
        -:  828:        , cycle
       90:  829:      );
        -:  830:
        -:  831:      // Null terminate
       90:  832:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       90:  833:      Fw::TextLogString _logString = _textBuffer;
        -:  834:      this->m_LogText_OutputPort[0].invoke(
        -:  835:          _id,
        -:  836:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -:  837:          _logString
       90:  838:      );
        -:  839:
       90:  840:    }
        -:  841:#endif
        -:  842:
       90:  843:  }
        -:  844:
        -:  845:  // ----------------------------------------------------------------------
        -:  846:  // Calls for messages received on typed input ports
        -:  847:  // ----------------------------------------------------------------------
        -:  848:
      240:  849:  void ActiveRateGroupComponentBase ::
        -:  850:    m_p_CycleIn_in(
        -:  851:        Fw::PassiveComponentBase* callComp,
        -:  852:        NATIVE_INT_TYPE portNum,
        -:  853:        Svc::TimerVal cycle_start
        -:  854:    )
        -:  855:  {
      240:  856:    FW_ASSERT(callComp);
        -:  857:    ActiveRateGroupComponentBase* compPtr =
      240:  858:      (ActiveRateGroupComponentBase*) callComp;
      240:  859:    compPtr->CycleIn_handlerBase(portNum, cycle_start);
      240:  860:  }
        -:  861:
        -:  862:  // ----------------------------------------------------------------------
        -:  863:  // Port handler base-class functions for typed input ports
        -:  864:  // ----------------------------------------------------------------------
        -:  865:
      240:  866:  void ActiveRateGroupComponentBase ::
        -:  867:    CycleIn_handlerBase(
        -:  868:        NATIVE_INT_TYPE portNum,
        -:  869:        Svc::TimerVal cycle_start
        -:  870:    )
        -:  871:  {
        -:  872:
        -:  873:    // Make sure port number is valid
      240:  874:    FW_ASSERT(portNum < this->getNum_CycleIn_InputPorts());
        -:  875:
        -:  876:    // Call pre-message hook
        -:  877:    CycleIn_preMsgHook(
        -:  878:        portNum,
        -:  879:        cycle_start
      240:  880:    );
        -:  881:
      240:  882:    ComponentIpcSerializableBuffer msg;
        -:  883:    Fw::SerializeStatus _status;
        -:  884:
        -:  885:    _status = msg.serialize(
        -:  886:        static_cast<NATIVE_INT_TYPE>(CYCLEIN_CYCLE)
      240:  887:    );
      240:  888:    FW_ASSERT (
        -:  889:        _status == Fw::FW_SERIALIZE_OK,
        -:  890:        static_cast<NATIVE_INT_TYPE>(_status)
      480:  891:    );
        -:  892:
      240:  893:    _status = msg.serialize(portNum);
      240:  894:    FW_ASSERT (
        -:  895:        _status == Fw::FW_SERIALIZE_OK,
        -:  896:        static_cast<NATIVE_INT_TYPE>(_status)
      480:  897:    );
        -:  898:
        -:  899:    // Serialize argument cycle_start
      240:  900:    _status = msg.serialize(cycle_start);
      240:  901:    FW_ASSERT(
        -:  902:        _status == Fw::FW_SERIALIZE_OK,
        -:  903:        static_cast<NATIVE_INT_TYPE>(_status)
      480:  904:    );
        -:  905:
        -:  906:    Os::Queue::QueueStatus qStatus =
      240:  907:      this->m_queue.send(msg, 0);
      240:  908:    FW_ASSERT(
        -:  909:        qStatus == Os::Queue::QUEUE_OK,
        -:  910:        static_cast<NATIVE_INT_TYPE>(qStatus)
      720:  911:    );
      240:  912:  }
        -:  913:
        -:  914:  // ----------------------------------------------------------------------
        -:  915:  // Pre-message hooks for async input ports
        -:  916:  // ----------------------------------------------------------------------
        -:  917:
    #####:  918:  void ActiveRateGroupComponentBase ::
        -:  919:    CycleIn_preMsgHook(
        -:  920:        NATIVE_INT_TYPE portNum,
        -:  921:        Svc::TimerVal cycle_start
        -:  922:    )
        -:  923:  {
        -:  924:    // Default: no-op
    #####:  925:  }
        -:  926:
        -:  927:  // ----------------------------------------------------------------------
        -:  928:  // Message dispatch method for active and queued components. Called
        -:  929:  // by active component thread or implementation code for queued components
        -:  930:  // ----------------------------------------------------------------------
        -:  931:
      135:  932:  Fw::QueuedComponentBase::MsgDispatchStatus ActiveRateGroupComponentBase ::
        -:  933:    doDispatch(void)
        -:  934:  {
        -:  935:
      135:  936:    ComponentIpcSerializableBuffer msg;
        -:  937:    NATIVE_INT_TYPE priority;
        -:  938:
      135:  939:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority);
      135:  940:    FW_ASSERT(
        -:  941:        msgStatus == Os::Queue::QUEUE_OK,
        -:  942:        static_cast<NATIVE_INT_TYPE>(msgStatus)
      270:  943:    );
        -:  944:
        -:  945:    // Reset to beginning of buffer
      135:  946:    msg.resetDeser();
        -:  947:
        -:  948:    NATIVE_INT_TYPE desMsg;
      135:  949:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
      135:  950:    FW_ASSERT(
        -:  951:        deserStatus == Fw::FW_SERIALIZE_OK,
        -:  952:        static_cast<NATIVE_INT_TYPE>(deserStatus)
      270:  953:    );
        -:  954:
      135:  955:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -:  956:
      135:  957:    if (msgType == ACTIVERATEGROUP_COMPONENT_EXIT) {
    #####:  958:      return MSG_DISPATCH_EXIT;
        -:  959:    }
        -:  960:
        -:  961:    NATIVE_INT_TYPE portNum;
      135:  962:    deserStatus = msg.deserialize(portNum);
      135:  963:    FW_ASSERT(
        -:  964:        deserStatus == Fw::FW_SERIALIZE_OK,
        -:  965:        static_cast<NATIVE_INT_TYPE>(deserStatus)
      270:  966:    );
        -:  967:
      135:  968:    switch (msgType) {
        -:  969:
        -:  970:      // Handle async input port CycleIn
        -:  971:      case CYCLEIN_CYCLE: {
        -:  972:
        -:  973:        // Deserialize argument cycle_start
      135:  974:        Svc::TimerVal cycle_start;
      135:  975:        deserStatus = msg.deserialize(cycle_start);
      135:  976:        FW_ASSERT(
        -:  977:            deserStatus == Fw::FW_SERIALIZE_OK,
        -:  978:            static_cast<NATIVE_INT_TYPE>(deserStatus)
      270:  979:        );
        -:  980:
        -:  981:        // Call handler function
        -:  982:        this->CycleIn_handler(
        -:  983:            portNum,
        -:  984:            cycle_start
      135:  985:        );
        -:  986:
      135:  987:        break;
        -:  988:
        -:  989:      }
        -:  990:
        -:  991:      default:
    #####:  992:        return MSG_DISPATCH_ERROR;
        -:  993:
        -:  994:    }
        -:  995:
      270:  996:    return MSG_DISPATCH_OK;
        -:  997:
        -:  998:  }
        -:  999:
        -: 1000:}
        -: 1001:
