        -:    0:Source:/home/tim/source/isf/Svc/CmdDispatcher/CommandDispatcherComponentAc.cpp
        -:    0:Programs:5
        -:    1:// ====================================================================== 
        -:    2:// \title  CommandDispatcherComponentAc.hpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for CommandDispatcher component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   11:// 
        -:   18:// ====================================================================== 
        -:   19:
        -:   20:#include <stdio.h>
        -:   21:#include <Fw/Cfg/Config.hpp>
        -:   22:#include <Svc/CmdDispatcher/CommandDispatcherComponentAc.hpp>
        -:   23:#include <Fw/Types/Assert.hpp>
        -:   24:#if FW_ENABLE_TEXT_LOGGING
        -:   25:#include <Fw/Types/EightyCharString.hpp>
        -:   26:#endif
        -:   27:
        -:   28:
        -:   29:namespace Svc {
        -:   30:
        -:   31:  // ----------------------------------------------------------------------
        -:   32:  // Anonymous namespace to prevent name collisions
        -:   33:  // ----------------------------------------------------------------------
        -:   34:
        -:   35:  namespace {
        -:   36:
        -:   37:    typedef enum {
        -:   38:      COMMANDDISPATCHER_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   39:      COMPCMDSTAT_CMDRESPONSE,
        -:   40:      SEQCMDBUFF_COM,
        -:   41:      CMD_CMD_NO_OP,
        -:   42:      CMD_CMD_NO_OP_STRING,
        -:   43:      CMD_CMD_TEST_CMD_1,
        -:   44:      CMD_CMD_CLEAR_TRACKING
        -:   45:    } MsgTypeEnum;
        -:   46:
        -:   47:    // Get the max size by doing a union of the input port serialization sizes.
        -:   48:
        -:   49:    typedef union {
        -:   50:      BYTE port1[Fw::InputCmdResponsePort::SERIALIZED_SIZE];
        -:   51:      BYTE port2[Fw::InputComPort::SERIALIZED_SIZE];
        -:   52:      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
        -:   53:    } BuffUnion;
        -:   54:
        -:   55:    // Define a message buffer class large enough to handle all the
        -:   56:    // asynchronous inputs to the component
        -:   57:
      562:   58:    class ComponentIpcSerializableBuffer : 
        -:   59:      public Fw::SerializeBufferBase
        -:   60:    {
        -:   61:
        -:   62:      public:
        -:   63:
        -:   64:        enum {
        -:   65:          // Max. message size = size of data + message id + port
        -:   66:          SERIALIZATION_SIZE =
        -:   67:            sizeof(BuffUnion) +
        -:   68:            sizeof(NATIVE_INT_TYPE) +
        -:   69:            sizeof(NATIVE_INT_TYPE)
        -:   70:        };
        -:   71:
     1000:   72:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
     1000:   73:          return sizeof(m_buff);
        -:   74:        }
        -:   75:
     6094:   76:        U8* getBuffAddr(void) {
     6094:   77:          return m_buff;
        -:   78:        }
        -:   79:
      142:   80:        const U8* getBuffAddr(void) const {
      142:   81:          return m_buff;
        -:   82:        }
        -:   83:
        -:   84:      private:
        -:   85:        // Should be the max of all the input ports serialized sizes...
        -:   86:        U8 m_buff[SERIALIZATION_SIZE];
        -:   87:
        -:   88:    };
        -:   89:
        -:   90:  }
        -:   91:
        -:   92:  // ----------------------------------------------------------------------
        -:   93:  // Getters for numbers of input ports
        -:   94:  // ----------------------------------------------------------------------
        -:   95:
       42:   96:  Fw::InputCmdRegPort *CommandDispatcherComponentBase ::
        -:   97:    get_compCmdReg_InputPort(NATIVE_INT_TYPE portNum)
        -:   98:  {
       42:   99:    FW_ASSERT(portNum < this->getNum_compCmdReg_InputPorts(),static_cast<AssertArg>(portNum));
       42:  100:    return &this->m_compCmdReg_InputPort[portNum];
        -:  101:  }
        -:  102:
       42:  103:  Fw::InputCmdResponsePort *CommandDispatcherComponentBase ::
        -:  104:    get_compCmdStat_InputPort(NATIVE_INT_TYPE portNum)
        -:  105:  {
       42:  106:    FW_ASSERT(portNum < this->getNum_compCmdStat_InputPorts(),static_cast<AssertArg>(portNum));
       42:  107:    return &this->m_compCmdStat_InputPort[portNum];
        -:  108:  }
        -:  109:
       21:  110:  Fw::InputComPort *CommandDispatcherComponentBase ::
        -:  111:    get_seqCmdBuff_InputPort(NATIVE_INT_TYPE portNum)
        -:  112:  {
       21:  113:    FW_ASSERT(portNum < this->getNum_seqCmdBuff_InputPorts(),static_cast<AssertArg>(portNum));
       21:  114:    return &this->m_seqCmdBuff_InputPort[portNum];
        -:  115:  }
        -:  116:
       21:  117:  Fw::InputCmdPort *CommandDispatcherComponentBase ::
        -:  118:    get_CmdDisp_InputPort(NATIVE_INT_TYPE portNum)
        -:  119:  {
       21:  120:    FW_ASSERT(portNum < this->getNum_CmdDisp_InputPorts(),static_cast<AssertArg>(portNum));
       21:  121:    return &this->m_CmdDisp_InputPort[portNum];
        -:  122:  }
        -:  123:
        -:  124:  // ----------------------------------------------------------------------
        -:  125:  // Typed connectors for output ports
        -:  126:  // ----------------------------------------------------------------------
        -:  127:
       42:  128:  void CommandDispatcherComponentBase ::
        -:  129:    set_compCmdSend_OutputPort(
        -:  130:        NATIVE_INT_TYPE portNum,
        -:  131:        Fw::InputCmdPort* port
        -:  132:    )
        -:  133:  {
       42:  134:    FW_ASSERT(portNum < this->getNum_compCmdSend_OutputPorts(),static_cast<AssertArg>(portNum));
       42:  135:    this->m_compCmdSend_OutputPort[portNum].addCallPort(port);
       42:  136:  }
        -:  137:
       21:  138:  void CommandDispatcherComponentBase ::
        -:  139:    set_seqCmdStatus_OutputPort(
        -:  140:        NATIVE_INT_TYPE portNum,
        -:  141:        Fw::InputCmdResponsePort* port
        -:  142:    )
        -:  143:  {
       21:  144:    FW_ASSERT(portNum < this->getNum_seqCmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  145:    this->m_seqCmdStatus_OutputPort[portNum].addCallPort(port);
       21:  146:  }
        -:  147:
       21:  148:  void CommandDispatcherComponentBase ::
        -:  149:    set_CmdStatus_OutputPort(
        -:  150:        NATIVE_INT_TYPE portNum,
        -:  151:        Fw::InputCmdResponsePort* port
        -:  152:    )
        -:  153:  {
       21:  154:    FW_ASSERT(portNum < this->getNum_CmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  155:    this->m_CmdStatus_OutputPort[portNum].addCallPort(port);
       21:  156:  }
        -:  157:
       21:  158:  void CommandDispatcherComponentBase ::
        -:  159:    set_CmdReg_OutputPort(
        -:  160:        NATIVE_INT_TYPE portNum,
        -:  161:        Fw::InputCmdRegPort* port
        -:  162:    )
        -:  163:  {
       21:  164:    FW_ASSERT(portNum < this->getNum_CmdReg_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  165:    this->m_CmdReg_OutputPort[portNum].addCallPort(port);
       21:  166:  }
        -:  167:
       21:  168:  void CommandDispatcherComponentBase ::
        -:  169:    set_Tlm_OutputPort(
        -:  170:        NATIVE_INT_TYPE portNum,
        -:  171:        Fw::InputTlmPort* port
        -:  172:    )
        -:  173:  {
       21:  174:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  175:    this->m_Tlm_OutputPort[portNum].addCallPort(port);
       21:  176:  }
        -:  177:
       21:  178:  void CommandDispatcherComponentBase ::
        -:  179:    set_Time_OutputPort(
        -:  180:        NATIVE_INT_TYPE portNum,
        -:  181:        Fw::InputTimePort* port
        -:  182:    )
        -:  183:  {
       21:  184:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  185:    this->m_Time_OutputPort[portNum].addCallPort(port);
       21:  186:  }
        -:  187:
       21:  188:  void CommandDispatcherComponentBase ::
        -:  189:    set_Log_OutputPort(
        -:  190:        NATIVE_INT_TYPE portNum,
        -:  191:        Fw::InputLogPort* port
        -:  192:    )
        -:  193:  {
       21:  194:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  195:    this->m_Log_OutputPort[portNum].addCallPort(port);
       21:  196:  }
        -:  197:
        -:  198:#if FW_ENABLE_TEXT_LOGGING == 1
       21:  199:  void CommandDispatcherComponentBase ::
        -:  200:    set_LogText_OutputPort(
        -:  201:        NATIVE_INT_TYPE portNum,
        -:  202:        Fw::InputLogTextPort* port
        -:  203:    )
        -:  204:  {
       21:  205:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
       21:  206:    this->m_LogText_OutputPort[portNum].addCallPort(port);
       21:  207:  }
        -:  208:#endif
        -:  209:
        -:  210:  // ----------------------------------------------------------------------
        -:  211:  // Serialization connectors for output ports
        -:  212:  // ----------------------------------------------------------------------
        -:  213:
        -:  214:#if FW_PORT_SERIALIZATION
        -:  215:
    #####:  216:  void CommandDispatcherComponentBase ::
        -:  217:    set_compCmdSend_OutputPort(
        -:  218:        NATIVE_INT_TYPE portNum,
        -:  219:        Fw::InputSerializePort *port
        -:  220:    )
        -:  221:  {
    #####:  222:    FW_ASSERT(portNum < this->getNum_compCmdSend_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  223:    return this->m_compCmdSend_OutputPort[portNum].registerSerialPort(port);
        -:  224:  }
        -:  225:
    #####:  226:  void CommandDispatcherComponentBase ::
        -:  227:    set_seqCmdStatus_OutputPort(
        -:  228:        NATIVE_INT_TYPE portNum,
        -:  229:        Fw::InputSerializePort *port
        -:  230:    )
        -:  231:  {
    #####:  232:    FW_ASSERT(portNum < this->getNum_seqCmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  233:    return this->m_seqCmdStatus_OutputPort[portNum].registerSerialPort(port);
        -:  234:  }
        -:  235:
    #####:  236:  void CommandDispatcherComponentBase ::
        -:  237:    set_CmdStatus_OutputPort(
        -:  238:        NATIVE_INT_TYPE portNum,
        -:  239:        Fw::InputSerializePort *port
        -:  240:    )
        -:  241:  {
    #####:  242:    FW_ASSERT(portNum < this->getNum_CmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  243:    return this->m_CmdStatus_OutputPort[portNum].registerSerialPort(port);
        -:  244:  }
        -:  245:
    #####:  246:  void CommandDispatcherComponentBase ::
        -:  247:    set_CmdReg_OutputPort(
        -:  248:        NATIVE_INT_TYPE portNum,
        -:  249:        Fw::InputSerializePort *port
        -:  250:    )
        -:  251:  {
    #####:  252:    FW_ASSERT(portNum < this->getNum_CmdReg_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  253:    return this->m_CmdReg_OutputPort[portNum].registerSerialPort(port);
        -:  254:  }
        -:  255:
    #####:  256:  void CommandDispatcherComponentBase ::
        -:  257:    set_Tlm_OutputPort(
        -:  258:        NATIVE_INT_TYPE portNum,
        -:  259:        Fw::InputSerializePort *port
        -:  260:    )
        -:  261:  {
    #####:  262:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  263:    return this->m_Tlm_OutputPort[portNum].registerSerialPort(port);
        -:  264:  }
        -:  265:
    #####:  266:  void CommandDispatcherComponentBase ::
        -:  267:    set_Time_OutputPort(
        -:  268:        NATIVE_INT_TYPE portNum,
        -:  269:        Fw::InputSerializePort *port
        -:  270:    )
        -:  271:  {
    #####:  272:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  273:    return this->m_Time_OutputPort[portNum].registerSerialPort(port);
        -:  274:  }
        -:  275:
    #####:  276:  void CommandDispatcherComponentBase ::
        -:  277:    set_Log_OutputPort(
        -:  278:        NATIVE_INT_TYPE portNum,
        -:  279:        Fw::InputSerializePort *port
        -:  280:    )
        -:  281:  {
    #####:  282:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  283:    return this->m_Log_OutputPort[portNum].registerSerialPort(port);
        -:  284:  }
        -:  285:
        -:  286:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  287:  void CommandDispatcherComponentBase ::
        -:  288:    set_LogText_OutputPort(
        -:  289:        NATIVE_INT_TYPE portNum,
        -:  290:        Fw::InputSerializePort *port
        -:  291:    )
        -:  292:  {
    #####:  293:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  294:    return this->m_LogText_OutputPort[portNum].registerSerialPort(port);
        -:  295:  }
        -:  296:#endif
        -:  297:
        -:  298:#endif
        -:  299:
        -:  300:  // ----------------------------------------------------------------------
        -:  301:  // Command registration
        -:  302:  // ----------------------------------------------------------------------
        -:  303:
       18:  304:  void CommandDispatcherComponentBase ::
        -:  305:    regCommands(void)
        -:  306:  {
       18:  307:    FW_ASSERT(this->m_CmdReg_OutputPort[0].isConnected());
       18:  308:    this->m_CmdReg_OutputPort[0].invoke(OPCODE_CMD_NO_OP);
       18:  309:    this->m_CmdReg_OutputPort[0].invoke(OPCODE_CMD_NO_OP_STRING);
       18:  310:    this->m_CmdReg_OutputPort[0].invoke(OPCODE_CMD_TEST_CMD_1);
       18:  311:    this->m_CmdReg_OutputPort[0].invoke(OPCODE_CMD_CLEAR_TRACKING);
       18:  312:  }
        -:  313:
        -:  314:  // ----------------------------------------------------------------------
        -:  315:  // Component construction, initialization, and destruction
        -:  316:  // ----------------------------------------------------------------------
        -:  317:
       21:  318:  CommandDispatcherComponentBase ::
        -:  319:#if FW_OBJECT_NAMES == 1
        -:  320:    CommandDispatcherComponentBase(const char* compName) :
       21:  321:      Fw::ActiveComponentBase(compName)
        -:  322:#else
        -:  323:    CommandDispatcherComponentBase() :
        -:  324:      Fw::ActiveComponentBase()
        -:  325:#endif
        -:  326:  {
        -:  327:
        -:  328:    // Initialize telemetry channel CommandsDispatched
       21:  329:    this->m_first_update_CommandsDispatched = true;
       21:  330:    this->m_last_CommandsDispatched = 0;
        -:  331:
        -:  332:    // Initialize telemetry channel CommandErrors
       21:  333:    this->m_first_update_CommandErrors = true;
       21:  334:    this->m_last_CommandErrors = 0;
        -:  335:
       21:  336:  }
        -:  337:
       21:  338:  void CommandDispatcherComponentBase ::
        -:  339:    init(
        -:  340:        NATIVE_INT_TYPE queueDepth,
        -:  341:        NATIVE_INT_TYPE instance
        -:  342:    )
        -:  343:  {
        -:  344:
        -:  345:    // Initialize base class
       21:  346:    Fw::ActiveComponentBase::init(instance);
        -:  347:
        -:  348:    // Connect input port compCmdReg
      462:  349:    for (
       21:  350:        NATIVE_INT_TYPE port = 0;
      231:  351:        port < this->getNum_compCmdReg_InputPorts();
        -:  352:        port++
        -:  353:    ) {
        -:  354:
      210:  355:      this->m_compCmdReg_InputPort[port].init();
        -:  356:      this->m_compCmdReg_InputPort[port].addCallComp(
        -:  357:          this,
        -:  358:          m_p_compCmdReg_in
      210:  359:      );
      210:  360:      this->m_compCmdReg_InputPort[port].setPortNum(port);
        -:  361:
        -:  362:#if FW_OBJECT_NAMES == 1
        -:  363:      char portName[80];
        -:  364:      (void) snprintf(
        -:  365:          portName,
        -:  366:          sizeof(portName),
        -:  367:          "%s_compCmdReg_InputPort[%d]",
        -:  368:          this->m_objName,
        -:  369:          port
      210:  370:      );
      210:  371:      this->m_compCmdReg_InputPort[port].setObjName(portName);
        -:  372:#endif
        -:  373:
        -:  374:    }
        -:  375:
        -:  376:    // Connect input port compCmdStat
       84:  377:    for (
       21:  378:        NATIVE_INT_TYPE port = 0;
       42:  379:        port < this->getNum_compCmdStat_InputPorts();
        -:  380:        port++
        -:  381:    ) {
        -:  382:
       21:  383:      this->m_compCmdStat_InputPort[port].init();
        -:  384:      this->m_compCmdStat_InputPort[port].addCallComp(
        -:  385:          this,
        -:  386:          m_p_compCmdStat_in
       21:  387:      );
       21:  388:      this->m_compCmdStat_InputPort[port].setPortNum(port);
        -:  389:
        -:  390:#if FW_OBJECT_NAMES == 1
        -:  391:      char portName[80];
        -:  392:      (void) snprintf(
        -:  393:          portName,
        -:  394:          sizeof(portName),
        -:  395:          "%s_compCmdStat_InputPort[%d]",
        -:  396:          this->m_objName,
        -:  397:          port
       21:  398:      );
       21:  399:      this->m_compCmdStat_InputPort[port].setObjName(portName);
        -:  400:#endif
        -:  401:
        -:  402:    }
        -:  403:
        -:  404:    // Connect input port seqCmdBuff
      252:  405:    for (
       21:  406:        NATIVE_INT_TYPE port = 0;
      126:  407:        port < this->getNum_seqCmdBuff_InputPorts();
        -:  408:        port++
        -:  409:    ) {
        -:  410:
      105:  411:      this->m_seqCmdBuff_InputPort[port].init();
        -:  412:      this->m_seqCmdBuff_InputPort[port].addCallComp(
        -:  413:          this,
        -:  414:          m_p_seqCmdBuff_in
      105:  415:      );
      105:  416:      this->m_seqCmdBuff_InputPort[port].setPortNum(port);
        -:  417:
        -:  418:#if FW_OBJECT_NAMES == 1
        -:  419:      char portName[80];
        -:  420:      (void) snprintf(
        -:  421:          portName,
        -:  422:          sizeof(portName),
        -:  423:          "%s_seqCmdBuff_InputPort[%d]",
        -:  424:          this->m_objName,
        -:  425:          port
      105:  426:      );
      105:  427:      this->m_seqCmdBuff_InputPort[port].setObjName(portName);
        -:  428:#endif
        -:  429:
        -:  430:    }
        -:  431:
        -:  432:    // Connect input port CmdDisp
       84:  433:    for (
       21:  434:        NATIVE_INT_TYPE port = 0;
       42:  435:        port < this->getNum_CmdDisp_InputPorts();
        -:  436:        port++
        -:  437:    ) {
        -:  438:
       21:  439:      this->m_CmdDisp_InputPort[port].init();
        -:  440:      this->m_CmdDisp_InputPort[port].addCallComp(
        -:  441:          this,
        -:  442:          m_p_CmdDisp_in
       21:  443:      );
       21:  444:      this->m_CmdDisp_InputPort[port].setPortNum(port);
        -:  445:
        -:  446:#if FW_OBJECT_NAMES == 1
        -:  447:      char portName[80];
        -:  448:      (void) snprintf(
        -:  449:          portName,
        -:  450:          sizeof(portName),
        -:  451:          "%s_CmdDisp_InputPort[%d]",
        -:  452:          this->m_objName,
        -:  453:          port
       21:  454:      );
       21:  455:      this->m_CmdDisp_InputPort[port].setObjName(portName);
        -:  456:#endif
        -:  457:
        -:  458:    }
        -:  459:
        -:  460:    // Initialize output port compCmdSend
      462:  461:    for (
       21:  462:        NATIVE_INT_TYPE port = 0;
      231:  463:        port < this->getNum_compCmdSend_OutputPorts();
        -:  464:        port++
        -:  465:    ) {
      210:  466:      this->m_compCmdSend_OutputPort[port].init();
        -:  467:
        -:  468:#if FW_OBJECT_NAMES == 1
        -:  469:      char portName[80];
        -:  470:      (void) snprintf(
        -:  471:          portName,
        -:  472:          sizeof(portName),
        -:  473:          "%s_compCmdSend_OutputPort[%d]",
        -:  474:          this->m_objName,
        -:  475:          port
      210:  476:      );
      210:  477:      this->m_compCmdSend_OutputPort[port].setObjName(portName);
        -:  478:#endif
        -:  479:
        -:  480:    }
        -:  481:
        -:  482:    // Initialize output port seqCmdStatus
      252:  483:    for (
       21:  484:        NATIVE_INT_TYPE port = 0;
      126:  485:        port < this->getNum_seqCmdStatus_OutputPorts();
        -:  486:        port++
        -:  487:    ) {
      105:  488:      this->m_seqCmdStatus_OutputPort[port].init();
        -:  489:
        -:  490:#if FW_OBJECT_NAMES == 1
        -:  491:      char portName[80];
        -:  492:      (void) snprintf(
        -:  493:          portName,
        -:  494:          sizeof(portName),
        -:  495:          "%s_seqCmdStatus_OutputPort[%d]",
        -:  496:          this->m_objName,
        -:  497:          port
      105:  498:      );
      105:  499:      this->m_seqCmdStatus_OutputPort[port].setObjName(portName);
        -:  500:#endif
        -:  501:
        -:  502:    }
        -:  503:
        -:  504:    // Initialize output port CmdStatus
       84:  505:    for (
       21:  506:        NATIVE_INT_TYPE port = 0;
       42:  507:        port < this->getNum_CmdStatus_OutputPorts();
        -:  508:        port++
        -:  509:    ) {
       21:  510:      this->m_CmdStatus_OutputPort[port].init();
        -:  511:
        -:  512:#if FW_OBJECT_NAMES == 1
        -:  513:      char portName[80];
        -:  514:      (void) snprintf(
        -:  515:          portName,
        -:  516:          sizeof(portName),
        -:  517:          "%s_CmdStatus_OutputPort[%d]",
        -:  518:          this->m_objName,
        -:  519:          port
       21:  520:      );
       21:  521:      this->m_CmdStatus_OutputPort[port].setObjName(portName);
        -:  522:#endif
        -:  523:
        -:  524:    }
        -:  525:
        -:  526:    // Initialize output port CmdReg
       84:  527:    for (
       21:  528:        NATIVE_INT_TYPE port = 0;
       42:  529:        port < this->getNum_CmdReg_OutputPorts();
        -:  530:        port++
        -:  531:    ) {
       21:  532:      this->m_CmdReg_OutputPort[port].init();
        -:  533:
        -:  534:#if FW_OBJECT_NAMES == 1
        -:  535:      char portName[80];
        -:  536:      (void) snprintf(
        -:  537:          portName,
        -:  538:          sizeof(portName),
        -:  539:          "%s_CmdReg_OutputPort[%d]",
        -:  540:          this->m_objName,
        -:  541:          port
       21:  542:      );
       21:  543:      this->m_CmdReg_OutputPort[port].setObjName(portName);
        -:  544:#endif
        -:  545:
        -:  546:    }
        -:  547:
        -:  548:    // Initialize output port Tlm
       84:  549:    for (
       21:  550:        NATIVE_INT_TYPE port = 0;
       42:  551:        port < this->getNum_Tlm_OutputPorts();
        -:  552:        port++
        -:  553:    ) {
       21:  554:      this->m_Tlm_OutputPort[port].init();
        -:  555:
        -:  556:#if FW_OBJECT_NAMES == 1
        -:  557:      char portName[80];
        -:  558:      (void) snprintf(
        -:  559:          portName,
        -:  560:          sizeof(portName),
        -:  561:          "%s_Tlm_OutputPort[%d]",
        -:  562:          this->m_objName,
        -:  563:          port
       21:  564:      );
       21:  565:      this->m_Tlm_OutputPort[port].setObjName(portName);
        -:  566:#endif
        -:  567:
        -:  568:    }
        -:  569:
        -:  570:    // Initialize output port Time
       84:  571:    for (
       21:  572:        NATIVE_INT_TYPE port = 0;
       42:  573:        port < this->getNum_Time_OutputPorts();
        -:  574:        port++
        -:  575:    ) {
       21:  576:      this->m_Time_OutputPort[port].init();
        -:  577:
        -:  578:#if FW_OBJECT_NAMES == 1
        -:  579:      char portName[80];
        -:  580:      (void) snprintf(
        -:  581:          portName,
        -:  582:          sizeof(portName),
        -:  583:          "%s_Time_OutputPort[%d]",
        -:  584:          this->m_objName,
        -:  585:          port
       21:  586:      );
       21:  587:      this->m_Time_OutputPort[port].setObjName(portName);
        -:  588:#endif
        -:  589:
        -:  590:    }
        -:  591:
        -:  592:    // Initialize output port Log
       84:  593:    for (
       21:  594:        NATIVE_INT_TYPE port = 0;
       42:  595:        port < this->getNum_Log_OutputPorts();
        -:  596:        port++
        -:  597:    ) {
       21:  598:      this->m_Log_OutputPort[port].init();
        -:  599:
        -:  600:#if FW_OBJECT_NAMES == 1
        -:  601:      char portName[80];
        -:  602:      (void) snprintf(
        -:  603:          portName,
        -:  604:          sizeof(portName),
        -:  605:          "%s_Log_OutputPort[%d]",
        -:  606:          this->m_objName,
        -:  607:          port
       21:  608:      );
       21:  609:      this->m_Log_OutputPort[port].setObjName(portName);
        -:  610:#endif
        -:  611:
        -:  612:    }
        -:  613:
        -:  614:    // Initialize output port LogText
        -:  615:#if FW_ENABLE_TEXT_LOGGING == 1
       84:  616:    for (
       21:  617:        NATIVE_INT_TYPE port = 0;
       42:  618:        port < this->getNum_LogText_OutputPorts();
        -:  619:        port++
        -:  620:    ) {
       21:  621:      this->m_LogText_OutputPort[port].init();
        -:  622:
        -:  623:#if FW_OBJECT_NAMES == 1
        -:  624:      char portName[80];
        -:  625:      (void) snprintf(
        -:  626:          portName,
        -:  627:          sizeof(portName),
        -:  628:          "%s_LogText_OutputPort[%d]",
        -:  629:          this->m_objName,
        -:  630:          port
       21:  631:      );
       21:  632:      this->m_LogText_OutputPort[port].setObjName(portName);
        -:  633:#endif
        -:  634:
        -:  635:    }
        -:  636:#endif
        -:  637:
        -:  638:    Os::Queue::QueueStatus qStat =
        -:  639:    this->createQueue(
        -:  640:        queueDepth,
        -:  641:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
       21:  642:    );
        -:  643:    FW_ASSERT(
        -:  644:        Os::Queue::QUEUE_OK == qStat,
        -:  645:        static_cast<AssertArg>(qStat)
       21:  646:    );
        -:  647:
       21:  648:  }
        -:  649:
       21:  650:  CommandDispatcherComponentBase::
       21:  651:    ~CommandDispatcherComponentBase() {
        -:  652:
       21:  653:  }
        -:  654:
        -:  655:  // ----------------------------------------------------------------------
        -:  656:  // Invocation functions for output ports
        -:  657:  // ----------------------------------------------------------------------
        -:  658:
       98:  659:  void CommandDispatcherComponentBase ::
        -:  660:    compCmdSend_out(
        -:  661:        NATIVE_INT_TYPE portNum,
        -:  662:        FwOpcodeType opCode, U32 cmdSeq, Fw::CmdArgBuffer &args
        -:  663:    )
        -:  664:  {
       98:  665:    FW_ASSERT(portNum < this->getNum_compCmdSend_OutputPorts(),static_cast<AssertArg>(portNum));
       98:  666:    m_compCmdSend_OutputPort[portNum].invoke(opCode, cmdSeq, args);
       98:  667:  }
        -:  668:
       26:  669:  void CommandDispatcherComponentBase ::
        -:  670:    seqCmdStatus_out(
        -:  671:        NATIVE_INT_TYPE portNum,
        -:  672:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -:  673:    )
        -:  674:  {
       26:  675:    FW_ASSERT(portNum < this->getNum_seqCmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
       26:  676:    m_seqCmdStatus_OutputPort[portNum].invoke(opCode, cmdSeq, response);
       26:  677:  }
        -:  678:
        -:  679:  // ----------------------------------------------------------------------
        -:  680:  // Getters for numbers of ports
        -:  681:  // ----------------------------------------------------------------------
        -:  682:
      472:  683:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  684:    getNum_compCmdSend_OutputPorts(void)
        -:  685:  {
      472:  686:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  687:        this->m_compCmdSend_OutputPort
        -:  688:    );
        -:  689:  }
        -:  690:
      360:  691:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  692:    getNum_compCmdReg_InputPorts(void)
        -:  693:  {
      360:  694:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  695:        this->m_compCmdReg_InputPort
        -:  696:    );
        -:  697:  }
        -:  698:
      107:  699:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  700:    getNum_compCmdStat_InputPorts(void)
        -:  701:  {
      107:  702:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  703:        this->m_compCmdStat_InputPort
        -:  704:    );
        -:  705:  }
        -:  706:
      317:  707:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  708:    getNum_seqCmdStatus_OutputPorts(void)
        -:  709:  {
      317:  710:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  711:        this->m_seqCmdStatus_OutputPort
        -:  712:    );
        -:  713:  }
        -:  714:
      254:  715:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  716:    getNum_seqCmdBuff_InputPorts(void)
        -:  717:  {
      254:  718:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  719:        this->m_seqCmdBuff_InputPort
        -:  720:    );
        -:  721:  }
        -:  722:
       63:  723:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  724:    getNum_CmdDisp_InputPorts(void)
        -:  725:  {
       63:  726:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  727:        this->m_CmdDisp_InputPort
        -:  728:    );
        -:  729:  }
        -:  730:
       63:  731:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  732:    getNum_CmdStatus_OutputPorts(void)
        -:  733:  {
       63:  734:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  735:        this->m_CmdStatus_OutputPort
        -:  736:    );
        -:  737:  }
        -:  738:
       63:  739:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  740:    getNum_CmdReg_OutputPorts(void)
        -:  741:  {
       63:  742:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  743:        this->m_CmdReg_OutputPort
        -:  744:    );
        -:  745:  }
        -:  746:
       63:  747:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  748:    getNum_Tlm_OutputPorts(void)
        -:  749:  {
       63:  750:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  751:        this->m_Tlm_OutputPort
        -:  752:    );
        -:  753:  }
        -:  754:
       63:  755:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  756:    getNum_Time_OutputPorts(void)
        -:  757:  {
       63:  758:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  759:        this->m_Time_OutputPort
        -:  760:    );
        -:  761:  }
        -:  762:
       63:  763:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  764:    getNum_Log_OutputPorts(void)
        -:  765:  {
       63:  766:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  767:        this->m_Log_OutputPort
        -:  768:    );
        -:  769:  }
        -:  770:
        -:  771:#if FW_ENABLE_TEXT_LOGGING == 1
       63:  772:  NATIVE_INT_TYPE CommandDispatcherComponentBase ::
        -:  773:    getNum_LogText_OutputPorts(void)
        -:  774:  {
       63:  775:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  776:        this->m_LogText_OutputPort
        -:  777:    );
        -:  778:  }
        -:  779:#endif
        -:  780:
        -:  781:  // ----------------------------------------------------------------------
        -:  782:  // Port connection status queries
        -:  783:  // ----------------------------------------------------------------------
        -:  784:
      101:  785:  bool CommandDispatcherComponentBase ::
        -:  786:    isConnected_compCmdSend_OutputPort(NATIVE_INT_TYPE portNum)
        -:  787:  {
      101:  788:     FW_ASSERT(
        -:  789:        portNum < this->getNum_compCmdSend_OutputPorts(),
        -:  790:        static_cast<AssertArg>(portNum)
      101:  791:     );
      101:  792:     return this->m_compCmdSend_OutputPort[portNum].isConnected();
        -:  793:  }
        -:  794:
      127:  795:  bool CommandDispatcherComponentBase ::
        -:  796:    isConnected_seqCmdStatus_OutputPort(NATIVE_INT_TYPE portNum)
        -:  797:  {
      127:  798:     FW_ASSERT(
        -:  799:        portNum < this->getNum_seqCmdStatus_OutputPorts(),
        -:  800:        static_cast<AssertArg>(portNum)
      127:  801:     );
      127:  802:     return this->m_seqCmdStatus_OutputPort[portNum].isConnected();
        -:  803:  }
        -:  804:
    #####:  805:  bool CommandDispatcherComponentBase ::
        -:  806:    isConnected_CmdStatus_OutputPort(NATIVE_INT_TYPE portNum)
        -:  807:  {
    #####:  808:     FW_ASSERT(
        -:  809:        portNum < this->getNum_CmdStatus_OutputPorts(),
        -:  810:        static_cast<AssertArg>(portNum)
    #####:  811:     );
    #####:  812:     return this->m_CmdStatus_OutputPort[portNum].isConnected();
        -:  813:  }
        -:  814:
    #####:  815:  bool CommandDispatcherComponentBase ::
        -:  816:    isConnected_CmdReg_OutputPort(NATIVE_INT_TYPE portNum)
        -:  817:  {
    #####:  818:     FW_ASSERT(
        -:  819:        portNum < this->getNum_CmdReg_OutputPorts(),
        -:  820:        static_cast<AssertArg>(portNum)
    #####:  821:     );
    #####:  822:     return this->m_CmdReg_OutputPort[portNum].isConnected();
        -:  823:  }
        -:  824:
    #####:  825:  bool CommandDispatcherComponentBase ::
        -:  826:    isConnected_Tlm_OutputPort(NATIVE_INT_TYPE portNum)
        -:  827:  {
    #####:  828:     FW_ASSERT(
        -:  829:        portNum < this->getNum_Tlm_OutputPorts(),
        -:  830:        static_cast<AssertArg>(portNum)
    #####:  831:     );
    #####:  832:     return this->m_Tlm_OutputPort[portNum].isConnected();
        -:  833:  }
        -:  834:
    #####:  835:  bool CommandDispatcherComponentBase ::
        -:  836:    isConnected_Time_OutputPort(NATIVE_INT_TYPE portNum)
        -:  837:  {
    #####:  838:     FW_ASSERT(
        -:  839:        portNum < this->getNum_Time_OutputPorts(),
        -:  840:        static_cast<AssertArg>(portNum)
    #####:  841:     );
    #####:  842:     return this->m_Time_OutputPort[portNum].isConnected();
        -:  843:  }
        -:  844:
    #####:  845:  bool CommandDispatcherComponentBase ::
        -:  846:    isConnected_Log_OutputPort(NATIVE_INT_TYPE portNum)
        -:  847:  {
    #####:  848:     FW_ASSERT(
        -:  849:        portNum < this->getNum_Log_OutputPorts(),
        -:  850:        static_cast<AssertArg>(portNum)
    #####:  851:     );
    #####:  852:     return this->m_Log_OutputPort[portNum].isConnected();
        -:  853:  }
        -:  854:
        -:  855:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  856:  bool CommandDispatcherComponentBase ::
        -:  857:    isConnected_LogText_OutputPort(NATIVE_INT_TYPE portNum)
        -:  858:  {
    #####:  859:     FW_ASSERT(
        -:  860:        portNum < this->getNum_LogText_OutputPorts(),
        -:  861:        static_cast<AssertArg>(portNum)
    #####:  862:     );
    #####:  863:     return this->m_LogText_OutputPort[portNum].isConnected();
        -:  864:  }
        -:  865:#endif
        -:  866:
        -:  867:  // ----------------------------------------------------------------------
        -:  868:  // Calls for messages received on typed input ports
        -:  869:  // ----------------------------------------------------------------------
        -:  870:
       12:  871:  void CommandDispatcherComponentBase ::
        -:  872:    m_p_CmdDisp_in(
        -:  873:        Fw::PassiveComponentBase* callComp,
        -:  874:        NATIVE_INT_TYPE portNum,
        -:  875:        FwOpcodeType opCode,
        -:  876:        U32 cmdSeq,
        -:  877:        Fw::CmdArgBuffer &args
        -:  878:    )
        -:  879:  {
        -:  880:
        -:  881:    // Select base class function based on opcode
       12:  882:    FW_ASSERT(callComp);
        -:  883:    CommandDispatcherComponentBase* compPtr =
       12:  884:      (CommandDispatcherComponentBase*) callComp;
        -:  885:
       12:  886:    switch (opCode) {
        -:  887:
        -:  888:      case OPCODE_CMD_NO_OP:
        -:  889:        compPtr->CMD_NO_OP_cmdHandlerBase(
        -:  890:            opCode,
        -:  891:            cmdSeq,
        -:  892:            args
        3:  893:        );
        3:  894:        break;
        -:  895:        
        -:  896:      case OPCODE_CMD_NO_OP_STRING:
        -:  897:        compPtr->CMD_NO_OP_STRING_cmdHandlerBase(
        -:  898:            opCode,
        -:  899:            cmdSeq,
        -:  900:            args
        3:  901:        );
        3:  902:        break;
        -:  903:        
        -:  904:      case OPCODE_CMD_TEST_CMD_1:
        -:  905:        compPtr->CMD_TEST_CMD_1_cmdHandlerBase(
        -:  906:            opCode,
        -:  907:            cmdSeq,
        -:  908:            args
        3:  909:        );
        3:  910:        break;
        -:  911:        
        -:  912:      case OPCODE_CMD_CLEAR_TRACKING:
        -:  913:        compPtr->CMD_CLEAR_TRACKING_cmdHandlerBase(
        -:  914:            opCode,
        -:  915:            cmdSeq,
        -:  916:            args
        3:  917:        );
        3:  918:        break;
        -:  919:        
        -:  920:      default: {
        -:  921:        compPtr->cmdResponse_out(
        -:  922:            opCode,cmdSeq,
        -:  923:            Fw::COMMAND_INVALID_OPCODE
    #####:  924:        );
    #####:  925:        break;
        -:  926:      }
        -:  927:
        -:  928:    }
        -:  929:
       12:  930:  }
        -:  931:
       12:  932:  void CommandDispatcherComponentBase ::
        -:  933:    cmdResponse_out(
        -:  934:        FwOpcodeType opCode,
        -:  935:        U32 cmdSeq,
        -:  936:        Fw::CommandResponse response
        -:  937:    )
        -:  938:  {
       12:  939:    FW_ASSERT(this->m_CmdStatus_OutputPort[0].isConnected());
       12:  940:    this->m_CmdStatus_OutputPort[0].invoke(opCode,cmdSeq,response);
       12:  941:  }
        -:  942:
        -:  943:  // ----------------------------------------------------------------------
        -:  944:  // Base class command functions
        -:  945:  // ----------------------------------------------------------------------
        -:  946:
        3:  947:  void CommandDispatcherComponentBase ::
        -:  948:    CMD_NO_OP_cmdHandlerBase(
        -:  949:        FwOpcodeType opCode,
        -:  950:        U32 cmdSeq,
        -:  951:        Fw::CmdArgBuffer &args
        -:  952:    )
        -:  953:  {
        -:  954:
        -:  955:    // Call pre-message hook
        3:  956:    this->CMD_NO_OP_preMsgHook(opCode,cmdSeq);
        -:  957:
        -:  958:    // Defer deserializing arguments to the message dispatcher
        -:  959:    // to avoid deserializing and reserializing just for IPC
        3:  960:    ComponentIpcSerializableBuffer msg;
        -:  961:    Fw::SerializeStatus _status;
        -:  962:
        -:  963:    // Serialize for IPC
        3:  964:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CMD_NO_OP);
        -:  965:    FW_ASSERT (
        -:  966:        _status == Fw::FW_SERIALIZE_OK,
        -:  967:        static_cast<AssertArg>(_status)
        3:  968:        );
        -:  969:
        -:  970:    // Fake port number to make message dequeue work
        3:  971:    NATIVE_INT_TYPE port = 0;
        3:  972:    _status = msg.serialize(port);
        -:  973:    FW_ASSERT (
        -:  974:        _status == Fw::FW_SERIALIZE_OK,
        -:  975:        static_cast<AssertArg>(_status)
        3:  976:    );
        -:  977:
        3:  978:    _status = msg.serialize(opCode);
        -:  979:    FW_ASSERT (
        -:  980:        _status == Fw::FW_SERIALIZE_OK,
        -:  981:        static_cast<AssertArg>(_status)
        3:  982:    );
        -:  983:
        3:  984:    _status = msg.serialize(cmdSeq);
        -:  985:    FW_ASSERT (
        -:  986:        _status == Fw::FW_SERIALIZE_OK,
        -:  987:        static_cast<AssertArg>(_status)
        3:  988:    );
        -:  989:
        3:  990:    _status = msg.serialize(args);
        -:  991:    FW_ASSERT (
        -:  992:        _status == Fw::FW_SERIALIZE_OK,
        -:  993:        static_cast<AssertArg>(_status)
        3:  994:    );
        -:  995:
        3:  996:    Os::Queue::QueueStatus qStatus = this->m_queue.send(msg,0);
        -:  997:
        -:  998:    FW_ASSERT(
        -:  999:        qStatus == Os::Queue::QUEUE_OK,
        -: 1000:        static_cast<AssertArg>(qStatus)
        3: 1001:    );
        -: 1002:
        3: 1003:  }
        -: 1004:
        3: 1005:  void CommandDispatcherComponentBase::
        -: 1006:    CMD_NO_OP_preMsgHook(
        -: 1007:        FwOpcodeType opCode,
        -: 1008:        U32 cmdSeq
        -: 1009:    )
        -: 1010:  {
        -: 1011:    // Defaults to no-op; can be overridden
        3: 1012:  }
        -: 1013:
        3: 1014:  void CommandDispatcherComponentBase ::
        -: 1015:    CMD_NO_OP_STRING_cmdHandlerBase(
        -: 1016:        FwOpcodeType opCode,
        -: 1017:        U32 cmdSeq,
        -: 1018:        Fw::CmdArgBuffer &args
        -: 1019:    )
        -: 1020:  {
        -: 1021:
        -: 1022:    // Call pre-message hook
        3: 1023:    this->CMD_NO_OP_STRING_preMsgHook(opCode,cmdSeq);
        -: 1024:
        -: 1025:    // Defer deserializing arguments to the message dispatcher
        -: 1026:    // to avoid deserializing and reserializing just for IPC
        3: 1027:    ComponentIpcSerializableBuffer msg;
        -: 1028:    Fw::SerializeStatus _status;
        -: 1029:
        -: 1030:    // Serialize for IPC
        3: 1031:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CMD_NO_OP_STRING);
        -: 1032:    FW_ASSERT (
        -: 1033:        _status == Fw::FW_SERIALIZE_OK,
        -: 1034:        static_cast<AssertArg>(_status)
        3: 1035:        );
        -: 1036:
        -: 1037:    // Fake port number to make message dequeue work
        3: 1038:    NATIVE_INT_TYPE port = 0;
        3: 1039:    _status = msg.serialize(port);
        -: 1040:    FW_ASSERT (
        -: 1041:        _status == Fw::FW_SERIALIZE_OK,
        -: 1042:        static_cast<AssertArg>(_status)
        3: 1043:    );
        -: 1044:
        3: 1045:    _status = msg.serialize(opCode);
        -: 1046:    FW_ASSERT (
        -: 1047:        _status == Fw::FW_SERIALIZE_OK,
        -: 1048:        static_cast<AssertArg>(_status)
        3: 1049:    );
        -: 1050:
        3: 1051:    _status = msg.serialize(cmdSeq);
        -: 1052:    FW_ASSERT (
        -: 1053:        _status == Fw::FW_SERIALIZE_OK,
        -: 1054:        static_cast<AssertArg>(_status)
        3: 1055:    );
        -: 1056:
        3: 1057:    _status = msg.serialize(args);
        -: 1058:    FW_ASSERT (
        -: 1059:        _status == Fw::FW_SERIALIZE_OK,
        -: 1060:        static_cast<AssertArg>(_status)
        3: 1061:    );
        -: 1062:
        3: 1063:    Os::Queue::QueueStatus qStatus = this->m_queue.send(msg,0);
        -: 1064:
        -: 1065:    FW_ASSERT(
        -: 1066:        qStatus == Os::Queue::QUEUE_OK,
        -: 1067:        static_cast<AssertArg>(qStatus)
        3: 1068:    );
        -: 1069:
        3: 1070:  }
        -: 1071:
        3: 1072:  void CommandDispatcherComponentBase::
        -: 1073:    CMD_NO_OP_STRING_preMsgHook(
        -: 1074:        FwOpcodeType opCode,
        -: 1075:        U32 cmdSeq
        -: 1076:    )
        -: 1077:  {
        -: 1078:    // Defaults to no-op; can be overridden
        3: 1079:  }
        -: 1080:
        3: 1081:  void CommandDispatcherComponentBase ::
        -: 1082:    CMD_TEST_CMD_1_cmdHandlerBase(
        -: 1083:        FwOpcodeType opCode,
        -: 1084:        U32 cmdSeq,
        -: 1085:        Fw::CmdArgBuffer &args
        -: 1086:    )
        -: 1087:  {
        -: 1088:
        -: 1089:    // Call pre-message hook
        3: 1090:    this->CMD_TEST_CMD_1_preMsgHook(opCode,cmdSeq);
        -: 1091:
        -: 1092:    // Defer deserializing arguments to the message dispatcher
        -: 1093:    // to avoid deserializing and reserializing just for IPC
        3: 1094:    ComponentIpcSerializableBuffer msg;
        -: 1095:    Fw::SerializeStatus _status;
        -: 1096:
        -: 1097:    // Serialize for IPC
        3: 1098:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CMD_TEST_CMD_1);
        -: 1099:    FW_ASSERT (
        -: 1100:        _status == Fw::FW_SERIALIZE_OK,
        -: 1101:        static_cast<AssertArg>(_status)
        3: 1102:        );
        -: 1103:
        -: 1104:    // Fake port number to make message dequeue work
        3: 1105:    NATIVE_INT_TYPE port = 0;
        3: 1106:    _status = msg.serialize(port);
        -: 1107:    FW_ASSERT (
        -: 1108:        _status == Fw::FW_SERIALIZE_OK,
        -: 1109:        static_cast<AssertArg>(_status)
        3: 1110:    );
        -: 1111:
        3: 1112:    _status = msg.serialize(opCode);
        -: 1113:    FW_ASSERT (
        -: 1114:        _status == Fw::FW_SERIALIZE_OK,
        -: 1115:        static_cast<AssertArg>(_status)
        3: 1116:    );
        -: 1117:
        3: 1118:    _status = msg.serialize(cmdSeq);
        -: 1119:    FW_ASSERT (
        -: 1120:        _status == Fw::FW_SERIALIZE_OK,
        -: 1121:        static_cast<AssertArg>(_status)
        3: 1122:    );
        -: 1123:
        3: 1124:    _status = msg.serialize(args);
        -: 1125:    FW_ASSERT (
        -: 1126:        _status == Fw::FW_SERIALIZE_OK,
        -: 1127:        static_cast<AssertArg>(_status)
        3: 1128:    );
        -: 1129:
        3: 1130:    Os::Queue::QueueStatus qStatus = this->m_queue.send(msg,0);
        -: 1131:
        -: 1132:    FW_ASSERT(
        -: 1133:        qStatus == Os::Queue::QUEUE_OK,
        -: 1134:        static_cast<AssertArg>(qStatus)
        3: 1135:    );
        -: 1136:
        3: 1137:  }
        -: 1138:
        3: 1139:  void CommandDispatcherComponentBase::
        -: 1140:    CMD_TEST_CMD_1_preMsgHook(
        -: 1141:        FwOpcodeType opCode,
        -: 1142:        U32 cmdSeq
        -: 1143:    )
        -: 1144:  {
        -: 1145:    // Defaults to no-op; can be overridden
        3: 1146:  }
        -: 1147:
        3: 1148:  void CommandDispatcherComponentBase ::
        -: 1149:    CMD_CLEAR_TRACKING_cmdHandlerBase(
        -: 1150:        FwOpcodeType opCode,
        -: 1151:        U32 cmdSeq,
        -: 1152:        Fw::CmdArgBuffer &args
        -: 1153:    )
        -: 1154:  {
        -: 1155:
        -: 1156:    // Call pre-message hook
        3: 1157:    this->CMD_CLEAR_TRACKING_preMsgHook(opCode,cmdSeq);
        -: 1158:
        -: 1159:    // Defer deserializing arguments to the message dispatcher
        -: 1160:    // to avoid deserializing and reserializing just for IPC
        3: 1161:    ComponentIpcSerializableBuffer msg;
        -: 1162:    Fw::SerializeStatus _status;
        -: 1163:
        -: 1164:    // Serialize for IPC
        3: 1165:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CMD_CLEAR_TRACKING);
        -: 1166:    FW_ASSERT (
        -: 1167:        _status == Fw::FW_SERIALIZE_OK,
        -: 1168:        static_cast<AssertArg>(_status)
        3: 1169:        );
        -: 1170:
        -: 1171:    // Fake port number to make message dequeue work
        3: 1172:    NATIVE_INT_TYPE port = 0;
        3: 1173:    _status = msg.serialize(port);
        -: 1174:    FW_ASSERT (
        -: 1175:        _status == Fw::FW_SERIALIZE_OK,
        -: 1176:        static_cast<AssertArg>(_status)
        3: 1177:    );
        -: 1178:
        3: 1179:    _status = msg.serialize(opCode);
        -: 1180:    FW_ASSERT (
        -: 1181:        _status == Fw::FW_SERIALIZE_OK,
        -: 1182:        static_cast<AssertArg>(_status)
        3: 1183:    );
        -: 1184:
        3: 1185:    _status = msg.serialize(cmdSeq);
        -: 1186:    FW_ASSERT (
        -: 1187:        _status == Fw::FW_SERIALIZE_OK,
        -: 1188:        static_cast<AssertArg>(_status)
        3: 1189:    );
        -: 1190:
        3: 1191:    _status = msg.serialize(args);
        -: 1192:    FW_ASSERT (
        -: 1193:        _status == Fw::FW_SERIALIZE_OK,
        -: 1194:        static_cast<AssertArg>(_status)
        3: 1195:    );
        -: 1196:
        3: 1197:    Os::Queue::QueueStatus qStatus = this->m_queue.send(msg,0);
        -: 1198:
        -: 1199:    FW_ASSERT(
        -: 1200:        qStatus == Os::Queue::QUEUE_OK,
        -: 1201:        static_cast<AssertArg>(qStatus)
        3: 1202:    );
        -: 1203:
        3: 1204:  }
        -: 1205:
        3: 1206:  void CommandDispatcherComponentBase::
        -: 1207:    CMD_CLEAR_TRACKING_preMsgHook(
        -: 1208:        FwOpcodeType opCode,
        -: 1209:        U32 cmdSeq
        -: 1210:    )
        -: 1211:  {
        -: 1212:    // Defaults to no-op; can be overridden
        3: 1213:  }
        -: 1214:
        -: 1215:  // ----------------------------------------------------------------------
        -: 1216:  // Telemetry write functions
        -: 1217:  // ----------------------------------------------------------------------
        -: 1218:
       98: 1219:  void CommandDispatcherComponentBase ::
        -: 1220:    tlmWrite_CommandsDispatched(U32& arg)
        -: 1221:  {
        -: 1222:
        -: 1223:    // Check to see if it is the first time
       98: 1224:    if (not this->m_first_update_CommandsDispatched) {
        -: 1225:      // Check to see if value has changed. If not, don't write it.
       83: 1226:      if (arg == this->m_last_CommandsDispatched) {
       98: 1227:        return;
        -: 1228:      } else {
       83: 1229:        this->m_last_CommandsDispatched = arg;
        -: 1230:      }
        -: 1231:    }
        -: 1232:    else {
       15: 1233:      this->m_first_update_CommandsDispatched = false;
       15: 1234:      this->m_last_CommandsDispatched = arg;
        -: 1235:    }
        -: 1236:
       98: 1237:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       98: 1238:      Fw::Time _timeTag = this->getTime();
      196: 1239:      Fw::TlmBuffer _tlmBuff;
       98: 1240:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1241:      FW_ASSERT(
        -: 1242:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1243:          static_cast<AssertArg>(_stat)
       98: 1244:      );
        -: 1245:      
        -: 1246:      FwChanIdType _id;
        -: 1247:      
       98: 1248:      _id = CHANNELID_COMMANDSDISPATCHED;
        -: 1249:      
        -: 1250:      this->m_Tlm_OutputPort[0].invoke(
        -: 1251:          _id,
        -: 1252:          _timeTag,
        -: 1253:          _tlmBuff
      196: 1254:      );
        -: 1255:    }
        -: 1256:
        -: 1257:  }
        -: 1258:
        8: 1259:  void CommandDispatcherComponentBase ::
        -: 1260:    tlmWrite_CommandErrors(U32& arg)
        -: 1261:  {
        -: 1262:
        -: 1263:    // Check to see if it is the first time
        8: 1264:    if (not this->m_first_update_CommandErrors) {
        -: 1265:      // Check to see if value has changed. If not, don't write it.
        2: 1266:      if (arg == this->m_last_CommandErrors) {
        8: 1267:        return;
        -: 1268:      } else {
        2: 1269:        this->m_last_CommandErrors = arg;
        -: 1270:      }
        -: 1271:    }
        -: 1272:    else {
        6: 1273:      this->m_first_update_CommandErrors = false;
        6: 1274:      this->m_last_CommandErrors = arg;
        -: 1275:    }
        -: 1276:
        8: 1277:    if (this->m_Tlm_OutputPort[0].isConnected()) {
        8: 1278:      Fw::Time _timeTag = this->getTime();
       16: 1279:      Fw::TlmBuffer _tlmBuff;
        8: 1280:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1281:      FW_ASSERT(
        -: 1282:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1283:          static_cast<AssertArg>(_stat)
        8: 1284:      );
        -: 1285:      
        -: 1286:      FwChanIdType _id;
        -: 1287:      
        8: 1288:      _id = CHANNELID_COMMANDERRORS;
        -: 1289:      
        -: 1290:      this->m_Tlm_OutputPort[0].invoke(
        -: 1291:          _id,
        -: 1292:          _timeTag,
        -: 1293:          _tlmBuff
       16: 1294:      );
        -: 1295:    }
        -: 1296:
        -: 1297:  }
        -: 1298:
        -: 1299:  // ----------------------------------------------------------------------
        -: 1300:  // Time
        -: 1301:  // ----------------------------------------------------------------------
        -: 1302:
      106: 1303:  Fw::Time CommandDispatcherComponentBase ::
        -: 1304:    getTime(void) 
        -: 1305:  {
      106: 1306:    if (this->m_Time_OutputPort[0].isConnected()) {
      106: 1307:      return this->m_Time_OutputPort[0].invoke();
        -: 1308:    } else {
    #####: 1309:      return Fw::Time(TB_NONE,0,0);
        -: 1310:    }
        -: 1311:  }
        -: 1312:
        -: 1313:  // ----------------------------------------------------------------------
        -: 1314:  // Event handling functions
        -: 1315:  // ----------------------------------------------------------------------
        -: 1316:
       87: 1317:  void CommandDispatcherComponentBase ::
        -: 1318:    log_DIAGNOSTIC_OpCodeRegistered(
        -: 1319:        U32 Opcode, I32 port, I32 slot
        -: 1320:    )
        -: 1321:  {
        -: 1322:
        -: 1323:    // Get the time
       87: 1324:    Fw::Time _logTime;
       87: 1325:    if (this->m_Time_OutputPort[0].isConnected()) {
       87: 1326:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1327:    }
        -: 1328:    
       87: 1329:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1330:    
       87: 1331:    _id = EVENTID_OPCODEREGISTERED;
        -: 1332:
        -: 1333:    // Emit the event on the log port
       87: 1334:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1335:
       87: 1336:      Fw::LogBuffer _logBuff;
        -: 1337:      Fw::SerializeStatus _status;
        -: 1338:
        -: 1339:#if FW_AMPCS_COMPATIBLE
        -: 1340:      // Serialize the number of arguments
        -: 1341:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 1342:      FW_ASSERT(
        -: 1343:          _status == Fw::FW_SERIALIZE_OK,
        -: 1344:          static_cast<AssertArg>(_status)
        -: 1345:      );
        -: 1346:#endif
        -: 1347:
        -: 1348:#if FW_AMPCS_COMPATIBLE
        -: 1349:      // Serialize the argument size
        -: 1350:      _status = _logBuff.serialize(
        -: 1351:          static_cast<U8>(sizeof(Opcode))
        -: 1352:      );
        -: 1353:      FW_ASSERT(
        -: 1354:          _status == Fw::FW_SERIALIZE_OK,
        -: 1355:          static_cast<AssertArg>(_status)
        -: 1356:      );
        -: 1357:#endif
        -: 1358:
       87: 1359:      _status = _logBuff.serialize(Opcode);
        -: 1360:      FW_ASSERT(
        -: 1361:          _status == Fw::FW_SERIALIZE_OK,
        -: 1362:          static_cast<AssertArg>(_status)
       87: 1363:      );
        -: 1364:
        -: 1365:#if FW_AMPCS_COMPATIBLE
        -: 1366:      // Serialize the argument size
        -: 1367:      _status = _logBuff.serialize(
        -: 1368:          static_cast<U8>(sizeof(port))
        -: 1369:      );
        -: 1370:      FW_ASSERT(
        -: 1371:          _status == Fw::FW_SERIALIZE_OK,
        -: 1372:          static_cast<AssertArg>(_status)
        -: 1373:      );
        -: 1374:#endif
        -: 1375:
       87: 1376:      _status = _logBuff.serialize(port);
        -: 1377:      FW_ASSERT(
        -: 1378:          _status == Fw::FW_SERIALIZE_OK,
        -: 1379:          static_cast<AssertArg>(_status)
       87: 1380:      );
        -: 1381:
        -: 1382:#if FW_AMPCS_COMPATIBLE
        -: 1383:      // Serialize the argument size
        -: 1384:      _status = _logBuff.serialize(
        -: 1385:          static_cast<U8>(sizeof(slot))
        -: 1386:      );
        -: 1387:      FW_ASSERT(
        -: 1388:          _status == Fw::FW_SERIALIZE_OK,
        -: 1389:          static_cast<AssertArg>(_status)
        -: 1390:      );
        -: 1391:#endif
        -: 1392:
       87: 1393:      _status = _logBuff.serialize(slot);
        -: 1394:      FW_ASSERT(
        -: 1395:          _status == Fw::FW_SERIALIZE_OK,
        -: 1396:          static_cast<AssertArg>(_status)
       87: 1397:      );
        -: 1398:
        -: 1399:
        -: 1400:      this->m_Log_OutputPort[0].invoke(
        -: 1401:          _id,
        -: 1402:          _logTime,Fw::LOG_DIAGNOSTIC,
        -: 1403:          _logBuff
       87: 1404:      );
        -: 1405:
        -: 1406:    }
        -: 1407:
        -: 1408:    // Emit the event on the text log port
        -: 1409:#if FW_ENABLE_TEXT_LOGGING
       87: 1410:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1411:
        -: 1412:#if FW_OBJECT_NAMES == 1
        -: 1413:      const char* _formatString =
       87: 1414:        "(%s) %s: Opcode 0x%04X registered to port %d slot %d";
        -: 1415:#else
        -: 1416:      const char* _formatString =
        -: 1417:        "%s: Opcode 0x%04X registered to port %d slot %d";
        -: 1418:#endif
        -: 1419:
        -: 1420:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1421:
        -: 1422:      (void) snprintf(
        -: 1423:          _textBuffer,
        -: 1424:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1425:          _formatString,
        -: 1426:#if FW_OBJECT_NAMES == 1
        -: 1427:          this->m_objName,
        -: 1428:#endif
        -: 1429:          "OpCodeRegistered "
        -: 1430:        , Opcode
        -: 1431:        , port
        -: 1432:        , slot
       87: 1433:      );
        -: 1434:
        -: 1435:      // Null terminate
       87: 1436:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       87: 1437:      Fw::TextLogString _logString = _textBuffer;
        -: 1438:      this->m_LogText_OutputPort[0].invoke(
        -: 1439:          _id,
        -: 1440:          _logTime,Fw::TEXT_LOG_DIAGNOSTIC,
        -: 1441:          _logString
       87: 1442:      );
        -: 1443:
       87: 1444:    }
        -: 1445:#endif
        -: 1446:
       87: 1447:  }
        -: 1448:
       98: 1449:  void CommandDispatcherComponentBase ::
        -: 1450:    log_COMMAND_OpCodeDispatched(
        -: 1451:        U32 Opcode, I32 port
        -: 1452:    )
        -: 1453:  {
        -: 1454:
        -: 1455:    // Get the time
       98: 1456:    Fw::Time _logTime;
       98: 1457:    if (this->m_Time_OutputPort[0].isConnected()) {
       98: 1458:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1459:    }
        -: 1460:    
       98: 1461:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1462:    
       98: 1463:    _id = EVENTID_OPCODEDISPATCHED;
        -: 1464:
        -: 1465:    // Emit the event on the log port
       98: 1466:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1467:
       98: 1468:      Fw::LogBuffer _logBuff;
        -: 1469:      Fw::SerializeStatus _status;
        -: 1470:
        -: 1471:#if FW_AMPCS_COMPATIBLE
        -: 1472:      // Serialize the number of arguments
        -: 1473:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1474:      FW_ASSERT(
        -: 1475:          _status == Fw::FW_SERIALIZE_OK,
        -: 1476:          static_cast<AssertArg>(_status)
        -: 1477:      );
        -: 1478:#endif
        -: 1479:
        -: 1480:#if FW_AMPCS_COMPATIBLE
        -: 1481:      // Serialize the argument size
        -: 1482:      _status = _logBuff.serialize(
        -: 1483:          static_cast<U8>(sizeof(Opcode))
        -: 1484:      );
        -: 1485:      FW_ASSERT(
        -: 1486:          _status == Fw::FW_SERIALIZE_OK,
        -: 1487:          static_cast<AssertArg>(_status)
        -: 1488:      );
        -: 1489:#endif
        -: 1490:
       98: 1491:      _status = _logBuff.serialize(Opcode);
        -: 1492:      FW_ASSERT(
        -: 1493:          _status == Fw::FW_SERIALIZE_OK,
        -: 1494:          static_cast<AssertArg>(_status)
       98: 1495:      );
        -: 1496:
        -: 1497:#if FW_AMPCS_COMPATIBLE
        -: 1498:      // Serialize the argument size
        -: 1499:      _status = _logBuff.serialize(
        -: 1500:          static_cast<U8>(sizeof(port))
        -: 1501:      );
        -: 1502:      FW_ASSERT(
        -: 1503:          _status == Fw::FW_SERIALIZE_OK,
        -: 1504:          static_cast<AssertArg>(_status)
        -: 1505:      );
        -: 1506:#endif
        -: 1507:
       98: 1508:      _status = _logBuff.serialize(port);
        -: 1509:      FW_ASSERT(
        -: 1510:          _status == Fw::FW_SERIALIZE_OK,
        -: 1511:          static_cast<AssertArg>(_status)
       98: 1512:      );
        -: 1513:
        -: 1514:
        -: 1515:      this->m_Log_OutputPort[0].invoke(
        -: 1516:          _id,
        -: 1517:          _logTime,Fw::LOG_COMMAND,
        -: 1518:          _logBuff
       98: 1519:      );
        -: 1520:
        -: 1521:    }
        -: 1522:
        -: 1523:    // Emit the event on the text log port
        -: 1524:#if FW_ENABLE_TEXT_LOGGING
       98: 1525:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1526:
        -: 1527:#if FW_OBJECT_NAMES == 1
        -: 1528:      const char* _formatString =
       98: 1529:        "(%s) %s: Opcode 0x%04X dispatched to port %d";
        -: 1530:#else
        -: 1531:      const char* _formatString =
        -: 1532:        "%s: Opcode 0x%04X dispatched to port %d";
        -: 1533:#endif
        -: 1534:
        -: 1535:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1536:
        -: 1537:      (void) snprintf(
        -: 1538:          _textBuffer,
        -: 1539:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1540:          _formatString,
        -: 1541:#if FW_OBJECT_NAMES == 1
        -: 1542:          this->m_objName,
        -: 1543:#endif
        -: 1544:          "OpCodeDispatched "
        -: 1545:        , Opcode
        -: 1546:        , port
       98: 1547:      );
        -: 1548:
        -: 1549:      // Null terminate
       98: 1550:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       98: 1551:      Fw::TextLogString _logString = _textBuffer;
        -: 1552:      this->m_LogText_OutputPort[0].invoke(
        -: 1553:          _id,
        -: 1554:          _logTime,Fw::TEXT_LOG_COMMAND,
        -: 1555:          _logString
       98: 1556:      );
        -: 1557:
       98: 1558:    }
        -: 1559:#endif
        -: 1560:
       98: 1561:  }
        -: 1562:
       15: 1563:  void CommandDispatcherComponentBase ::
        -: 1564:    log_COMMAND_OpCodeCompleted(
        -: 1565:        U32 Opcode
        -: 1566:    )
        -: 1567:  {
        -: 1568:
        -: 1569:    // Get the time
       15: 1570:    Fw::Time _logTime;
       15: 1571:    if (this->m_Time_OutputPort[0].isConnected()) {
       15: 1572:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1573:    }
        -: 1574:    
       15: 1575:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1576:    
       15: 1577:    _id = EVENTID_OPCODECOMPLETED;
        -: 1578:
        -: 1579:    // Emit the event on the log port
       15: 1580:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1581:
       15: 1582:      Fw::LogBuffer _logBuff;
        -: 1583:      Fw::SerializeStatus _status;
        -: 1584:
        -: 1585:#if FW_AMPCS_COMPATIBLE
        -: 1586:      // Serialize the number of arguments
        -: 1587:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1588:      FW_ASSERT(
        -: 1589:          _status == Fw::FW_SERIALIZE_OK,
        -: 1590:          static_cast<AssertArg>(_status)
        -: 1591:      );
        -: 1592:#endif
        -: 1593:
        -: 1594:#if FW_AMPCS_COMPATIBLE
        -: 1595:      // Serialize the argument size
        -: 1596:      _status = _logBuff.serialize(
        -: 1597:          static_cast<U8>(sizeof(Opcode))
        -: 1598:      );
        -: 1599:      FW_ASSERT(
        -: 1600:          _status == Fw::FW_SERIALIZE_OK,
        -: 1601:          static_cast<AssertArg>(_status)
        -: 1602:      );
        -: 1603:#endif
        -: 1604:
       15: 1605:      _status = _logBuff.serialize(Opcode);
        -: 1606:      FW_ASSERT(
        -: 1607:          _status == Fw::FW_SERIALIZE_OK,
        -: 1608:          static_cast<AssertArg>(_status)
       15: 1609:      );
        -: 1610:
        -: 1611:
        -: 1612:      this->m_Log_OutputPort[0].invoke(
        -: 1613:          _id,
        -: 1614:          _logTime,Fw::LOG_COMMAND,
        -: 1615:          _logBuff
       15: 1616:      );
        -: 1617:
        -: 1618:    }
        -: 1619:
        -: 1620:    // Emit the event on the text log port
        -: 1621:#if FW_ENABLE_TEXT_LOGGING
       15: 1622:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1623:
        -: 1624:#if FW_OBJECT_NAMES == 1
        -: 1625:      const char* _formatString =
       15: 1626:        "(%s) %s: Opcode 0x%04X completed";
        -: 1627:#else
        -: 1628:      const char* _formatString =
        -: 1629:        "%s: Opcode 0x%04X completed";
        -: 1630:#endif
        -: 1631:
        -: 1632:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1633:
        -: 1634:      (void) snprintf(
        -: 1635:          _textBuffer,
        -: 1636:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1637:          _formatString,
        -: 1638:#if FW_OBJECT_NAMES == 1
        -: 1639:          this->m_objName,
        -: 1640:#endif
        -: 1641:          "OpCodeCompleted "
        -: 1642:        , Opcode
       15: 1643:      );
        -: 1644:
        -: 1645:      // Null terminate
       15: 1646:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       15: 1647:      Fw::TextLogString _logString = _textBuffer;
        -: 1648:      this->m_LogText_OutputPort[0].invoke(
        -: 1649:          _id,
        -: 1650:          _logTime,Fw::TEXT_LOG_COMMAND,
        -: 1651:          _logString
       15: 1652:      );
        -: 1653:
       15: 1654:    }
        -: 1655:#endif
        -: 1656:
       15: 1657:  }
        -: 1658:
        5: 1659:  void CommandDispatcherComponentBase ::
        -: 1660:    log_WARNING_HI_OpCodeError(
        -: 1661:        U32 Opcode, I32 error
        -: 1662:    )
        -: 1663:  {
        -: 1664:
        -: 1665:    // Get the time
        5: 1666:    Fw::Time _logTime;
        5: 1667:    if (this->m_Time_OutputPort[0].isConnected()) {
        5: 1668:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1669:    }
        -: 1670:    
        5: 1671:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1672:    
        5: 1673:    _id = EVENTID_OPCODEERROR;
        -: 1674:
        -: 1675:    // Emit the event on the log port
        5: 1676:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1677:
        5: 1678:      Fw::LogBuffer _logBuff;
        -: 1679:      Fw::SerializeStatus _status;
        -: 1680:
        -: 1681:#if FW_AMPCS_COMPATIBLE
        -: 1682:      // Serialize the number of arguments
        -: 1683:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1684:      FW_ASSERT(
        -: 1685:          _status == Fw::FW_SERIALIZE_OK,
        -: 1686:          static_cast<AssertArg>(_status)
        -: 1687:      );
        -: 1688:#endif
        -: 1689:
        -: 1690:#if FW_AMPCS_COMPATIBLE
        -: 1691:      // Serialize the argument size
        -: 1692:      _status = _logBuff.serialize(
        -: 1693:          static_cast<U8>(sizeof(Opcode))
        -: 1694:      );
        -: 1695:      FW_ASSERT(
        -: 1696:          _status == Fw::FW_SERIALIZE_OK,
        -: 1697:          static_cast<AssertArg>(_status)
        -: 1698:      );
        -: 1699:#endif
        -: 1700:
        5: 1701:      _status = _logBuff.serialize(Opcode);
        -: 1702:      FW_ASSERT(
        -: 1703:          _status == Fw::FW_SERIALIZE_OK,
        -: 1704:          static_cast<AssertArg>(_status)
        5: 1705:      );
        -: 1706:
        -: 1707:#if FW_AMPCS_COMPATIBLE
        -: 1708:      // Serialize the argument size
        -: 1709:      _status = _logBuff.serialize(
        -: 1710:          static_cast<U8>(sizeof(error))
        -: 1711:      );
        -: 1712:      FW_ASSERT(
        -: 1713:          _status == Fw::FW_SERIALIZE_OK,
        -: 1714:          static_cast<AssertArg>(_status)
        -: 1715:      );
        -: 1716:#endif
        -: 1717:
        5: 1718:      _status = _logBuff.serialize(error);
        -: 1719:      FW_ASSERT(
        -: 1720:          _status == Fw::FW_SERIALIZE_OK,
        -: 1721:          static_cast<AssertArg>(_status)
        5: 1722:      );
        -: 1723:
        -: 1724:
        -: 1725:      this->m_Log_OutputPort[0].invoke(
        -: 1726:          _id,
        -: 1727:          _logTime,Fw::LOG_WARNING_HI,
        -: 1728:          _logBuff
        5: 1729:      );
        -: 1730:
        -: 1731:    }
        -: 1732:
        -: 1733:    // Emit the event on the text log port
        -: 1734:#if FW_ENABLE_TEXT_LOGGING
        5: 1735:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1736:
        -: 1737:#if FW_OBJECT_NAMES == 1
        -: 1738:      const char* _formatString =
        5: 1739:        "(%s) %s: Opcode 0x%04X completed with error %d ";
        -: 1740:#else
        -: 1741:      const char* _formatString =
        -: 1742:        "%s: Opcode 0x%04X completed with error %d ";
        -: 1743:#endif
        -: 1744:
        -: 1745:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1746:
        -: 1747:      (void) snprintf(
        -: 1748:          _textBuffer,
        -: 1749:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1750:          _formatString,
        -: 1751:#if FW_OBJECT_NAMES == 1
        -: 1752:          this->m_objName,
        -: 1753:#endif
        -: 1754:          "OpCodeError "
        -: 1755:        , Opcode
        -: 1756:        , error
        5: 1757:      );
        -: 1758:
        -: 1759:      // Null terminate
        5: 1760:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        5: 1761:      Fw::TextLogString _logString = _textBuffer;
        -: 1762:      this->m_LogText_OutputPort[0].invoke(
        -: 1763:          _id,
        -: 1764:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1765:          _logString
        5: 1766:      );
        -: 1767:
        5: 1768:    }
        -: 1769:#endif
        -: 1770:
        5: 1771:  }
        -: 1772:
        3: 1773:  void CommandDispatcherComponentBase ::
        -: 1774:    log_WARNING_HI_MalformedCommand(
        -: 1775:        U32 Status
        -: 1776:    )
        -: 1777:  {
        -: 1778:
        -: 1779:    // Get the time
        3: 1780:    Fw::Time _logTime;
        3: 1781:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1782:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1783:    }
        -: 1784:    
        3: 1785:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1786:    
        3: 1787:    _id = EVENTID_MALFORMEDCOMMAND;
        -: 1788:
        -: 1789:    // Emit the event on the log port
        3: 1790:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1791:
        3: 1792:      Fw::LogBuffer _logBuff;
        -: 1793:      Fw::SerializeStatus _status;
        -: 1794:
        -: 1795:#if FW_AMPCS_COMPATIBLE
        -: 1796:      // Serialize the number of arguments
        -: 1797:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1798:      FW_ASSERT(
        -: 1799:          _status == Fw::FW_SERIALIZE_OK,
        -: 1800:          static_cast<AssertArg>(_status)
        -: 1801:      );
        -: 1802:#endif
        -: 1803:
        -: 1804:#if FW_AMPCS_COMPATIBLE
        -: 1805:      // Serialize the argument size
        -: 1806:      _status = _logBuff.serialize(
        -: 1807:          static_cast<U8>(sizeof(Status))
        -: 1808:      );
        -: 1809:      FW_ASSERT(
        -: 1810:          _status == Fw::FW_SERIALIZE_OK,
        -: 1811:          static_cast<AssertArg>(_status)
        -: 1812:      );
        -: 1813:#endif
        -: 1814:
        3: 1815:      _status = _logBuff.serialize(Status);
        -: 1816:      FW_ASSERT(
        -: 1817:          _status == Fw::FW_SERIALIZE_OK,
        -: 1818:          static_cast<AssertArg>(_status)
        3: 1819:      );
        -: 1820:
        -: 1821:
        -: 1822:      this->m_Log_OutputPort[0].invoke(
        -: 1823:          _id,
        -: 1824:          _logTime,Fw::LOG_WARNING_HI,
        -: 1825:          _logBuff
        3: 1826:      );
        -: 1827:
        -: 1828:    }
        -: 1829:
        -: 1830:    // Emit the event on the text log port
        -: 1831:#if FW_ENABLE_TEXT_LOGGING
        3: 1832:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1833:
        -: 1834:#if FW_OBJECT_NAMES == 1
        -: 1835:      const char* _formatString =
        3: 1836:        "(%s) %s: Received malformed command packet. Status: %d";
        -: 1837:#else
        -: 1838:      const char* _formatString =
        -: 1839:        "%s: Received malformed command packet. Status: %d";
        -: 1840:#endif
        -: 1841:
        -: 1842:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1843:
        -: 1844:      (void) snprintf(
        -: 1845:          _textBuffer,
        -: 1846:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1847:          _formatString,
        -: 1848:#if FW_OBJECT_NAMES == 1
        -: 1849:          this->m_objName,
        -: 1850:#endif
        -: 1851:          "MalformedCommand "
        -: 1852:        , Status
        3: 1853:      );
        -: 1854:
        -: 1855:      // Null terminate
        3: 1856:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        3: 1857:      Fw::TextLogString _logString = _textBuffer;
        -: 1858:      this->m_LogText_OutputPort[0].invoke(
        -: 1859:          _id,
        -: 1860:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1861:          _logString
        3: 1862:      );
        -: 1863:
        3: 1864:    }
        -: 1865:#endif
        -: 1866:
        3: 1867:  }
        -: 1868:
        3: 1869:  void CommandDispatcherComponentBase ::
        -: 1870:    log_WARNING_HI_InvalidCommand(
        -: 1871:        U32 Opcode
        -: 1872:    )
        -: 1873:  {
        -: 1874:
        -: 1875:    // Get the time
        3: 1876:    Fw::Time _logTime;
        3: 1877:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1878:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1879:    }
        -: 1880:    
        3: 1881:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1882:    
        3: 1883:    _id = EVENTID_INVALIDCOMMAND;
        -: 1884:
        -: 1885:    // Emit the event on the log port
        3: 1886:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1887:
        3: 1888:      Fw::LogBuffer _logBuff;
        -: 1889:      Fw::SerializeStatus _status;
        -: 1890:
        -: 1891:#if FW_AMPCS_COMPATIBLE
        -: 1892:      // Serialize the number of arguments
        -: 1893:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1894:      FW_ASSERT(
        -: 1895:          _status == Fw::FW_SERIALIZE_OK,
        -: 1896:          static_cast<AssertArg>(_status)
        -: 1897:      );
        -: 1898:#endif
        -: 1899:
        -: 1900:#if FW_AMPCS_COMPATIBLE
        -: 1901:      // Serialize the argument size
        -: 1902:      _status = _logBuff.serialize(
        -: 1903:          static_cast<U8>(sizeof(Opcode))
        -: 1904:      );
        -: 1905:      FW_ASSERT(
        -: 1906:          _status == Fw::FW_SERIALIZE_OK,
        -: 1907:          static_cast<AssertArg>(_status)
        -: 1908:      );
        -: 1909:#endif
        -: 1910:
        3: 1911:      _status = _logBuff.serialize(Opcode);
        -: 1912:      FW_ASSERT(
        -: 1913:          _status == Fw::FW_SERIALIZE_OK,
        -: 1914:          static_cast<AssertArg>(_status)
        3: 1915:      );
        -: 1916:
        -: 1917:
        -: 1918:      this->m_Log_OutputPort[0].invoke(
        -: 1919:          _id,
        -: 1920:          _logTime,Fw::LOG_WARNING_HI,
        -: 1921:          _logBuff
        3: 1922:      );
        -: 1923:
        -: 1924:    }
        -: 1925:
        -: 1926:    // Emit the event on the text log port
        -: 1927:#if FW_ENABLE_TEXT_LOGGING
        3: 1928:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1929:
        -: 1930:#if FW_OBJECT_NAMES == 1
        -: 1931:      const char* _formatString =
        3: 1932:        "(%s) %s: Invalid opcode 0x%04X received.";
        -: 1933:#else
        -: 1934:      const char* _formatString =
        -: 1935:        "%s: Invalid opcode 0x%04X received.";
        -: 1936:#endif
        -: 1937:
        -: 1938:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1939:
        -: 1940:      (void) snprintf(
        -: 1941:          _textBuffer,
        -: 1942:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1943:          _formatString,
        -: 1944:#if FW_OBJECT_NAMES == 1
        -: 1945:          this->m_objName,
        -: 1946:#endif
        -: 1947:          "InvalidCommand "
        -: 1948:        , Opcode
        3: 1949:      );
        -: 1950:
        -: 1951:      // Null terminate
        3: 1952:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        3: 1953:      Fw::TextLogString _logString = _textBuffer;
        -: 1954:      this->m_LogText_OutputPort[0].invoke(
        -: 1955:          _id,
        -: 1956:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1957:          _logString
        3: 1958:      );
        -: 1959:
        3: 1960:    }
        -: 1961:#endif
        -: 1962:
        3: 1963:  }
        -: 1964:
        3: 1965:  void CommandDispatcherComponentBase ::
        -: 1966:    log_WARNING_HI_TooManyCommands(
        -: 1967:        U32 Opcode
        -: 1968:    )
        -: 1969:  {
        -: 1970:
        -: 1971:    // Get the time
        3: 1972:    Fw::Time _logTime;
        3: 1973:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1974:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 1975:    }
        -: 1976:    
        3: 1977:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1978:    
        3: 1979:    _id = EVENTID_TOOMANYCOMMANDS;
        -: 1980:
        -: 1981:    // Emit the event on the log port
        3: 1982:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1983:
        3: 1984:      Fw::LogBuffer _logBuff;
        -: 1985:      Fw::SerializeStatus _status;
        -: 1986:
        -: 1987:#if FW_AMPCS_COMPATIBLE
        -: 1988:      // Serialize the number of arguments
        -: 1989:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1990:      FW_ASSERT(
        -: 1991:          _status == Fw::FW_SERIALIZE_OK,
        -: 1992:          static_cast<AssertArg>(_status)
        -: 1993:      );
        -: 1994:#endif
        -: 1995:
        -: 1996:#if FW_AMPCS_COMPATIBLE
        -: 1997:      // Serialize the argument size
        -: 1998:      _status = _logBuff.serialize(
        -: 1999:          static_cast<U8>(sizeof(Opcode))
        -: 2000:      );
        -: 2001:      FW_ASSERT(
        -: 2002:          _status == Fw::FW_SERIALIZE_OK,
        -: 2003:          static_cast<AssertArg>(_status)
        -: 2004:      );
        -: 2005:#endif
        -: 2006:
        3: 2007:      _status = _logBuff.serialize(Opcode);
        -: 2008:      FW_ASSERT(
        -: 2009:          _status == Fw::FW_SERIALIZE_OK,
        -: 2010:          static_cast<AssertArg>(_status)
        3: 2011:      );
        -: 2012:
        -: 2013:
        -: 2014:      this->m_Log_OutputPort[0].invoke(
        -: 2015:          _id,
        -: 2016:          _logTime,Fw::LOG_WARNING_HI,
        -: 2017:          _logBuff
        3: 2018:      );
        -: 2019:
        -: 2020:    }
        -: 2021:
        -: 2022:    // Emit the event on the text log port
        -: 2023:#if FW_ENABLE_TEXT_LOGGING
        3: 2024:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2025:
        -: 2026:#if FW_OBJECT_NAMES == 1
        -: 2027:      const char* _formatString =
        3: 2028:        "(%s) %s: Too many outstanding commands. opcode=0x%04X";
        -: 2029:#else
        -: 2030:      const char* _formatString =
        -: 2031:        "%s: Too many outstanding commands. opcode=0x%04X";
        -: 2032:#endif
        -: 2033:
        -: 2034:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2035:
        -: 2036:      (void) snprintf(
        -: 2037:          _textBuffer,
        -: 2038:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2039:          _formatString,
        -: 2040:#if FW_OBJECT_NAMES == 1
        -: 2041:          this->m_objName,
        -: 2042:#endif
        -: 2043:          "TooManyCommands "
        -: 2044:        , Opcode
        3: 2045:      );
        -: 2046:
        -: 2047:      // Null terminate
        3: 2048:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        3: 2049:      Fw::TextLogString _logString = _textBuffer;
        -: 2050:      this->m_LogText_OutputPort[0].invoke(
        -: 2051:          _id,
        -: 2052:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2053:          _logString
        3: 2054:      );
        -: 2055:
        3: 2056:    }
        -: 2057:#endif
        -: 2058:
        3: 2059:  }
        -: 2060:
        3: 2061:  void CommandDispatcherComponentBase ::
        -: 2062:    log_COMMAND_NoOpReceived(
        -: 2063:        void
        -: 2064:    )
        -: 2065:  {
        -: 2066:
        -: 2067:    // Get the time
        3: 2068:    Fw::Time _logTime;
        3: 2069:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 2070:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 2071:    }
        -: 2072:    
        3: 2073:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2074:    
        3: 2075:    _id = EVENTID_NOOPRECEIVED;
        -: 2076:
        -: 2077:    // Emit the event on the log port
        3: 2078:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 2079:
        3: 2080:      Fw::LogBuffer _logBuff;
        -: 2081:
        -: 2082:
        -: 2083:      this->m_Log_OutputPort[0].invoke(
        -: 2084:          _id,
        -: 2085:          _logTime,Fw::LOG_COMMAND,
        -: 2086:          _logBuff
        3: 2087:      );
        -: 2088:
        -: 2089:    }
        -: 2090:
        -: 2091:    // Emit the event on the text log port
        -: 2092:#if FW_ENABLE_TEXT_LOGGING
        3: 2093:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2094:
        -: 2095:#if FW_OBJECT_NAMES == 1
        -: 2096:      const char* _formatString =
        3: 2097:        "(%s) %s: ISF received a NO-OP command";
        -: 2098:#else
        -: 2099:      const char* _formatString =
        -: 2100:        "%s: ISF received a NO-OP command";
        -: 2101:#endif
        -: 2102:
        -: 2103:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2104:
        -: 2105:      (void) snprintf(
        -: 2106:          _textBuffer,
        -: 2107:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2108:          _formatString,
        -: 2109:#if FW_OBJECT_NAMES == 1
        -: 2110:          this->m_objName,
        -: 2111:#endif
        -: 2112:          "NoOpReceived "
        3: 2113:      );
        -: 2114:
        -: 2115:      // Null terminate
        3: 2116:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        3: 2117:      Fw::TextLogString _logString = _textBuffer;
        -: 2118:      this->m_LogText_OutputPort[0].invoke(
        -: 2119:          _id,
        -: 2120:          _logTime,Fw::TEXT_LOG_COMMAND,
        -: 2121:          _logString
        3: 2122:      );
        -: 2123:
        3: 2124:    }
        -: 2125:#endif
        -: 2126:
        3: 2127:  }
        -: 2128:
        3: 2129:  void CommandDispatcherComponentBase ::
        -: 2130:    log_COMMAND_NoOpStringReceived(
        -: 2131:        Fw::LogStringArg& No_op_string
        -: 2132:    )
        -: 2133:  {
        -: 2134:
        -: 2135:    // Get the time
        3: 2136:    Fw::Time _logTime;
        3: 2137:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 2138:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 2139:    }
        -: 2140:    
        3: 2141:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2142:    
        3: 2143:    _id = EVENTID_NOOPSTRINGRECEIVED;
        -: 2144:
        -: 2145:    // Emit the event on the log port
        3: 2146:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 2147:
        3: 2148:      Fw::LogBuffer _logBuff;
        -: 2149:      Fw::SerializeStatus _status;
        -: 2150:
        -: 2151:#if FW_AMPCS_COMPATIBLE
        -: 2152:      // Serialize the number of arguments
        -: 2153:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 2154:      FW_ASSERT(
        -: 2155:          _status == Fw::FW_SERIALIZE_OK,
        -: 2156:          static_cast<AssertArg>(_status)
        -: 2157:      );
        -: 2158:#endif
        -: 2159:
        3: 2160:      No_op_string.setMaxSerialize(40);
        3: 2161:      _status = _logBuff.serialize(No_op_string);
        -: 2162:      FW_ASSERT(
        -: 2163:          _status == Fw::FW_SERIALIZE_OK,
        -: 2164:          static_cast<AssertArg>(_status)
        3: 2165:      );
        -: 2166:
        -: 2167:
        -: 2168:      this->m_Log_OutputPort[0].invoke(
        -: 2169:          _id,
        -: 2170:          _logTime,Fw::LOG_COMMAND,
        -: 2171:          _logBuff
        3: 2172:      );
        -: 2173:
        -: 2174:    }
        -: 2175:
        -: 2176:    // Emit the event on the text log port
        -: 2177:#if FW_ENABLE_TEXT_LOGGING
        3: 2178:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2179:
        -: 2180:#if FW_OBJECT_NAMES == 1
        -: 2181:      const char* _formatString =
        3: 2182:        "(%s) %s: ISF generated a NO-OP string, No_op_string=%s";
        -: 2183:#else
        -: 2184:      const char* _formatString =
        -: 2185:        "%s: ISF generated a NO-OP string, No_op_string=%s";
        -: 2186:#endif
        -: 2187:
        -: 2188:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2189:
        -: 2190:      (void) snprintf(
        -: 2191:          _textBuffer,
        -: 2192:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2193:          _formatString,
        -: 2194:#if FW_OBJECT_NAMES == 1
        -: 2195:          this->m_objName,
        -: 2196:#endif
        -: 2197:          "NoOpStringReceived "
        3: 2198:        , No_op_string.toChar()
        3: 2199:      );
        -: 2200:
        -: 2201:      // Null terminate
        3: 2202:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        3: 2203:      Fw::TextLogString _logString = _textBuffer;
        -: 2204:      this->m_LogText_OutputPort[0].invoke(
        -: 2205:          _id,
        -: 2206:          _logTime,Fw::TEXT_LOG_COMMAND,
        -: 2207:          _logString
        3: 2208:      );
        -: 2209:
        3: 2210:    }
        -: 2211:#endif
        -: 2212:
        3: 2213:  }
        -: 2214:
        3: 2215:  void CommandDispatcherComponentBase ::
        -: 2216:    log_COMMAND_TestCmd1Args(
        -: 2217:        I32 arg1, F32 arg2, U8 arg3
        -: 2218:    )
        -: 2219:  {
        -: 2220:
        -: 2221:    // Get the time
        3: 2222:    Fw::Time _logTime;
        3: 2223:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 2224:      _logTime = this->m_Time_OutputPort[0].invoke();
        -: 2225:    }
        -: 2226:    
        3: 2227:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2228:    
        3: 2229:    _id = EVENTID_TESTCMD1ARGS;
        -: 2230:
        -: 2231:    // Emit the event on the log port
        3: 2232:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 2233:
        3: 2234:      Fw::LogBuffer _logBuff;
        -: 2235:      Fw::SerializeStatus _status;
        -: 2236:
        -: 2237:#if FW_AMPCS_COMPATIBLE
        -: 2238:      // Serialize the number of arguments
        -: 2239:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 2240:      FW_ASSERT(
        -: 2241:          _status == Fw::FW_SERIALIZE_OK,
        -: 2242:          static_cast<AssertArg>(_status)
        -: 2243:      );
        -: 2244:#endif
        -: 2245:
        -: 2246:#if FW_AMPCS_COMPATIBLE
        -: 2247:      // Serialize the argument size
        -: 2248:      _status = _logBuff.serialize(
        -: 2249:          static_cast<U8>(sizeof(arg1))
        -: 2250:      );
        -: 2251:      FW_ASSERT(
        -: 2252:          _status == Fw::FW_SERIALIZE_OK,
        -: 2253:          static_cast<AssertArg>(_status)
        -: 2254:      );
        -: 2255:#endif
        -: 2256:
        3: 2257:      _status = _logBuff.serialize(arg1);
        -: 2258:      FW_ASSERT(
        -: 2259:          _status == Fw::FW_SERIALIZE_OK,
        -: 2260:          static_cast<AssertArg>(_status)
        3: 2261:      );
        -: 2262:
        -: 2263:#if FW_AMPCS_COMPATIBLE
        -: 2264:      // Serialize the argument size
        -: 2265:      _status = _logBuff.serialize(
        -: 2266:          static_cast<U8>(sizeof(arg2))
        -: 2267:      );
        -: 2268:      FW_ASSERT(
        -: 2269:          _status == Fw::FW_SERIALIZE_OK,
        -: 2270:          static_cast<AssertArg>(_status)
        -: 2271:      );
        -: 2272:#endif
        -: 2273:
        3: 2274:      _status = _logBuff.serialize(arg2);
        -: 2275:      FW_ASSERT(
        -: 2276:          _status == Fw::FW_SERIALIZE_OK,
        -: 2277:          static_cast<AssertArg>(_status)
        3: 2278:      );
        -: 2279:
        -: 2280:#if FW_AMPCS_COMPATIBLE
        -: 2281:      // Serialize the argument size
        -: 2282:      _status = _logBuff.serialize(
        -: 2283:          static_cast<U8>(sizeof(arg3))
        -: 2284:      );
        -: 2285:      FW_ASSERT(
        -: 2286:          _status == Fw::FW_SERIALIZE_OK,
        -: 2287:          static_cast<AssertArg>(_status)
        -: 2288:      );
        -: 2289:#endif
        -: 2290:
        3: 2291:      _status = _logBuff.serialize(arg3);
        -: 2292:      FW_ASSERT(
        -: 2293:          _status == Fw::FW_SERIALIZE_OK,
        -: 2294:          static_cast<AssertArg>(_status)
        3: 2295:      );
        -: 2296:
        -: 2297:
        -: 2298:      this->m_Log_OutputPort[0].invoke(
        -: 2299:          _id,
        -: 2300:          _logTime,Fw::LOG_COMMAND,
        -: 2301:          _logBuff
        3: 2302:      );
        -: 2303:
        -: 2304:    }
        -: 2305:
        -: 2306:    // Emit the event on the text log port
        -: 2307:#if FW_ENABLE_TEXT_LOGGING
        3: 2308:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2309:
        -: 2310:#if FW_OBJECT_NAMES == 1
        -: 2311:      const char* _formatString =
        3: 2312:        "(%s) %s: ISF TEST_CMD_1 args: I32: %d, F32: %f, U8: %d";
        -: 2313:#else
        -: 2314:      const char* _formatString =
        -: 2315:        "%s: ISF TEST_CMD_1 args: I32: %d, F32: %f, U8: %d";
        -: 2316:#endif
        -: 2317:
        -: 2318:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2319:
        -: 2320:      (void) snprintf(
        -: 2321:          _textBuffer,
        -: 2322:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2323:          _formatString,
        -: 2324:#if FW_OBJECT_NAMES == 1
        -: 2325:          this->m_objName,
        -: 2326:#endif
        -: 2327:          "TestCmd1Args "
        -: 2328:        , arg1
        -: 2329:        , arg2
        -: 2330:        , arg3
        3: 2331:      );
        -: 2332:
        -: 2333:      // Null terminate
        3: 2334:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        3: 2335:      Fw::TextLogString _logString = _textBuffer;
        -: 2336:      this->m_LogText_OutputPort[0].invoke(
        -: 2337:          _id,
        -: 2338:          _logTime,Fw::TEXT_LOG_COMMAND,
        -: 2339:          _logString
        3: 2340:      );
        -: 2341:
        3: 2342:    }
        -: 2343:#endif
        -: 2344:
        3: 2345:  }
        -: 2346:
        -: 2347:  // ----------------------------------------------------------------------
        -: 2348:  // Mutex functions for guarded ports
        -: 2349:  // ----------------------------------------------------------------------
        -: 2350:
       87: 2351:  void CommandDispatcherComponentBase ::
        -: 2352:    lock(void)
        -: 2353:  {
       87: 2354:    this->m_guardedPortMutex.lock();
       87: 2355:  }
        -: 2356:
       87: 2357:  void CommandDispatcherComponentBase ::
        -: 2358:    unLock(void)
        -: 2359:  {
       87: 2360:    this->m_guardedPortMutex.unLock();
       87: 2361:  }
        -: 2362:
        -: 2363:  // ----------------------------------------------------------------------
        -: 2364:  // Calls for messages received on typed input ports
        -: 2365:  // ----------------------------------------------------------------------
        -: 2366:
       87: 2367:  void CommandDispatcherComponentBase ::
        -: 2368:    m_p_compCmdReg_in(
        -: 2369:        Fw::PassiveComponentBase* callComp,
        -: 2370:        NATIVE_INT_TYPE portNum,
        -: 2371:        FwOpcodeType opCode
        -: 2372:    )
        -: 2373:  {
       87: 2374:    FW_ASSERT(callComp);
        -: 2375:    CommandDispatcherComponentBase* compPtr =
       87: 2376:      (CommandDispatcherComponentBase*) callComp;
       87: 2377:    compPtr->compCmdReg_handlerBase(portNum, opCode);
       87: 2378:  }
        -: 2379:
       23: 2380:  void CommandDispatcherComponentBase ::
        -: 2381:    m_p_compCmdStat_in(
        -: 2382:        Fw::PassiveComponentBase* callComp,
        -: 2383:        NATIVE_INT_TYPE portNum,
        -: 2384:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 2385:    )
        -: 2386:  {
       23: 2387:    FW_ASSERT(callComp);
        -: 2388:    CommandDispatcherComponentBase* compPtr =
       23: 2389:      (CommandDispatcherComponentBase*) callComp;
       23: 2390:    compPtr->compCmdStat_handlerBase(portNum, opCode, cmdSeq, response);
       23: 2391:  }
        -: 2392:
      107: 2393:  void CommandDispatcherComponentBase ::
        -: 2394:    m_p_seqCmdBuff_in(
        -: 2395:        Fw::PassiveComponentBase* callComp,
        -: 2396:        NATIVE_INT_TYPE portNum,
        -: 2397:        Fw::ComBuffer &data, U32 context
        -: 2398:    )
        -: 2399:  {
      107: 2400:    FW_ASSERT(callComp);
        -: 2401:    CommandDispatcherComponentBase* compPtr =
      107: 2402:      (CommandDispatcherComponentBase*) callComp;
      107: 2403:    compPtr->seqCmdBuff_handlerBase(portNum, data, context);
      107: 2404:  }
        -: 2405:
        -: 2406:  // ----------------------------------------------------------------------
        -: 2407:  // Port handler base-class functions for typed input ports
        -: 2408:  // ----------------------------------------------------------------------
        -: 2409:
       87: 2410:  void CommandDispatcherComponentBase ::
        -: 2411:    compCmdReg_handlerBase(
        -: 2412:        NATIVE_INT_TYPE portNum,
        -: 2413:        FwOpcodeType opCode
        -: 2414:    )
        -: 2415:  {
        -: 2416:
        -: 2417:    // Make sure port number is valid
       87: 2418:    FW_ASSERT(portNum < this->getNum_compCmdReg_InputPorts(),static_cast<AssertArg>(portNum));
        -: 2419:
        -: 2420:    // Lock guard mutex before calling
       87: 2421:    this->lock();
        -: 2422:
        -: 2423:    // Down call to pure virtual handler method implemented in Impl class
       87: 2424:    this->compCmdReg_handler(portNum, opCode);
        -: 2425:
        -: 2426:    // Unlock guard mutex
       87: 2427:    this->unLock();
        -: 2428:
       87: 2429:  }
        -: 2430:
       23: 2431:  void CommandDispatcherComponentBase ::
        -: 2432:    compCmdStat_handlerBase(
        -: 2433:        NATIVE_INT_TYPE portNum,
        -: 2434:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 2435:    )
        -: 2436:  {
        -: 2437:
        -: 2438:    // Make sure port number is valid
       23: 2439:    FW_ASSERT(portNum < this->getNum_compCmdStat_InputPorts(),static_cast<AssertArg>(portNum));
        -: 2440:
        -: 2441:    // Call pre-message hook
        -: 2442:    compCmdStat_preMsgHook(
        -: 2443:        portNum,
        -: 2444:        opCode, cmdSeq, response
       23: 2445:    );
        -: 2446:
       23: 2447:    ComponentIpcSerializableBuffer msg;
        -: 2448:    Fw::SerializeStatus _status;
        -: 2449:
        -: 2450:    _status = msg.serialize(
        -: 2451:        static_cast<NATIVE_INT_TYPE>(COMPCMDSTAT_CMDRESPONSE)
       23: 2452:    );
        -: 2453:    FW_ASSERT (
        -: 2454:        _status == Fw::FW_SERIALIZE_OK,
        -: 2455:        static_cast<AssertArg>(_status)
       23: 2456:    );
        -: 2457:
       23: 2458:    _status = msg.serialize(portNum);
        -: 2459:    FW_ASSERT (
        -: 2460:        _status == Fw::FW_SERIALIZE_OK,
        -: 2461:        static_cast<AssertArg>(_status)
       23: 2462:    );
        -: 2463:
        -: 2464:    // Serialize argument opCode
       23: 2465:    _status = msg.serialize(opCode);
        -: 2466:    FW_ASSERT(
        -: 2467:        _status == Fw::FW_SERIALIZE_OK,
        -: 2468:        static_cast<AssertArg>(_status)
       23: 2469:    );
        -: 2470:
        -: 2471:    // Serialize argument cmdSeq
       23: 2472:    _status = msg.serialize(cmdSeq);
        -: 2473:    FW_ASSERT(
        -: 2474:        _status == Fw::FW_SERIALIZE_OK,
        -: 2475:        static_cast<AssertArg>(_status)
       23: 2476:    );
        -: 2477:
        -: 2478:    // Serialize argument response
       23: 2479:    _status = msg.serialize(static_cast<FwEnumStoreType>(response));
        -: 2480:    FW_ASSERT(
        -: 2481:        _status == Fw::FW_SERIALIZE_OK,
        -: 2482:        static_cast<AssertArg>(_status)
       23: 2483:    );
        -: 2484:
        -: 2485:    Os::Queue::QueueStatus qStatus =
       23: 2486:      this->m_queue.send(msg, 0);
        -: 2487:    FW_ASSERT(
        -: 2488:        qStatus == Os::Queue::QUEUE_OK,
        -: 2489:        static_cast<AssertArg>(qStatus)
       23: 2490:    );
       23: 2491:  }
        -: 2492:
      107: 2493:  void CommandDispatcherComponentBase ::
        -: 2494:    seqCmdBuff_handlerBase(
        -: 2495:        NATIVE_INT_TYPE portNum,
        -: 2496:        Fw::ComBuffer &data, U32 context
        -: 2497:    )
        -: 2498:  {
        -: 2499:
        -: 2500:    // Make sure port number is valid
      107: 2501:    FW_ASSERT(portNum < this->getNum_seqCmdBuff_InputPorts(),static_cast<AssertArg>(portNum));
        -: 2502:
        -: 2503:    // Call pre-message hook
        -: 2504:    seqCmdBuff_preMsgHook(
        -: 2505:        portNum,
        -: 2506:        data, context
      107: 2507:    );
        -: 2508:
      107: 2509:    ComponentIpcSerializableBuffer msg;
        -: 2510:    Fw::SerializeStatus _status;
        -: 2511:
        -: 2512:    _status = msg.serialize(
        -: 2513:        static_cast<NATIVE_INT_TYPE>(SEQCMDBUFF_COM)
      107: 2514:    );
        -: 2515:    FW_ASSERT (
        -: 2516:        _status == Fw::FW_SERIALIZE_OK,
        -: 2517:        static_cast<AssertArg>(_status)
      107: 2518:    );
        -: 2519:
      107: 2520:    _status = msg.serialize(portNum);
        -: 2521:    FW_ASSERT (
        -: 2522:        _status == Fw::FW_SERIALIZE_OK,
        -: 2523:        static_cast<AssertArg>(_status)
      107: 2524:    );
        -: 2525:
        -: 2526:    // Serialize argument data
      107: 2527:    _status = msg.serialize(data);
        -: 2528:    FW_ASSERT(
        -: 2529:        _status == Fw::FW_SERIALIZE_OK,
        -: 2530:        static_cast<AssertArg>(_status)
      107: 2531:    );
        -: 2532:
        -: 2533:    // Serialize argument context
      107: 2534:    _status = msg.serialize(context);
        -: 2535:    FW_ASSERT(
        -: 2536:        _status == Fw::FW_SERIALIZE_OK,
        -: 2537:        static_cast<AssertArg>(_status)
      107: 2538:    );
        -: 2539:
        -: 2540:    Os::Queue::QueueStatus qStatus =
      107: 2541:      this->m_queue.send(msg, 0);
        -: 2542:    FW_ASSERT(
        -: 2543:        qStatus == Os::Queue::QUEUE_OK,
        -: 2544:        static_cast<AssertArg>(qStatus)
      107: 2545:    );
      107: 2546:  }
        -: 2547:
        -: 2548:  // ----------------------------------------------------------------------
        -: 2549:  // Pre-message hooks for async input ports
        -: 2550:  // ----------------------------------------------------------------------
        -: 2551:
       23: 2552:  void CommandDispatcherComponentBase ::
        -: 2553:    compCmdStat_preMsgHook(
        -: 2554:        NATIVE_INT_TYPE portNum,
        -: 2555:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 2556:    )
        -: 2557:  {
        -: 2558:    // Default: no-op
       23: 2559:  }
        -: 2560:
      107: 2561:  void CommandDispatcherComponentBase ::
        -: 2562:    seqCmdBuff_preMsgHook(
        -: 2563:        NATIVE_INT_TYPE portNum,
        -: 2564:        Fw::ComBuffer &data, U32 context
        -: 2565:    )
        -: 2566:  {
        -: 2567:    // Default: no-op
      107: 2568:  }
        -: 2569:
        -: 2570:  // ----------------------------------------------------------------------
        -: 2571:  // Message dispatch method for active and queued components. Called
        -: 2572:  // by active component thread or implementation code for queued components
        -: 2573:  // ----------------------------------------------------------------------
        -: 2574:
      139: 2575:  Fw::QueuedComponentBase::MsgDispatchStatus CommandDispatcherComponentBase ::
        -: 2576:    doDispatch(void)
        -: 2577:  {
        -: 2578:
      139: 2579:    ComponentIpcSerializableBuffer msg;
        -: 2580:    NATIVE_INT_TYPE priority;
        -: 2581:
      139: 2582:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority);
        -: 2583:    FW_ASSERT(
        -: 2584:        msgStatus == Os::Queue::QUEUE_OK,
        -: 2585:        static_cast<AssertArg>(msgStatus)
      139: 2586:    );
        -: 2587:
        -: 2588:    // Reset to beginning of buffer
      139: 2589:    msg.resetDeser();
        -: 2590:
        -: 2591:    NATIVE_INT_TYPE desMsg;
      139: 2592:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
        -: 2593:    FW_ASSERT(
        -: 2594:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2595:        static_cast<AssertArg>(deserStatus)
      139: 2596:    );
        -: 2597:
      139: 2598:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -: 2599:
      139: 2600:    if (msgType == COMMANDDISPATCHER_COMPONENT_EXIT) {
    #####: 2601:      return MSG_DISPATCH_EXIT;
        -: 2602:    }
        -: 2603:
        -: 2604:    NATIVE_INT_TYPE portNum;
      139: 2605:    deserStatus = msg.deserialize(portNum);
        -: 2606:    FW_ASSERT(
        -: 2607:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2608:        static_cast<AssertArg>(deserStatus)
      139: 2609:    );
        -: 2610:
      139: 2611:    switch (msgType) {
        -: 2612:
        -: 2613:      // Handle async input port compCmdStat
        -: 2614:      case COMPCMDSTAT_CMDRESPONSE: {
        -: 2615:
        -: 2616:        // Deserialize argument opCode
        -: 2617:        FwOpcodeType opCode;
       20: 2618:        deserStatus = msg.deserialize(opCode);
        -: 2619:        FW_ASSERT(
        -: 2620:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2621:            static_cast<AssertArg>(deserStatus)
       20: 2622:        );
        -: 2623:
        -: 2624:        // Deserialize argument cmdSeq
        -: 2625:        U32 cmdSeq;
       20: 2626:        deserStatus = msg.deserialize(cmdSeq);
        -: 2627:        FW_ASSERT(
        -: 2628:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2629:            static_cast<AssertArg>(deserStatus)
       20: 2630:        );
        -: 2631:
        -: 2632:        // Deserialize argument response
        -: 2633:        Fw::CommandResponse response;
        -: 2634:        FwEnumStoreType responseInt;
       20: 2635:        deserStatus = msg.deserialize(responseInt);
       20: 2636:        response = (Fw::CommandResponse) responseInt;
        -: 2637:        FW_ASSERT(
        -: 2638:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2639:            static_cast<AssertArg>(deserStatus)
       20: 2640:        );
        -: 2641:
        -: 2642:        // Call handler function
        -: 2643:        this->compCmdStat_handler(
        -: 2644:            portNum,
        -: 2645:            opCode, cmdSeq, response
       20: 2646:        );
        -: 2647:
       20: 2648:        break;
        -: 2649:
        -: 2650:      }
        -: 2651:
        -: 2652:      // Handle async input port seqCmdBuff
        -: 2653:      case SEQCMDBUFF_COM: {
        -: 2654:
        -: 2655:        // Deserialize argument data
      107: 2656:        Fw::ComBuffer data;
      107: 2657:        deserStatus = msg.deserialize(data);
        -: 2658:        FW_ASSERT(
        -: 2659:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2660:            static_cast<AssertArg>(deserStatus)
      107: 2661:        );
        -: 2662:
        -: 2663:        // Deserialize argument context
        -: 2664:        U32 context;
      107: 2665:        deserStatus = msg.deserialize(context);
        -: 2666:        FW_ASSERT(
        -: 2667:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2668:            static_cast<AssertArg>(deserStatus)
      107: 2669:        );
        -: 2670:
        -: 2671:        // Call handler function
        -: 2672:        this->seqCmdBuff_handler(
        -: 2673:            portNum,
        -: 2674:            data, context
      107: 2675:        );
        -: 2676:
      107: 2677:        break;
        -: 2678:
        -: 2679:      }
        -: 2680:
        -: 2681:      // Handle command CMD_NO_OP
        -: 2682:      case CMD_CMD_NO_OP: {
        -: 2683:        // Deserialize opcode
        -: 2684:        FwOpcodeType opCode;
        3: 2685:        deserStatus = msg.deserialize(opCode);
        -: 2686:        FW_ASSERT (
        -: 2687:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2688:            static_cast<AssertArg>(deserStatus)
        3: 2689:        );
        -: 2690:
        -: 2691:        // Deserialize command sequence
        -: 2692:        U32 cmdSeq;
        3: 2693:        deserStatus = msg.deserialize(cmdSeq);
        -: 2694:        FW_ASSERT (
        -: 2695:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2696:            static_cast<AssertArg>(deserStatus)
        3: 2697:        );
        -: 2698:
        -: 2699:        // Deserialize command argument buffer
        3: 2700:        Fw::CmdArgBuffer args;
        3: 2701:        deserStatus = msg.deserialize(args);
        -: 2702:        FW_ASSERT (
        -: 2703:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2704:            static_cast<AssertArg>(deserStatus)
        3: 2705:        );
        -: 2706:
        -: 2707:        // Reset buffer
        3: 2708:        args.resetDeser();
        -: 2709:
        -: 2710:        // Make sure there was no data left over.
        -: 2711:        // That means the argument buffer size was incorrect.
        3: 2712:        if (args.getBuffLeft() != 0) {
    #####: 2713:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2714:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2715:          }
        -: 2716:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2717:          break;
        -: 2718:        }
        -: 2719:
        -: 2720:        // Call handler function
        3: 2721:        this->CMD_NO_OP_cmdHandler(opCode, cmdSeq);
        -: 2722:
        3: 2723:        break;
        -: 2724:
        -: 2725:      }
        -: 2726:
        -: 2727:      // Handle command CMD_NO_OP_STRING
        -: 2728:      case CMD_CMD_NO_OP_STRING: {
        -: 2729:        // Deserialize opcode
        -: 2730:        FwOpcodeType opCode;
        3: 2731:        deserStatus = msg.deserialize(opCode);
        -: 2732:        FW_ASSERT (
        -: 2733:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2734:            static_cast<AssertArg>(deserStatus)
        3: 2735:        );
        -: 2736:
        -: 2737:        // Deserialize command sequence
        -: 2738:        U32 cmdSeq;
        3: 2739:        deserStatus = msg.deserialize(cmdSeq);
        -: 2740:        FW_ASSERT (
        -: 2741:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2742:            static_cast<AssertArg>(deserStatus)
        3: 2743:        );
        -: 2744:
        -: 2745:        // Deserialize command argument buffer
        3: 2746:        Fw::CmdArgBuffer args;
        3: 2747:        deserStatus = msg.deserialize(args);
        -: 2748:        FW_ASSERT (
        -: 2749:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2750:            static_cast<AssertArg>(deserStatus)
        3: 2751:        );
        -: 2752:
        -: 2753:        // Reset buffer
        3: 2754:        args.resetDeser();
        -: 2755:
        -: 2756:        // Deserialize argument arg1
        6: 2757:        Fw::CmdStringArg arg1;
        3: 2758:        deserStatus = args.deserialize(arg1);
        3: 2759:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2760:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2761:            this->cmdResponse_out(
        -: 2762:                opCode,
        -: 2763:                cmdSeq,
        -: 2764:                Fw::COMMAND_FORMAT_ERROR
    #####: 2765:            );
        -: 2766:          }
        -: 2767:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2768:          break;
        -: 2769:        }
        -: 2770:
        -: 2771:        // Make sure there was no data left over.
        -: 2772:        // That means the argument buffer size was incorrect.
        3: 2773:        if (args.getBuffLeft() != 0) {
    #####: 2774:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2775:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2776:          }
        -: 2777:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2778:          break;
        -: 2779:        }
        -: 2780:
        -: 2781:        // Call handler function
        -: 2782:        this->CMD_NO_OP_STRING_cmdHandler(
        -: 2783:            opCode,
        -: 2784:            cmdSeq,
        -: 2785:            arg1
        3: 2786:        );
        -: 2787:
        6: 2788:        break;
        -: 2789:
        -: 2790:      }
        -: 2791:
        -: 2792:      // Handle command CMD_TEST_CMD_1
        -: 2793:      case CMD_CMD_TEST_CMD_1: {
        -: 2794:        // Deserialize opcode
        -: 2795:        FwOpcodeType opCode;
        3: 2796:        deserStatus = msg.deserialize(opCode);
        -: 2797:        FW_ASSERT (
        -: 2798:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2799:            static_cast<AssertArg>(deserStatus)
        3: 2800:        );
        -: 2801:
        -: 2802:        // Deserialize command sequence
        -: 2803:        U32 cmdSeq;
        3: 2804:        deserStatus = msg.deserialize(cmdSeq);
        -: 2805:        FW_ASSERT (
        -: 2806:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2807:            static_cast<AssertArg>(deserStatus)
        3: 2808:        );
        -: 2809:
        -: 2810:        // Deserialize command argument buffer
        3: 2811:        Fw::CmdArgBuffer args;
        3: 2812:        deserStatus = msg.deserialize(args);
        -: 2813:        FW_ASSERT (
        -: 2814:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2815:            static_cast<AssertArg>(deserStatus)
        3: 2816:        );
        -: 2817:
        -: 2818:        // Reset buffer
        3: 2819:        args.resetDeser();
        -: 2820:
        -: 2821:        // Deserialize argument arg1
        -: 2822:        I32 arg1;
        3: 2823:        deserStatus = args.deserialize(arg1);
        3: 2824:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2825:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2826:            this->cmdResponse_out(
        -: 2827:                opCode,
        -: 2828:                cmdSeq,
        -: 2829:                Fw::COMMAND_FORMAT_ERROR
    #####: 2830:            );
        -: 2831:          }
        -: 2832:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2833:          break;
        -: 2834:        }
        -: 2835:
        -: 2836:        // Deserialize argument arg2
        -: 2837:        F32 arg2;
        3: 2838:        deserStatus = args.deserialize(arg2);
        3: 2839:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2840:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2841:            this->cmdResponse_out(
        -: 2842:                opCode,
        -: 2843:                cmdSeq,
        -: 2844:                Fw::COMMAND_FORMAT_ERROR
    #####: 2845:            );
        -: 2846:          }
        -: 2847:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2848:          break;
        -: 2849:        }
        -: 2850:
        -: 2851:        // Deserialize argument arg3
        -: 2852:        U8 arg3;
        3: 2853:        deserStatus = args.deserialize(arg3);
        3: 2854:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2855:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2856:            this->cmdResponse_out(
        -: 2857:                opCode,
        -: 2858:                cmdSeq,
        -: 2859:                Fw::COMMAND_FORMAT_ERROR
    #####: 2860:            );
        -: 2861:          }
        -: 2862:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2863:          break;
        -: 2864:        }
        -: 2865:
        -: 2866:        // Make sure there was no data left over.
        -: 2867:        // That means the argument buffer size was incorrect.
        3: 2868:        if (args.getBuffLeft() != 0) {
    #####: 2869:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2870:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2871:          }
        -: 2872:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2873:          break;
        -: 2874:        }
        -: 2875:
        -: 2876:        // Call handler function
        -: 2877:        this->CMD_TEST_CMD_1_cmdHandler(
        -: 2878:            opCode,
        -: 2879:            cmdSeq,
        -: 2880:            arg1, arg2, arg3
        3: 2881:        );
        -: 2882:
        3: 2883:        break;
        -: 2884:
        -: 2885:      }
        -: 2886:
        -: 2887:      // Handle command CMD_CLEAR_TRACKING
        -: 2888:      case CMD_CMD_CLEAR_TRACKING: {
        -: 2889:        // Deserialize opcode
        -: 2890:        FwOpcodeType opCode;
        3: 2891:        deserStatus = msg.deserialize(opCode);
        -: 2892:        FW_ASSERT (
        -: 2893:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2894:            static_cast<AssertArg>(deserStatus)
        3: 2895:        );
        -: 2896:
        -: 2897:        // Deserialize command sequence
        -: 2898:        U32 cmdSeq;
        3: 2899:        deserStatus = msg.deserialize(cmdSeq);
        -: 2900:        FW_ASSERT (
        -: 2901:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2902:            static_cast<AssertArg>(deserStatus)
        3: 2903:        );
        -: 2904:
        -: 2905:        // Deserialize command argument buffer
        3: 2906:        Fw::CmdArgBuffer args;
        3: 2907:        deserStatus = msg.deserialize(args);
        -: 2908:        FW_ASSERT (
        -: 2909:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2910:            static_cast<AssertArg>(deserStatus)
        3: 2911:        );
        -: 2912:
        -: 2913:        // Reset buffer
        3: 2914:        args.resetDeser();
        -: 2915:
        -: 2916:        // Make sure there was no data left over.
        -: 2917:        // That means the argument buffer size was incorrect.
        3: 2918:        if (args.getBuffLeft() != 0) {
    #####: 2919:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2920:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2921:          }
        -: 2922:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2923:          break;
        -: 2924:        }
        -: 2925:
        -: 2926:        // Call handler function
        3: 2927:        this->CMD_CLEAR_TRACKING_cmdHandler(opCode, cmdSeq);
        -: 2928:
        3: 2929:        break;
        -: 2930:
        -: 2931:      }
        -: 2932:
        -: 2933:      default:
    #####: 2934:        return MSG_DISPATCH_ERROR;
        -: 2935:
        -: 2936:    }
        -: 2937:
      139: 2938:    return MSG_DISPATCH_OK;
        -: 2939:
        -: 2940:  }
        -: 2941:
        -: 2942:} // end namespace Svc
