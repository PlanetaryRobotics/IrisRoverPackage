        -:    0:Source:/home/tim/source/isf/Svc/CmdSequencer/CmdSequencerComponentAc.cpp
        -:    0:Programs:11
        -:    1:// ====================================================================== 
        -:    2:// \title  CmdSequencerComponentAc.hpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for CmdSequencer component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   11:// 
        -:   18:// ====================================================================== 
        -:   19:
        -:   20:#include <stdio.h>
        -:   21:#include <Fw/Cfg/Config.hpp>
        -:   22:#include <Svc/CmdSequencer/CmdSequencerComponentAc.hpp>
        -:   23:#include <Fw/Types/Assert.hpp>
        -:   24:#if FW_ENABLE_TEXT_LOGGING
        -:   25:#include <Fw/Types/EightyCharString.hpp>
        -:   26:#endif
        -:   27:
        -:   28:
        -:   29:namespace Svc {
        -:   30:
        -:   31:  // ----------------------------------------------------------------------
        -:   32:  // Anonymous namespace to prevent name collisions
        -:   33:  // ----------------------------------------------------------------------
        -:   34:
        -:   35:  namespace {
        -:   36:
        -:   37:    typedef enum {
        -:   38:      CMDSEQUENCER_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   39:      PINGIN_PING,
        -:   40:      CMDRESPONSEIN_CMDRESPONSE,
        -:   41:      SCHEDIN_SCHED,
        -:   42:      SEQRUNIN_CMDSEQIN,
        -:   43:      CMD_CS_RUN,
        -:   44:      CMD_CS_VALIDATE,
        -:   45:      CMD_CS_CANCEL,
        -:   46:      CMD_CS_START,
        -:   47:      CMD_CS_STEP,
        -:   48:      CMD_CS_AUTO,
        -:   49:      CMD_CS_MANUAL
        -:   50:    } MsgTypeEnum;
        -:   51:
        -:   52:    // Get the max size by doing a union of the input port serialization sizes.
        -:   53:
        -:   54:    typedef union {
        -:   55:      BYTE port1[Svc::InputPingPort::SERIALIZED_SIZE];
        -:   56:      BYTE port2[Fw::InputCmdResponsePort::SERIALIZED_SIZE];
        -:   57:      BYTE port3[Svc::InputSchedPort::SERIALIZED_SIZE];
        -:   58:      BYTE port4[Svc::InputCmdSeqInPort::SERIALIZED_SIZE];
        -:   59:      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
        -:   60:    } BuffUnion;
        -:   61:
        -:   62:    // Define a message buffer class large enough to handle all the
        -:   63:    // asynchronous inputs to the component
        -:   64:
     4348:   65:    class ComponentIpcSerializableBuffer : 
        -:   66:      public Fw::SerializeBufferBase
        -:   67:    {
        -:   68:
        -:   69:      public:
        -:   70:
        -:   71:        enum {
        -:   72:          // Max. message size = size of data + message id + port
        -:   73:          SERIALIZATION_SIZE =
        -:   74:            sizeof(BuffUnion) +
        -:   75:            sizeof(NATIVE_INT_TYPE) +
        -:   76:            sizeof(NATIVE_INT_TYPE)
        -:   77:        };
        -:   78:
     7949:   79:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
     7949:   80:          return sizeof(m_buff);
        -:   81:        }
        -:   82:
    52530:   83:        U8* getBuffAddr(void) {
    52530:   84:          return m_buff;
        -:   85:        }
        -:   86:
     1087:   87:        const U8* getBuffAddr(void) const {
     1087:   88:          return m_buff;
        -:   89:        }
        -:   90:
        -:   91:      private:
        -:   92:        // Should be the max of all the input ports serialized sizes...
        -:   93:        U8 m_buff[SERIALIZATION_SIZE];
        -:   94:
        -:   95:    };
        -:   96:
        -:   97:  }
        -:   98:
        -:   99:  // ----------------------------------------------------------------------
        -:  100:  // Getters for numbers of input ports
        -:  101:  // ----------------------------------------------------------------------
        -:  102:
      213:  103:  Svc::InputPingPort *CmdSequencerComponentBase ::
        -:  104:    get_pingIn_InputPort(NATIVE_INT_TYPE portNum)
        -:  105:  {
      213:  106:    FW_ASSERT(portNum < this->getNum_pingIn_InputPorts(),static_cast<AssertArg>(portNum));
      213:  107:    return &this->m_pingIn_InputPort[portNum];
        -:  108:  }
        -:  109:
      213:  110:  Fw::InputCmdResponsePort *CmdSequencerComponentBase ::
        -:  111:    get_cmdResponseIn_InputPort(NATIVE_INT_TYPE portNum)
        -:  112:  {
      213:  113:    FW_ASSERT(portNum < this->getNum_cmdResponseIn_InputPorts(),static_cast<AssertArg>(portNum));
      213:  114:    return &this->m_cmdResponseIn_InputPort[portNum];
        -:  115:  }
        -:  116:
      213:  117:  Fw::InputCmdPort *CmdSequencerComponentBase ::
        -:  118:    get_cmdIn_InputPort(NATIVE_INT_TYPE portNum)
        -:  119:  {
      213:  120:    FW_ASSERT(portNum < this->getNum_cmdIn_InputPorts(),static_cast<AssertArg>(portNum));
      213:  121:    return &this->m_cmdIn_InputPort[portNum];
        -:  122:  }
        -:  123:
      213:  124:  Svc::InputSchedPort *CmdSequencerComponentBase ::
        -:  125:    get_schedIn_InputPort(NATIVE_INT_TYPE portNum)
        -:  126:  {
      213:  127:    FW_ASSERT(portNum < this->getNum_schedIn_InputPorts(),static_cast<AssertArg>(portNum));
      213:  128:    return &this->m_schedIn_InputPort[portNum];
        -:  129:  }
        -:  130:
      213:  131:  Svc::InputCmdSeqInPort *CmdSequencerComponentBase ::
        -:  132:    get_seqRunIn_InputPort(NATIVE_INT_TYPE portNum)
        -:  133:  {
      213:  134:    FW_ASSERT(portNum < this->getNum_seqRunIn_InputPorts(),static_cast<AssertArg>(portNum));
      213:  135:    return &this->m_seqRunIn_InputPort[portNum];
        -:  136:  }
        -:  137:
        -:  138:  // ----------------------------------------------------------------------
        -:  139:  // Typed connectors for output ports
        -:  140:  // ----------------------------------------------------------------------
        -:  141:
      213:  142:  void CmdSequencerComponentBase ::
        -:  143:    set_cmdRegOut_OutputPort(
        -:  144:        NATIVE_INT_TYPE portNum,
        -:  145:        Fw::InputCmdRegPort* port
        -:  146:    )
        -:  147:  {
      213:  148:    FW_ASSERT(portNum < this->getNum_cmdRegOut_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  149:    this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
      213:  150:  }
        -:  151:
        -:  152:#if FW_ENABLE_TEXT_LOGGING == 1
      213:  153:  void CmdSequencerComponentBase ::
        -:  154:    set_LogText_OutputPort(
        -:  155:        NATIVE_INT_TYPE portNum,
        -:  156:        Fw::InputLogTextPort* port
        -:  157:    )
        -:  158:  {
      213:  159:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  160:    this->m_LogText_OutputPort[portNum].addCallPort(port);
      213:  161:  }
        -:  162:#endif
        -:  163:
      213:  164:  void CmdSequencerComponentBase ::
        -:  165:    set_tlmOut_OutputPort(
        -:  166:        NATIVE_INT_TYPE portNum,
        -:  167:        Fw::InputTlmPort* port
        -:  168:    )
        -:  169:  {
      213:  170:    FW_ASSERT(portNum < this->getNum_tlmOut_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  171:    this->m_tlmOut_OutputPort[portNum].addCallPort(port);
      213:  172:  }
        -:  173:
      213:  174:  void CmdSequencerComponentBase ::
        -:  175:    set_cmdResponseOut_OutputPort(
        -:  176:        NATIVE_INT_TYPE portNum,
        -:  177:        Fw::InputCmdResponsePort* port
        -:  178:    )
        -:  179:  {
      213:  180:    FW_ASSERT(portNum < this->getNum_cmdResponseOut_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  181:    this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
      213:  182:  }
        -:  183:
      213:  184:  void CmdSequencerComponentBase ::
        -:  185:    set_timeCaller_OutputPort(
        -:  186:        NATIVE_INT_TYPE portNum,
        -:  187:        Fw::InputTimePort* port
        -:  188:    )
        -:  189:  {
      213:  190:    FW_ASSERT(portNum < this->getNum_timeCaller_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  191:    this->m_timeCaller_OutputPort[portNum].addCallPort(port);
      213:  192:  }
        -:  193:
      213:  194:  void CmdSequencerComponentBase ::
        -:  195:    set_comCmdOut_OutputPort(
        -:  196:        NATIVE_INT_TYPE portNum,
        -:  197:        Fw::InputComPort* port
        -:  198:    )
        -:  199:  {
      213:  200:    FW_ASSERT(portNum < this->getNum_comCmdOut_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  201:    this->m_comCmdOut_OutputPort[portNum].addCallPort(port);
      213:  202:  }
        -:  203:
      213:  204:  void CmdSequencerComponentBase ::
        -:  205:    set_pingOut_OutputPort(
        -:  206:        NATIVE_INT_TYPE portNum,
        -:  207:        Svc::InputPingPort* port
        -:  208:    )
        -:  209:  {
      213:  210:    FW_ASSERT(portNum < this->getNum_pingOut_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  211:    this->m_pingOut_OutputPort[portNum].addCallPort(port);
      213:  212:  }
        -:  213:
      213:  214:  void CmdSequencerComponentBase ::
        -:  215:    set_logOut_OutputPort(
        -:  216:        NATIVE_INT_TYPE portNum,
        -:  217:        Fw::InputLogPort* port
        -:  218:    )
        -:  219:  {
      213:  220:    FW_ASSERT(portNum < this->getNum_logOut_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  221:    this->m_logOut_OutputPort[portNum].addCallPort(port);
      213:  222:  }
        -:  223:
      213:  224:  void CmdSequencerComponentBase ::
        -:  225:    set_seqDone_OutputPort(
        -:  226:        NATIVE_INT_TYPE portNum,
        -:  227:        Fw::InputCmdResponsePort* port
        -:  228:    )
        -:  229:  {
      213:  230:    FW_ASSERT(portNum < this->getNum_seqDone_OutputPorts(),static_cast<AssertArg>(portNum));
      213:  231:    this->m_seqDone_OutputPort[portNum].addCallPort(port);
      213:  232:  }
        -:  233:
        -:  234:  // ----------------------------------------------------------------------
        -:  235:  // Serialization connectors for output ports
        -:  236:  // ----------------------------------------------------------------------
        -:  237:
        -:  238:#if FW_PORT_SERIALIZATION
        -:  239:
    #####:  240:  void CmdSequencerComponentBase ::
        -:  241:    set_cmdRegOut_OutputPort(
        -:  242:        NATIVE_INT_TYPE portNum,
        -:  243:        Fw::InputSerializePort *port
        -:  244:    )
        -:  245:  {
    #####:  246:    FW_ASSERT(portNum < this->getNum_cmdRegOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  247:    return this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
        -:  248:  }
        -:  249:
        -:  250:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  251:  void CmdSequencerComponentBase ::
        -:  252:    set_LogText_OutputPort(
        -:  253:        NATIVE_INT_TYPE portNum,
        -:  254:        Fw::InputSerializePort *port
        -:  255:    )
        -:  256:  {
    #####:  257:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  258:    return this->m_LogText_OutputPort[portNum].registerSerialPort(port);
        -:  259:  }
        -:  260:#endif
        -:  261:
    #####:  262:  void CmdSequencerComponentBase ::
        -:  263:    set_tlmOut_OutputPort(
        -:  264:        NATIVE_INT_TYPE portNum,
        -:  265:        Fw::InputSerializePort *port
        -:  266:    )
        -:  267:  {
    #####:  268:    FW_ASSERT(portNum < this->getNum_tlmOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  269:    return this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
        -:  270:  }
        -:  271:
    #####:  272:  void CmdSequencerComponentBase ::
        -:  273:    set_cmdResponseOut_OutputPort(
        -:  274:        NATIVE_INT_TYPE portNum,
        -:  275:        Fw::InputSerializePort *port
        -:  276:    )
        -:  277:  {
    #####:  278:    FW_ASSERT(portNum < this->getNum_cmdResponseOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  279:    return this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
        -:  280:  }
        -:  281:
    #####:  282:  void CmdSequencerComponentBase ::
        -:  283:    set_timeCaller_OutputPort(
        -:  284:        NATIVE_INT_TYPE portNum,
        -:  285:        Fw::InputSerializePort *port
        -:  286:    )
        -:  287:  {
    #####:  288:    FW_ASSERT(portNum < this->getNum_timeCaller_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  289:    return this->m_timeCaller_OutputPort[portNum].registerSerialPort(port);
        -:  290:  }
        -:  291:
    #####:  292:  void CmdSequencerComponentBase ::
        -:  293:    set_comCmdOut_OutputPort(
        -:  294:        NATIVE_INT_TYPE portNum,
        -:  295:        Fw::InputSerializePort *port
        -:  296:    )
        -:  297:  {
    #####:  298:    FW_ASSERT(portNum < this->getNum_comCmdOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  299:    return this->m_comCmdOut_OutputPort[portNum].registerSerialPort(port);
        -:  300:  }
        -:  301:
    #####:  302:  void CmdSequencerComponentBase ::
        -:  303:    set_pingOut_OutputPort(
        -:  304:        NATIVE_INT_TYPE portNum,
        -:  305:        Fw::InputSerializePort *port
        -:  306:    )
        -:  307:  {
    #####:  308:    FW_ASSERT(portNum < this->getNum_pingOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  309:    return this->m_pingOut_OutputPort[portNum].registerSerialPort(port);
        -:  310:  }
        -:  311:
    #####:  312:  void CmdSequencerComponentBase ::
        -:  313:    set_logOut_OutputPort(
        -:  314:        NATIVE_INT_TYPE portNum,
        -:  315:        Fw::InputSerializePort *port
        -:  316:    )
        -:  317:  {
    #####:  318:    FW_ASSERT(portNum < this->getNum_logOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  319:    return this->m_logOut_OutputPort[portNum].registerSerialPort(port);
        -:  320:  }
        -:  321:
    #####:  322:  void CmdSequencerComponentBase ::
        -:  323:    set_seqDone_OutputPort(
        -:  324:        NATIVE_INT_TYPE portNum,
        -:  325:        Fw::InputSerializePort *port
        -:  326:    )
        -:  327:  {
    #####:  328:    FW_ASSERT(portNum < this->getNum_seqDone_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  329:    return this->m_seqDone_OutputPort[portNum].registerSerialPort(port);
        -:  330:  }
        -:  331:
        -:  332:#endif
        -:  333:
        -:  334:  // ----------------------------------------------------------------------
        -:  335:  // Command registration
        -:  336:  // ----------------------------------------------------------------------
        -:  337:
        9:  338:  void CmdSequencerComponentBase ::
        -:  339:    regCommands(void)
        -:  340:  {
        9:  341:    FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());
        9:  342:    this->m_cmdRegOut_OutputPort[0].invoke(
        -:  343:        this->getIdBase() + OPCODE_CS_RUN
        9:  344:    );
        9:  345:    this->m_cmdRegOut_OutputPort[0].invoke(
        9:  346:        this->getIdBase() + OPCODE_CS_VALIDATE
        9:  347:    );
        9:  348:    this->m_cmdRegOut_OutputPort[0].invoke(
        9:  349:        this->getIdBase() + OPCODE_CS_CANCEL
        9:  350:    );
        9:  351:    this->m_cmdRegOut_OutputPort[0].invoke(
        9:  352:        this->getIdBase() + OPCODE_CS_START
        9:  353:    );
        9:  354:    this->m_cmdRegOut_OutputPort[0].invoke(
        9:  355:        this->getIdBase() + OPCODE_CS_STEP
        9:  356:    );
        9:  357:    this->m_cmdRegOut_OutputPort[0].invoke(
        9:  358:        this->getIdBase() + OPCODE_CS_AUTO
        9:  359:    );
        9:  360:    this->m_cmdRegOut_OutputPort[0].invoke(
        9:  361:        this->getIdBase() + OPCODE_CS_MANUAL
        9:  362:    );
        9:  363:  }
        -:  364:
        -:  365:  // ----------------------------------------------------------------------
        -:  366:  // Component construction, initialization, and destruction
        -:  367:  // ----------------------------------------------------------------------
        -:  368:
      213:  369:  CmdSequencerComponentBase ::
        -:  370:#if FW_OBJECT_NAMES == 1
        -:  371:    CmdSequencerComponentBase(const char* compName) :
      213:  372:      Fw::ActiveComponentBase(compName)
        -:  373:#else
        -:  374:    CmdSequencerComponentBase() :
        -:  375:      Fw::ActiveComponentBase()
        -:  376:#endif
        -:  377:  {
        -:  378:
        -:  379:  
        -:  380:  
      213:  381:  }
        -:  382:
      213:  383:  void CmdSequencerComponentBase ::
        -:  384:    init(
        -:  385:        NATIVE_INT_TYPE queueDepth,
        -:  386:        NATIVE_INT_TYPE instance
        -:  387:    )
        -:  388:  {
        -:  389:
        -:  390:    // Initialize base class
      213:  391:    Fw::ActiveComponentBase::init(instance);
        -:  392:
        -:  393:    // Connect input port pingIn
      639:  394:    for (
      213:  395:        NATIVE_INT_TYPE port = 0;
      426:  396:        port < this->getNum_pingIn_InputPorts();
        -:  397:        port++
        -:  398:    ) {
        -:  399:
      213:  400:      this->m_pingIn_InputPort[port].init();
      213:  401:      this->m_pingIn_InputPort[port].addCallComp(
        -:  402:          this,
        -:  403:          m_p_pingIn_in
      213:  404:      );
      213:  405:      this->m_pingIn_InputPort[port].setPortNum(port);
        -:  406:
        -:  407:#if FW_OBJECT_NAMES == 1
        -:  408:      char portName[80];
      213:  409:      (void) snprintf(
        -:  410:          portName,
        -:  411:          sizeof(portName),
        -:  412:          "%s_pingIn_InputPort[%d]",
        -:  413:          this->m_objName,
        -:  414:          port
      213:  415:      );
      213:  416:      this->m_pingIn_InputPort[port].setObjName(portName);
        -:  417:#endif
        -:  418:
        -:  419:    }
        -:  420:
        -:  421:    // Connect input port cmdResponseIn
      639:  422:    for (
      213:  423:        NATIVE_INT_TYPE port = 0;
      426:  424:        port < this->getNum_cmdResponseIn_InputPorts();
        -:  425:        port++
        -:  426:    ) {
        -:  427:
      213:  428:      this->m_cmdResponseIn_InputPort[port].init();
      213:  429:      this->m_cmdResponseIn_InputPort[port].addCallComp(
        -:  430:          this,
        -:  431:          m_p_cmdResponseIn_in
      213:  432:      );
      213:  433:      this->m_cmdResponseIn_InputPort[port].setPortNum(port);
        -:  434:
        -:  435:#if FW_OBJECT_NAMES == 1
        -:  436:      char portName[80];
      213:  437:      (void) snprintf(
        -:  438:          portName,
        -:  439:          sizeof(portName),
        -:  440:          "%s_cmdResponseIn_InputPort[%d]",
        -:  441:          this->m_objName,
        -:  442:          port
      213:  443:      );
      213:  444:      this->m_cmdResponseIn_InputPort[port].setObjName(portName);
        -:  445:#endif
        -:  446:
        -:  447:    }
        -:  448:
        -:  449:    // Connect input port cmdIn
      639:  450:    for (
      213:  451:        NATIVE_INT_TYPE port = 0;
      426:  452:        port < this->getNum_cmdIn_InputPorts();
        -:  453:        port++
        -:  454:    ) {
        -:  455:
      213:  456:      this->m_cmdIn_InputPort[port].init();
      213:  457:      this->m_cmdIn_InputPort[port].addCallComp(
        -:  458:          this,
        -:  459:          m_p_cmdIn_in
      213:  460:      );
      213:  461:      this->m_cmdIn_InputPort[port].setPortNum(port);
        -:  462:
        -:  463:#if FW_OBJECT_NAMES == 1
        -:  464:      char portName[80];
      213:  465:      (void) snprintf(
        -:  466:          portName,
        -:  467:          sizeof(portName),
        -:  468:          "%s_cmdIn_InputPort[%d]",
        -:  469:          this->m_objName,
        -:  470:          port
      213:  471:      );
      213:  472:      this->m_cmdIn_InputPort[port].setObjName(portName);
        -:  473:#endif
        -:  474:
        -:  475:    }
        -:  476:
        -:  477:    // Connect input port schedIn
      639:  478:    for (
      213:  479:        NATIVE_INT_TYPE port = 0;
      426:  480:        port < this->getNum_schedIn_InputPorts();
        -:  481:        port++
        -:  482:    ) {
        -:  483:
      213:  484:      this->m_schedIn_InputPort[port].init();
      213:  485:      this->m_schedIn_InputPort[port].addCallComp(
        -:  486:          this,
        -:  487:          m_p_schedIn_in
      213:  488:      );
      213:  489:      this->m_schedIn_InputPort[port].setPortNum(port);
        -:  490:
        -:  491:#if FW_OBJECT_NAMES == 1
        -:  492:      char portName[80];
      213:  493:      (void) snprintf(
        -:  494:          portName,
        -:  495:          sizeof(portName),
        -:  496:          "%s_schedIn_InputPort[%d]",
        -:  497:          this->m_objName,
        -:  498:          port
      213:  499:      );
      213:  500:      this->m_schedIn_InputPort[port].setObjName(portName);
        -:  501:#endif
        -:  502:
        -:  503:    }
        -:  504:
        -:  505:    // Connect input port seqRunIn
      639:  506:    for (
      213:  507:        NATIVE_INT_TYPE port = 0;
      426:  508:        port < this->getNum_seqRunIn_InputPorts();
        -:  509:        port++
        -:  510:    ) {
        -:  511:
      213:  512:      this->m_seqRunIn_InputPort[port].init();
      213:  513:      this->m_seqRunIn_InputPort[port].addCallComp(
        -:  514:          this,
        -:  515:          m_p_seqRunIn_in
      213:  516:      );
      213:  517:      this->m_seqRunIn_InputPort[port].setPortNum(port);
        -:  518:
        -:  519:#if FW_OBJECT_NAMES == 1
        -:  520:      char portName[80];
      213:  521:      (void) snprintf(
        -:  522:          portName,
        -:  523:          sizeof(portName),
        -:  524:          "%s_seqRunIn_InputPort[%d]",
        -:  525:          this->m_objName,
        -:  526:          port
      213:  527:      );
      213:  528:      this->m_seqRunIn_InputPort[port].setObjName(portName);
        -:  529:#endif
        -:  530:
        -:  531:    }
        -:  532:
        -:  533:    // Initialize output port cmdRegOut
      639:  534:    for (
      213:  535:        NATIVE_INT_TYPE port = 0;
      426:  536:        port < this->getNum_cmdRegOut_OutputPorts();
        -:  537:        port++
        -:  538:    ) {
      213:  539:      this->m_cmdRegOut_OutputPort[port].init();
        -:  540:
        -:  541:#if FW_OBJECT_NAMES == 1
        -:  542:      char portName[80];
      213:  543:      (void) snprintf(
        -:  544:          portName,
        -:  545:          sizeof(portName),
        -:  546:          "%s_cmdRegOut_OutputPort[%d]",
        -:  547:          this->m_objName,
        -:  548:          port
      213:  549:      );
      213:  550:      this->m_cmdRegOut_OutputPort[port].setObjName(portName);
        -:  551:#endif
        -:  552:
        -:  553:    }
        -:  554:
        -:  555:    // Initialize output port LogText
        -:  556:#if FW_ENABLE_TEXT_LOGGING == 1
      639:  557:    for (
      213:  558:        NATIVE_INT_TYPE port = 0;
      426:  559:        port < this->getNum_LogText_OutputPorts();
        -:  560:        port++
        -:  561:    ) {
      213:  562:      this->m_LogText_OutputPort[port].init();
        -:  563:
        -:  564:#if FW_OBJECT_NAMES == 1
        -:  565:      char portName[80];
      213:  566:      (void) snprintf(
        -:  567:          portName,
        -:  568:          sizeof(portName),
        -:  569:          "%s_LogText_OutputPort[%d]",
        -:  570:          this->m_objName,
        -:  571:          port
      213:  572:      );
      213:  573:      this->m_LogText_OutputPort[port].setObjName(portName);
        -:  574:#endif
        -:  575:
        -:  576:    }
        -:  577:#endif
        -:  578:
        -:  579:    // Initialize output port tlmOut
      639:  580:    for (
      213:  581:        NATIVE_INT_TYPE port = 0;
      426:  582:        port < this->getNum_tlmOut_OutputPorts();
        -:  583:        port++
        -:  584:    ) {
      213:  585:      this->m_tlmOut_OutputPort[port].init();
        -:  586:
        -:  587:#if FW_OBJECT_NAMES == 1
        -:  588:      char portName[80];
      213:  589:      (void) snprintf(
        -:  590:          portName,
        -:  591:          sizeof(portName),
        -:  592:          "%s_tlmOut_OutputPort[%d]",
        -:  593:          this->m_objName,
        -:  594:          port
      213:  595:      );
      213:  596:      this->m_tlmOut_OutputPort[port].setObjName(portName);
        -:  597:#endif
        -:  598:
        -:  599:    }
        -:  600:
        -:  601:    // Initialize output port cmdResponseOut
      639:  602:    for (
      213:  603:        NATIVE_INT_TYPE port = 0;
      426:  604:        port < this->getNum_cmdResponseOut_OutputPorts();
        -:  605:        port++
        -:  606:    ) {
      213:  607:      this->m_cmdResponseOut_OutputPort[port].init();
        -:  608:
        -:  609:#if FW_OBJECT_NAMES == 1
        -:  610:      char portName[80];
      213:  611:      (void) snprintf(
        -:  612:          portName,
        -:  613:          sizeof(portName),
        -:  614:          "%s_cmdResponseOut_OutputPort[%d]",
        -:  615:          this->m_objName,
        -:  616:          port
      213:  617:      );
      213:  618:      this->m_cmdResponseOut_OutputPort[port].setObjName(portName);
        -:  619:#endif
        -:  620:
        -:  621:    }
        -:  622:
        -:  623:    // Initialize output port timeCaller
      639:  624:    for (
      213:  625:        NATIVE_INT_TYPE port = 0;
      426:  626:        port < this->getNum_timeCaller_OutputPorts();
        -:  627:        port++
        -:  628:    ) {
      213:  629:      this->m_timeCaller_OutputPort[port].init();
        -:  630:
        -:  631:#if FW_OBJECT_NAMES == 1
        -:  632:      char portName[80];
      213:  633:      (void) snprintf(
        -:  634:          portName,
        -:  635:          sizeof(portName),
        -:  636:          "%s_timeCaller_OutputPort[%d]",
        -:  637:          this->m_objName,
        -:  638:          port
      213:  639:      );
      213:  640:      this->m_timeCaller_OutputPort[port].setObjName(portName);
        -:  641:#endif
        -:  642:
        -:  643:    }
        -:  644:
        -:  645:    // Initialize output port comCmdOut
      639:  646:    for (
      213:  647:        NATIVE_INT_TYPE port = 0;
      426:  648:        port < this->getNum_comCmdOut_OutputPorts();
        -:  649:        port++
        -:  650:    ) {
      213:  651:      this->m_comCmdOut_OutputPort[port].init();
        -:  652:
        -:  653:#if FW_OBJECT_NAMES == 1
        -:  654:      char portName[80];
      213:  655:      (void) snprintf(
        -:  656:          portName,
        -:  657:          sizeof(portName),
        -:  658:          "%s_comCmdOut_OutputPort[%d]",
        -:  659:          this->m_objName,
        -:  660:          port
      213:  661:      );
      213:  662:      this->m_comCmdOut_OutputPort[port].setObjName(portName);
        -:  663:#endif
        -:  664:
        -:  665:    }
        -:  666:
        -:  667:    // Initialize output port pingOut
      639:  668:    for (
      213:  669:        NATIVE_INT_TYPE port = 0;
      426:  670:        port < this->getNum_pingOut_OutputPorts();
        -:  671:        port++
        -:  672:    ) {
      213:  673:      this->m_pingOut_OutputPort[port].init();
        -:  674:
        -:  675:#if FW_OBJECT_NAMES == 1
        -:  676:      char portName[80];
      213:  677:      (void) snprintf(
        -:  678:          portName,
        -:  679:          sizeof(portName),
        -:  680:          "%s_pingOut_OutputPort[%d]",
        -:  681:          this->m_objName,
        -:  682:          port
      213:  683:      );
      213:  684:      this->m_pingOut_OutputPort[port].setObjName(portName);
        -:  685:#endif
        -:  686:
        -:  687:    }
        -:  688:
        -:  689:    // Initialize output port logOut
      639:  690:    for (
      213:  691:        NATIVE_INT_TYPE port = 0;
      426:  692:        port < this->getNum_logOut_OutputPorts();
        -:  693:        port++
        -:  694:    ) {
      213:  695:      this->m_logOut_OutputPort[port].init();
        -:  696:
        -:  697:#if FW_OBJECT_NAMES == 1
        -:  698:      char portName[80];
      213:  699:      (void) snprintf(
        -:  700:          portName,
        -:  701:          sizeof(portName),
        -:  702:          "%s_logOut_OutputPort[%d]",
        -:  703:          this->m_objName,
        -:  704:          port
      213:  705:      );
      213:  706:      this->m_logOut_OutputPort[port].setObjName(portName);
        -:  707:#endif
        -:  708:
        -:  709:    }
        -:  710:
        -:  711:    // Initialize output port seqDone
      639:  712:    for (
      213:  713:        NATIVE_INT_TYPE port = 0;
      426:  714:        port < this->getNum_seqDone_OutputPorts();
        -:  715:        port++
        -:  716:    ) {
      213:  717:      this->m_seqDone_OutputPort[port].init();
        -:  718:
        -:  719:#if FW_OBJECT_NAMES == 1
        -:  720:      char portName[80];
      213:  721:      (void) snprintf(
        -:  722:          portName,
        -:  723:          sizeof(portName),
        -:  724:          "%s_seqDone_OutputPort[%d]",
        -:  725:          this->m_objName,
        -:  726:          port
      213:  727:      );
      213:  728:      this->m_seqDone_OutputPort[port].setObjName(portName);
        -:  729:#endif
        -:  730:
        -:  731:    }
        -:  732:
        -:  733:    Os::Queue::QueueStatus qStat =
      213:  734:    this->createQueue(
        -:  735:        queueDepth,
        -:  736:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
      213:  737:    );
        -:  738:    FW_ASSERT(
        -:  739:        Os::Queue::QUEUE_OK == qStat,
        -:  740:        static_cast<AssertArg>(qStat)
      213:  741:    );
        -:  742:
      213:  743:  }
        -:  744:
      213:  745:  CmdSequencerComponentBase::
      213:  746:    ~CmdSequencerComponentBase() {
        -:  747:
      213:  748:  }
        -:  749:
        -:  750:  // ----------------------------------------------------------------------
        -:  751:  // Invocation functions for output ports
        -:  752:  // ----------------------------------------------------------------------
        -:  753:
      360:  754:  void CmdSequencerComponentBase ::
        -:  755:    comCmdOut_out(
        -:  756:        NATIVE_INT_TYPE portNum,
        -:  757:        Fw::ComBuffer &data, U32 context
        -:  758:    )
        -:  759:  {
      360:  760:    FW_ASSERT(portNum < this->getNum_comCmdOut_OutputPorts(),static_cast<AssertArg>(portNum));
      360:  761:    this->m_comCmdOut_OutputPort[portNum].invoke(data, context);
      360:  762:  }
        -:  763:
        9:  764:  void CmdSequencerComponentBase ::
        -:  765:    pingOut_out(
        -:  766:        NATIVE_INT_TYPE portNum,
        -:  767:        U32 key
        -:  768:    )
        -:  769:  {
        9:  770:    FW_ASSERT(portNum < this->getNum_pingOut_OutputPorts(),static_cast<AssertArg>(portNum));
        9:  771:    this->m_pingOut_OutputPort[portNum].invoke(key);
        9:  772:  }
        -:  773:
      117:  774:  void CmdSequencerComponentBase ::
        -:  775:    seqDone_out(
        -:  776:        NATIVE_INT_TYPE portNum,
        -:  777:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -:  778:    )
        -:  779:  {
      117:  780:    FW_ASSERT(portNum < this->getNum_seqDone_OutputPorts(),static_cast<AssertArg>(portNum));
      117:  781:    this->m_seqDone_OutputPort[portNum].invoke(opCode, cmdSeq, response);
      117:  782:  }
        -:  783:
        -:  784:  // ----------------------------------------------------------------------
        -:  785:  // Getters for numbers of ports
        -:  786:  // ----------------------------------------------------------------------
        -:  787:
      639:  788:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  789:    getNum_cmdRegOut_OutputPorts(void)
        -:  790:  {
      639:  791:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  792:        this->m_cmdRegOut_OutputPort
        -:  793:    );
        -:  794:  }
        -:  795:
        -:  796:#if FW_ENABLE_TEXT_LOGGING == 1
      639:  797:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  798:    getNum_LogText_OutputPorts(void)
        -:  799:  {
      639:  800:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  801:        this->m_LogText_OutputPort
        -:  802:    );
        -:  803:  }
        -:  804:#endif
        -:  805:
      648:  806:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  807:    getNum_pingIn_InputPorts(void)
        -:  808:  {
      648:  809:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  810:        this->m_pingIn_InputPort
        -:  811:    );
        -:  812:  }
        -:  813:
      639:  814:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  815:    getNum_tlmOut_OutputPorts(void)
        -:  816:  {
      639:  817:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  818:        this->m_tlmOut_OutputPort
        -:  819:    );
        -:  820:  }
        -:  821:
      639:  822:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  823:    getNum_cmdResponseOut_OutputPorts(void)
        -:  824:  {
      639:  825:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  826:        this->m_cmdResponseOut_OutputPort
        -:  827:    );
        -:  828:  }
        -:  829:
      639:  830:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  831:    getNum_timeCaller_OutputPorts(void)
        -:  832:  {
      639:  833:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  834:        this->m_timeCaller_OutputPort
        -:  835:    );
        -:  836:  }
        -:  837:
      999:  838:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  839:    getNum_comCmdOut_OutputPorts(void)
        -:  840:  {
      999:  841:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  842:        this->m_comCmdOut_OutputPort
        -:  843:    );
        -:  844:  }
        -:  845:
      648:  846:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  847:    getNum_pingOut_OutputPorts(void)
        -:  848:  {
      648:  849:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  850:        this->m_pingOut_OutputPort
        -:  851:    );
        -:  852:  }
        -:  853:
      981:  854:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  855:    getNum_cmdResponseIn_InputPorts(void)
        -:  856:  {
      981:  857:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  858:        this->m_cmdResponseIn_InputPort
        -:  859:    );
        -:  860:  }
        -:  861:
      639:  862:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  863:    getNum_cmdIn_InputPorts(void)
        -:  864:  {
      639:  865:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  866:        this->m_cmdIn_InputPort
        -:  867:    );
        -:  868:  }
        -:  869:
      747:  870:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  871:    getNum_schedIn_InputPorts(void)
        -:  872:  {
      747:  873:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  874:        this->m_schedIn_InputPort
        -:  875:    );
        -:  876:  }
        -:  877:
      666:  878:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  879:    getNum_seqRunIn_InputPorts(void)
        -:  880:  {
      666:  881:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  882:        this->m_seqRunIn_InputPort
        -:  883:    );
        -:  884:  }
        -:  885:
      639:  886:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  887:    getNum_logOut_OutputPorts(void)
        -:  888:  {
      639:  889:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  890:        this->m_logOut_OutputPort
        -:  891:    );
        -:  892:  }
        -:  893:
      855:  894:  NATIVE_INT_TYPE CmdSequencerComponentBase ::
        -:  895:    getNum_seqDone_OutputPorts(void)
        -:  896:  {
      855:  897:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  898:        this->m_seqDone_OutputPort
        -:  899:    );
        -:  900:  }
        -:  901:
        -:  902:  // ----------------------------------------------------------------------
        -:  903:  // Port connection status queries
        -:  904:  // ----------------------------------------------------------------------
        -:  905:
    #####:  906:  bool CmdSequencerComponentBase ::
        -:  907:    isConnected_cmdRegOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  908:  {
    #####:  909:     FW_ASSERT(
        -:  910:        portNum < this->getNum_cmdRegOut_OutputPorts(),
        -:  911:        static_cast<AssertArg>(portNum)
    #####:  912:     );
    #####:  913:     return this->m_cmdRegOut_OutputPort[portNum].isConnected();
        -:  914:  }
        -:  915:
        -:  916:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  917:  bool CmdSequencerComponentBase ::
        -:  918:    isConnected_LogText_OutputPort(NATIVE_INT_TYPE portNum)
        -:  919:  {
    #####:  920:     FW_ASSERT(
        -:  921:        portNum < this->getNum_LogText_OutputPorts(),
        -:  922:        static_cast<AssertArg>(portNum)
    #####:  923:     );
    #####:  924:     return this->m_LogText_OutputPort[portNum].isConnected();
        -:  925:  }
        -:  926:#endif
        -:  927:
    #####:  928:  bool CmdSequencerComponentBase ::
        -:  929:    isConnected_tlmOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  930:  {
    #####:  931:     FW_ASSERT(
        -:  932:        portNum < this->getNum_tlmOut_OutputPorts(),
        -:  933:        static_cast<AssertArg>(portNum)
    #####:  934:     );
    #####:  935:     return this->m_tlmOut_OutputPort[portNum].isConnected();
        -:  936:  }
        -:  937:
    #####:  938:  bool CmdSequencerComponentBase ::
        -:  939:    isConnected_cmdResponseOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  940:  {
    #####:  941:     FW_ASSERT(
        -:  942:        portNum < this->getNum_cmdResponseOut_OutputPorts(),
        -:  943:        static_cast<AssertArg>(portNum)
    #####:  944:     );
    #####:  945:     return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
        -:  946:  }
        -:  947:
    #####:  948:  bool CmdSequencerComponentBase ::
        -:  949:    isConnected_timeCaller_OutputPort(NATIVE_INT_TYPE portNum)
        -:  950:  {
    #####:  951:     FW_ASSERT(
        -:  952:        portNum < this->getNum_timeCaller_OutputPorts(),
        -:  953:        static_cast<AssertArg>(portNum)
    #####:  954:     );
    #####:  955:     return this->m_timeCaller_OutputPort[portNum].isConnected();
        -:  956:  }
        -:  957:
    #####:  958:  bool CmdSequencerComponentBase ::
        -:  959:    isConnected_comCmdOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  960:  {
    #####:  961:     FW_ASSERT(
        -:  962:        portNum < this->getNum_comCmdOut_OutputPorts(),
        -:  963:        static_cast<AssertArg>(portNum)
    #####:  964:     );
    #####:  965:     return this->m_comCmdOut_OutputPort[portNum].isConnected();
        -:  966:  }
        -:  967:
    #####:  968:  bool CmdSequencerComponentBase ::
        -:  969:    isConnected_pingOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  970:  {
    #####:  971:     FW_ASSERT(
        -:  972:        portNum < this->getNum_pingOut_OutputPorts(),
        -:  973:        static_cast<AssertArg>(portNum)
    #####:  974:     );
    #####:  975:     return this->m_pingOut_OutputPort[portNum].isConnected();
        -:  976:  }
        -:  977:
    #####:  978:  bool CmdSequencerComponentBase ::
        -:  979:    isConnected_logOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  980:  {
    #####:  981:     FW_ASSERT(
        -:  982:        portNum < this->getNum_logOut_OutputPorts(),
        -:  983:        static_cast<AssertArg>(portNum)
    #####:  984:     );
    #####:  985:     return this->m_logOut_OutputPort[portNum].isConnected();
        -:  986:  }
        -:  987:
       99:  988:  bool CmdSequencerComponentBase ::
        -:  989:    isConnected_seqDone_OutputPort(NATIVE_INT_TYPE portNum)
        -:  990:  {
       99:  991:     FW_ASSERT(
        -:  992:        portNum < this->getNum_seqDone_OutputPorts(),
        -:  993:        static_cast<AssertArg>(portNum)
       99:  994:     );
       99:  995:     return this->m_seqDone_OutputPort[portNum].isConnected();
        -:  996:  }
        -:  997:
        -:  998:  // ----------------------------------------------------------------------
        -:  999:  // Calls for messages received on command input ports
        -: 1000:  // ----------------------------------------------------------------------
        -: 1001:
      601: 1002:  void CmdSequencerComponentBase ::
        -: 1003:    m_p_cmdIn_in(
        -: 1004:        Fw::PassiveComponentBase* callComp,
        -: 1005:        NATIVE_INT_TYPE portNum,
        -: 1006:        FwOpcodeType opCode,
        -: 1007:        U32 cmdSeq,
        -: 1008:        Fw::CmdArgBuffer &args
        -: 1009:    )
        -: 1010:  {
        -: 1011:
        -: 1012:    // Select base class function based on opcode
      601: 1013:    FW_ASSERT(callComp);
        -: 1014:    CmdSequencerComponentBase* compPtr =
      601: 1015:      (CmdSequencerComponentBase*) callComp;
        -: 1016:
      601: 1017:    const U32 idBase = callComp->getIdBase();
      601: 1018:    FW_ASSERT(opCode >= idBase, opCode, idBase);
      601: 1019:    switch (opCode - idBase) {
        -: 1020:
        -: 1021:      case OPCODE_CS_RUN: /*!< Run a command sequence file */
        -: 1022:        compPtr->CS_Run_cmdHandlerBase(
        -: 1023:            opCode,
        -: 1024:            cmdSeq,
        -: 1025:            args
      190: 1026:        );
      190: 1027:        break;
        -: 1028:        
        -: 1029:      case OPCODE_CS_VALIDATE: /*!< Validate a command sequence file */
        -: 1030:        compPtr->CS_Validate_cmdHandlerBase(
        -: 1031:            opCode,
        -: 1032:            cmdSeq,
        -: 1033:            args
      231: 1034:        );
      231: 1035:        break;
        -: 1036:        
        -: 1037:      case OPCODE_CS_CANCEL: /*!< Cancel a command sequence */
        -: 1038:        compPtr->CS_Cancel_cmdHandlerBase(
        -: 1039:            opCode,
        -: 1040:            cmdSeq,
        -: 1041:            args
       18: 1042:        );
       18: 1043:        break;
        -: 1044:        
        -: 1045:      case OPCODE_CS_START: /*!< Start running a command sequence */
        -: 1046:        compPtr->CS_Start_cmdHandlerBase(
        -: 1047:            opCode,
        -: 1048:            cmdSeq,
        -: 1049:            args
       36: 1050:        );
       36: 1051:        break;
        -: 1052:        
        -: 1053:      case OPCODE_CS_STEP: /*!< Perform one step in a command sequence. Valid only if CmdSequencer is in MANUAL run mode. */
        -: 1054:        compPtr->CS_Step_cmdHandlerBase(
        -: 1055:            opCode,
        -: 1056:            cmdSeq,
        -: 1057:            args
       81: 1058:        );
       81: 1059:        break;
        -: 1060:        
        -: 1061:      case OPCODE_CS_AUTO: /*!< Set the run mode to AUTO. */
        -: 1062:        compPtr->CS_Auto_cmdHandlerBase(
        -: 1063:            opCode,
        -: 1064:            cmdSeq,
        -: 1065:            args
       18: 1066:        );
       18: 1067:        break;
        -: 1068:        
        -: 1069:      case OPCODE_CS_MANUAL: /*!< Set the run mode to MANUAL. */
        -: 1070:        compPtr->CS_Manual_cmdHandlerBase(
        -: 1071:            opCode,
        -: 1072:            cmdSeq,
        -: 1073:            args
       27: 1074:        );
       27: 1075:        break;
        -: 1076:        
        -: 1077:      default: {
        -: 1078:        compPtr->cmdResponse_out(
        -: 1079:            opCode,cmdSeq,
        -: 1080:            Fw::COMMAND_INVALID_OPCODE
    #####: 1081:        );
    #####: 1082:        break;
        -: 1083:      }
        -: 1084:
        -: 1085:    }
        -: 1086:
      601: 1087:  }
        -: 1088:
      601: 1089:  void CmdSequencerComponentBase ::
        -: 1090:    cmdResponse_out(
        -: 1091:        FwOpcodeType opCode,
        -: 1092:        U32 cmdSeq,
        -: 1093:        Fw::CommandResponse response
        -: 1094:    )
        -: 1095:  {
      601: 1096:    FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
      601: 1097:    this->m_cmdResponseOut_OutputPort[0].invoke(opCode,cmdSeq,response);
      601: 1098:  }
        -: 1099:
        -: 1100:  // ----------------------------------------------------------------------
        -: 1101:  // Base class command functions
        -: 1102:  // ----------------------------------------------------------------------
        -: 1103:
      190: 1104:  void CmdSequencerComponentBase ::
        -: 1105:    CS_Run_cmdHandlerBase(
        -: 1106:        FwOpcodeType opCode,
        -: 1107:        U32 cmdSeq,
        -: 1108:        Fw::CmdArgBuffer &args
        -: 1109:    )
        -: 1110:  {
        -: 1111:
        -: 1112:    // Call pre-message hook
      190: 1113:    this->CS_Run_preMsgHook(opCode,cmdSeq);
        -: 1114:
        -: 1115:    // Defer deserializing arguments to the message dispatcher
        -: 1116:    // to avoid deserializing and reserializing just for IPC
      380: 1117:    ComponentIpcSerializableBuffer msg;
      190: 1118:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1119:
        -: 1120:    // Serialize for IPC
      190: 1121:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_RUN);
        -: 1122:    FW_ASSERT (
        -: 1123:        _status == Fw::FW_SERIALIZE_OK,
        -: 1124:        static_cast<AssertArg>(_status)
      190: 1125:        );
        -: 1126:
        -: 1127:    // Fake port number to make message dequeue work
      190: 1128:    NATIVE_INT_TYPE port = 0;
      190: 1129:    _status = msg.serialize(port);
        -: 1130:    FW_ASSERT (
        -: 1131:        _status == Fw::FW_SERIALIZE_OK,
        -: 1132:        static_cast<AssertArg>(_status)
      190: 1133:    );
        -: 1134:
      190: 1135:    _status = msg.serialize(opCode);
        -: 1136:    FW_ASSERT (
        -: 1137:        _status == Fw::FW_SERIALIZE_OK,
        -: 1138:        static_cast<AssertArg>(_status)
      190: 1139:    );
        -: 1140:
      190: 1141:    _status = msg.serialize(cmdSeq);
        -: 1142:    FW_ASSERT (
        -: 1143:        _status == Fw::FW_SERIALIZE_OK,
        -: 1144:        static_cast<AssertArg>(_status)
      190: 1145:    );
        -: 1146:
      190: 1147:    _status = msg.serialize(args);
        -: 1148:    FW_ASSERT (
        -: 1149:        _status == Fw::FW_SERIALIZE_OK,
        -: 1150:        static_cast<AssertArg>(_status)
      190: 1151:    );
        -: 1152:    
        -: 1153:    // send message
        -: 1154:    Os::Queue::QueueBlocking _block = 
      190: 1155:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1156:    Os::Queue::QueueStatus qStatus =
      190: 1157:      this->m_queue.send(msg, 0,_block);
        -: 1158:    FW_ASSERT(
        -: 1159:        qStatus == Os::Queue::QUEUE_OK,
        -: 1160:        static_cast<AssertArg>(qStatus)
      190: 1161:    );    
        -: 1162:
      190: 1163:  }
        -: 1164:
      190: 1165:  void CmdSequencerComponentBase::
        -: 1166:    CS_Run_preMsgHook(
        -: 1167:        FwOpcodeType opCode,
        -: 1168:        U32 cmdSeq
        -: 1169:    )
        -: 1170:  {
        -: 1171:    // Defaults to no-op; can be overridden
      190: 1172:  }
        -: 1173:
      231: 1174:  void CmdSequencerComponentBase ::
        -: 1175:    CS_Validate_cmdHandlerBase(
        -: 1176:        FwOpcodeType opCode,
        -: 1177:        U32 cmdSeq,
        -: 1178:        Fw::CmdArgBuffer &args
        -: 1179:    )
        -: 1180:  {
        -: 1181:
        -: 1182:    // Call pre-message hook
      231: 1183:    this->CS_Validate_preMsgHook(opCode,cmdSeq);
        -: 1184:
        -: 1185:    // Defer deserializing arguments to the message dispatcher
        -: 1186:    // to avoid deserializing and reserializing just for IPC
      462: 1187:    ComponentIpcSerializableBuffer msg;
      231: 1188:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1189:
        -: 1190:    // Serialize for IPC
      231: 1191:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_VALIDATE);
        -: 1192:    FW_ASSERT (
        -: 1193:        _status == Fw::FW_SERIALIZE_OK,
        -: 1194:        static_cast<AssertArg>(_status)
      231: 1195:        );
        -: 1196:
        -: 1197:    // Fake port number to make message dequeue work
      231: 1198:    NATIVE_INT_TYPE port = 0;
      231: 1199:    _status = msg.serialize(port);
        -: 1200:    FW_ASSERT (
        -: 1201:        _status == Fw::FW_SERIALIZE_OK,
        -: 1202:        static_cast<AssertArg>(_status)
      231: 1203:    );
        -: 1204:
      231: 1205:    _status = msg.serialize(opCode);
        -: 1206:    FW_ASSERT (
        -: 1207:        _status == Fw::FW_SERIALIZE_OK,
        -: 1208:        static_cast<AssertArg>(_status)
      231: 1209:    );
        -: 1210:
      231: 1211:    _status = msg.serialize(cmdSeq);
        -: 1212:    FW_ASSERT (
        -: 1213:        _status == Fw::FW_SERIALIZE_OK,
        -: 1214:        static_cast<AssertArg>(_status)
      231: 1215:    );
        -: 1216:
      231: 1217:    _status = msg.serialize(args);
        -: 1218:    FW_ASSERT (
        -: 1219:        _status == Fw::FW_SERIALIZE_OK,
        -: 1220:        static_cast<AssertArg>(_status)
      231: 1221:    );
        -: 1222:    
        -: 1223:    // send message
        -: 1224:    Os::Queue::QueueBlocking _block = 
      231: 1225:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1226:    Os::Queue::QueueStatus qStatus =
      231: 1227:      this->m_queue.send(msg, 0,_block);
        -: 1228:    FW_ASSERT(
        -: 1229:        qStatus == Os::Queue::QUEUE_OK,
        -: 1230:        static_cast<AssertArg>(qStatus)
      231: 1231:    );    
        -: 1232:
      231: 1233:  }
        -: 1234:
      231: 1235:  void CmdSequencerComponentBase::
        -: 1236:    CS_Validate_preMsgHook(
        -: 1237:        FwOpcodeType opCode,
        -: 1238:        U32 cmdSeq
        -: 1239:    )
        -: 1240:  {
        -: 1241:    // Defaults to no-op; can be overridden
      231: 1242:  }
        -: 1243:
       18: 1244:  void CmdSequencerComponentBase ::
        -: 1245:    CS_Cancel_cmdHandlerBase(
        -: 1246:        FwOpcodeType opCode,
        -: 1247:        U32 cmdSeq,
        -: 1248:        Fw::CmdArgBuffer &args
        -: 1249:    )
        -: 1250:  {
        -: 1251:
        -: 1252:    // Call pre-message hook
       18: 1253:    this->CS_Cancel_preMsgHook(opCode,cmdSeq);
        -: 1254:
        -: 1255:    // Defer deserializing arguments to the message dispatcher
        -: 1256:    // to avoid deserializing and reserializing just for IPC
       36: 1257:    ComponentIpcSerializableBuffer msg;
       18: 1258:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1259:
        -: 1260:    // Serialize for IPC
       18: 1261:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_CANCEL);
        -: 1262:    FW_ASSERT (
        -: 1263:        _status == Fw::FW_SERIALIZE_OK,
        -: 1264:        static_cast<AssertArg>(_status)
       18: 1265:        );
        -: 1266:
        -: 1267:    // Fake port number to make message dequeue work
       18: 1268:    NATIVE_INT_TYPE port = 0;
       18: 1269:    _status = msg.serialize(port);
        -: 1270:    FW_ASSERT (
        -: 1271:        _status == Fw::FW_SERIALIZE_OK,
        -: 1272:        static_cast<AssertArg>(_status)
       18: 1273:    );
        -: 1274:
       18: 1275:    _status = msg.serialize(opCode);
        -: 1276:    FW_ASSERT (
        -: 1277:        _status == Fw::FW_SERIALIZE_OK,
        -: 1278:        static_cast<AssertArg>(_status)
       18: 1279:    );
        -: 1280:
       18: 1281:    _status = msg.serialize(cmdSeq);
        -: 1282:    FW_ASSERT (
        -: 1283:        _status == Fw::FW_SERIALIZE_OK,
        -: 1284:        static_cast<AssertArg>(_status)
       18: 1285:    );
        -: 1286:
       18: 1287:    _status = msg.serialize(args);
        -: 1288:    FW_ASSERT (
        -: 1289:        _status == Fw::FW_SERIALIZE_OK,
        -: 1290:        static_cast<AssertArg>(_status)
       18: 1291:    );
        -: 1292:    
        -: 1293:    // send message
        -: 1294:    Os::Queue::QueueBlocking _block = 
       18: 1295:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1296:    Os::Queue::QueueStatus qStatus =
       18: 1297:      this->m_queue.send(msg, 0,_block);
        -: 1298:    FW_ASSERT(
        -: 1299:        qStatus == Os::Queue::QUEUE_OK,
        -: 1300:        static_cast<AssertArg>(qStatus)
       18: 1301:    );    
        -: 1302:
       18: 1303:  }
        -: 1304:
       18: 1305:  void CmdSequencerComponentBase::
        -: 1306:    CS_Cancel_preMsgHook(
        -: 1307:        FwOpcodeType opCode,
        -: 1308:        U32 cmdSeq
        -: 1309:    )
        -: 1310:  {
        -: 1311:    // Defaults to no-op; can be overridden
       18: 1312:  }
        -: 1313:
       36: 1314:  void CmdSequencerComponentBase ::
        -: 1315:    CS_Start_cmdHandlerBase(
        -: 1316:        FwOpcodeType opCode,
        -: 1317:        U32 cmdSeq,
        -: 1318:        Fw::CmdArgBuffer &args
        -: 1319:    )
        -: 1320:  {
        -: 1321:
        -: 1322:    // Call pre-message hook
       36: 1323:    this->CS_Start_preMsgHook(opCode,cmdSeq);
        -: 1324:
        -: 1325:    // Defer deserializing arguments to the message dispatcher
        -: 1326:    // to avoid deserializing and reserializing just for IPC
       72: 1327:    ComponentIpcSerializableBuffer msg;
       36: 1328:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1329:
        -: 1330:    // Serialize for IPC
       36: 1331:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_START);
        -: 1332:    FW_ASSERT (
        -: 1333:        _status == Fw::FW_SERIALIZE_OK,
        -: 1334:        static_cast<AssertArg>(_status)
       36: 1335:        );
        -: 1336:
        -: 1337:    // Fake port number to make message dequeue work
       36: 1338:    NATIVE_INT_TYPE port = 0;
       36: 1339:    _status = msg.serialize(port);
        -: 1340:    FW_ASSERT (
        -: 1341:        _status == Fw::FW_SERIALIZE_OK,
        -: 1342:        static_cast<AssertArg>(_status)
       36: 1343:    );
        -: 1344:
       36: 1345:    _status = msg.serialize(opCode);
        -: 1346:    FW_ASSERT (
        -: 1347:        _status == Fw::FW_SERIALIZE_OK,
        -: 1348:        static_cast<AssertArg>(_status)
       36: 1349:    );
        -: 1350:
       36: 1351:    _status = msg.serialize(cmdSeq);
        -: 1352:    FW_ASSERT (
        -: 1353:        _status == Fw::FW_SERIALIZE_OK,
        -: 1354:        static_cast<AssertArg>(_status)
       36: 1355:    );
        -: 1356:
       36: 1357:    _status = msg.serialize(args);
        -: 1358:    FW_ASSERT (
        -: 1359:        _status == Fw::FW_SERIALIZE_OK,
        -: 1360:        static_cast<AssertArg>(_status)
       36: 1361:    );
        -: 1362:    
        -: 1363:    // send message
        -: 1364:    Os::Queue::QueueBlocking _block = 
       36: 1365:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1366:    Os::Queue::QueueStatus qStatus =
       36: 1367:      this->m_queue.send(msg, 0,_block);
        -: 1368:    FW_ASSERT(
        -: 1369:        qStatus == Os::Queue::QUEUE_OK,
        -: 1370:        static_cast<AssertArg>(qStatus)
       36: 1371:    );    
        -: 1372:
       36: 1373:  }
        -: 1374:
       36: 1375:  void CmdSequencerComponentBase::
        -: 1376:    CS_Start_preMsgHook(
        -: 1377:        FwOpcodeType opCode,
        -: 1378:        U32 cmdSeq
        -: 1379:    )
        -: 1380:  {
        -: 1381:    // Defaults to no-op; can be overridden
       36: 1382:  }
        -: 1383:
       81: 1384:  void CmdSequencerComponentBase ::
        -: 1385:    CS_Step_cmdHandlerBase(
        -: 1386:        FwOpcodeType opCode,
        -: 1387:        U32 cmdSeq,
        -: 1388:        Fw::CmdArgBuffer &args
        -: 1389:    )
        -: 1390:  {
        -: 1391:
        -: 1392:    // Call pre-message hook
       81: 1393:    this->CS_Step_preMsgHook(opCode,cmdSeq);
        -: 1394:
        -: 1395:    // Defer deserializing arguments to the message dispatcher
        -: 1396:    // to avoid deserializing and reserializing just for IPC
      162: 1397:    ComponentIpcSerializableBuffer msg;
       81: 1398:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1399:
        -: 1400:    // Serialize for IPC
       81: 1401:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_STEP);
        -: 1402:    FW_ASSERT (
        -: 1403:        _status == Fw::FW_SERIALIZE_OK,
        -: 1404:        static_cast<AssertArg>(_status)
       81: 1405:        );
        -: 1406:
        -: 1407:    // Fake port number to make message dequeue work
       81: 1408:    NATIVE_INT_TYPE port = 0;
       81: 1409:    _status = msg.serialize(port);
        -: 1410:    FW_ASSERT (
        -: 1411:        _status == Fw::FW_SERIALIZE_OK,
        -: 1412:        static_cast<AssertArg>(_status)
       81: 1413:    );
        -: 1414:
       81: 1415:    _status = msg.serialize(opCode);
        -: 1416:    FW_ASSERT (
        -: 1417:        _status == Fw::FW_SERIALIZE_OK,
        -: 1418:        static_cast<AssertArg>(_status)
       81: 1419:    );
        -: 1420:
       81: 1421:    _status = msg.serialize(cmdSeq);
        -: 1422:    FW_ASSERT (
        -: 1423:        _status == Fw::FW_SERIALIZE_OK,
        -: 1424:        static_cast<AssertArg>(_status)
       81: 1425:    );
        -: 1426:
       81: 1427:    _status = msg.serialize(args);
        -: 1428:    FW_ASSERT (
        -: 1429:        _status == Fw::FW_SERIALIZE_OK,
        -: 1430:        static_cast<AssertArg>(_status)
       81: 1431:    );
        -: 1432:    
        -: 1433:    // send message
        -: 1434:    Os::Queue::QueueBlocking _block = 
       81: 1435:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1436:    Os::Queue::QueueStatus qStatus =
       81: 1437:      this->m_queue.send(msg, 0,_block);
        -: 1438:    FW_ASSERT(
        -: 1439:        qStatus == Os::Queue::QUEUE_OK,
        -: 1440:        static_cast<AssertArg>(qStatus)
       81: 1441:    );    
        -: 1442:
       81: 1443:  }
        -: 1444:
       81: 1445:  void CmdSequencerComponentBase::
        -: 1446:    CS_Step_preMsgHook(
        -: 1447:        FwOpcodeType opCode,
        -: 1448:        U32 cmdSeq
        -: 1449:    )
        -: 1450:  {
        -: 1451:    // Defaults to no-op; can be overridden
       81: 1452:  }
        -: 1453:
       18: 1454:  void CmdSequencerComponentBase ::
        -: 1455:    CS_Auto_cmdHandlerBase(
        -: 1456:        FwOpcodeType opCode,
        -: 1457:        U32 cmdSeq,
        -: 1458:        Fw::CmdArgBuffer &args
        -: 1459:    )
        -: 1460:  {
        -: 1461:
        -: 1462:    // Call pre-message hook
       18: 1463:    this->CS_Auto_preMsgHook(opCode,cmdSeq);
        -: 1464:
        -: 1465:    // Defer deserializing arguments to the message dispatcher
        -: 1466:    // to avoid deserializing and reserializing just for IPC
       36: 1467:    ComponentIpcSerializableBuffer msg;
       18: 1468:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1469:
        -: 1470:    // Serialize for IPC
       18: 1471:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_AUTO);
        -: 1472:    FW_ASSERT (
        -: 1473:        _status == Fw::FW_SERIALIZE_OK,
        -: 1474:        static_cast<AssertArg>(_status)
       18: 1475:        );
        -: 1476:
        -: 1477:    // Fake port number to make message dequeue work
       18: 1478:    NATIVE_INT_TYPE port = 0;
       18: 1479:    _status = msg.serialize(port);
        -: 1480:    FW_ASSERT (
        -: 1481:        _status == Fw::FW_SERIALIZE_OK,
        -: 1482:        static_cast<AssertArg>(_status)
       18: 1483:    );
        -: 1484:
       18: 1485:    _status = msg.serialize(opCode);
        -: 1486:    FW_ASSERT (
        -: 1487:        _status == Fw::FW_SERIALIZE_OK,
        -: 1488:        static_cast<AssertArg>(_status)
       18: 1489:    );
        -: 1490:
       18: 1491:    _status = msg.serialize(cmdSeq);
        -: 1492:    FW_ASSERT (
        -: 1493:        _status == Fw::FW_SERIALIZE_OK,
        -: 1494:        static_cast<AssertArg>(_status)
       18: 1495:    );
        -: 1496:
       18: 1497:    _status = msg.serialize(args);
        -: 1498:    FW_ASSERT (
        -: 1499:        _status == Fw::FW_SERIALIZE_OK,
        -: 1500:        static_cast<AssertArg>(_status)
       18: 1501:    );
        -: 1502:    
        -: 1503:    // send message
        -: 1504:    Os::Queue::QueueBlocking _block = 
       18: 1505:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1506:    Os::Queue::QueueStatus qStatus =
       18: 1507:      this->m_queue.send(msg, 0,_block);
        -: 1508:    FW_ASSERT(
        -: 1509:        qStatus == Os::Queue::QUEUE_OK,
        -: 1510:        static_cast<AssertArg>(qStatus)
       18: 1511:    );    
        -: 1512:
       18: 1513:  }
        -: 1514:
       18: 1515:  void CmdSequencerComponentBase::
        -: 1516:    CS_Auto_preMsgHook(
        -: 1517:        FwOpcodeType opCode,
        -: 1518:        U32 cmdSeq
        -: 1519:    )
        -: 1520:  {
        -: 1521:    // Defaults to no-op; can be overridden
       18: 1522:  }
        -: 1523:
       27: 1524:  void CmdSequencerComponentBase ::
        -: 1525:    CS_Manual_cmdHandlerBase(
        -: 1526:        FwOpcodeType opCode,
        -: 1527:        U32 cmdSeq,
        -: 1528:        Fw::CmdArgBuffer &args
        -: 1529:    )
        -: 1530:  {
        -: 1531:
        -: 1532:    // Call pre-message hook
       27: 1533:    this->CS_Manual_preMsgHook(opCode,cmdSeq);
        -: 1534:
        -: 1535:    // Defer deserializing arguments to the message dispatcher
        -: 1536:    // to avoid deserializing and reserializing just for IPC
       54: 1537:    ComponentIpcSerializableBuffer msg;
       27: 1538:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1539:
        -: 1540:    // Serialize for IPC
       27: 1541:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_CS_MANUAL);
        -: 1542:    FW_ASSERT (
        -: 1543:        _status == Fw::FW_SERIALIZE_OK,
        -: 1544:        static_cast<AssertArg>(_status)
       27: 1545:        );
        -: 1546:
        -: 1547:    // Fake port number to make message dequeue work
       27: 1548:    NATIVE_INT_TYPE port = 0;
       27: 1549:    _status = msg.serialize(port);
        -: 1550:    FW_ASSERT (
        -: 1551:        _status == Fw::FW_SERIALIZE_OK,
        -: 1552:        static_cast<AssertArg>(_status)
       27: 1553:    );
        -: 1554:
       27: 1555:    _status = msg.serialize(opCode);
        -: 1556:    FW_ASSERT (
        -: 1557:        _status == Fw::FW_SERIALIZE_OK,
        -: 1558:        static_cast<AssertArg>(_status)
       27: 1559:    );
        -: 1560:
       27: 1561:    _status = msg.serialize(cmdSeq);
        -: 1562:    FW_ASSERT (
        -: 1563:        _status == Fw::FW_SERIALIZE_OK,
        -: 1564:        static_cast<AssertArg>(_status)
       27: 1565:    );
        -: 1566:
       27: 1567:    _status = msg.serialize(args);
        -: 1568:    FW_ASSERT (
        -: 1569:        _status == Fw::FW_SERIALIZE_OK,
        -: 1570:        static_cast<AssertArg>(_status)
       27: 1571:    );
        -: 1572:    
        -: 1573:    // send message
        -: 1574:    Os::Queue::QueueBlocking _block = 
       27: 1575:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1576:    Os::Queue::QueueStatus qStatus =
       27: 1577:      this->m_queue.send(msg, 0,_block);
        -: 1578:    FW_ASSERT(
        -: 1579:        qStatus == Os::Queue::QUEUE_OK,
        -: 1580:        static_cast<AssertArg>(qStatus)
       27: 1581:    );    
        -: 1582:
       27: 1583:  }
        -: 1584:
       27: 1585:  void CmdSequencerComponentBase::
        -: 1586:    CS_Manual_preMsgHook(
        -: 1587:        FwOpcodeType opCode,
        -: 1588:        U32 cmdSeq
        -: 1589:    )
        -: 1590:  {
        -: 1591:    // Defaults to no-op; can be overridden
       27: 1592:  }
        -: 1593:
        -: 1594:  // ----------------------------------------------------------------------
        -: 1595:  // Telemetry write functions
        -: 1596:  // ----------------------------------------------------------------------
        -: 1597:
      216: 1598:  void CmdSequencerComponentBase ::
        -: 1599:    tlmWrite_CS_LoadCommands(U32 arg)
        -: 1600:  {
        -: 1601:
      216: 1602:    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      432: 1603:      Fw::Time _tlmTime;
      216: 1604:      if (this->m_timeCaller_OutputPort[0].isConnected()) {
      216: 1605:         this->m_timeCaller_OutputPort[0].invoke( _tlmTime);
        -: 1606:      }
      432: 1607:      Fw::TlmBuffer _tlmBuff;
      216: 1608:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1609:      FW_ASSERT(
        -: 1610:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1611:          static_cast<AssertArg>(_stat)
      216: 1612:      );
        -: 1613:      
        -: 1614:      FwChanIdType _id;
        -: 1615:      
      216: 1616:      _id = this->getIdBase() + CHANNELID_CS_LOADCOMMANDS;
        -: 1617:      
      216: 1618:      this->m_tlmOut_OutputPort[0].invoke(
        -: 1619:          _id,
        -: 1620:          _tlmTime,
        -: 1621:          _tlmBuff
      216: 1622:      );
        -: 1623:    }
        -: 1624:
      216: 1625:  }
        -: 1626:
        9: 1627:  void CmdSequencerComponentBase ::
        -: 1628:    tlmWrite_CS_CancelCommands(U32 arg)
        -: 1629:  {
        -: 1630:
        9: 1631:    if (this->m_tlmOut_OutputPort[0].isConnected()) {
       18: 1632:      Fw::Time _tlmTime;
        9: 1633:      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 1634:         this->m_timeCaller_OutputPort[0].invoke( _tlmTime);
        -: 1635:      }
       18: 1636:      Fw::TlmBuffer _tlmBuff;
        9: 1637:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1638:      FW_ASSERT(
        -: 1639:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1640:          static_cast<AssertArg>(_stat)
        9: 1641:      );
        -: 1642:      
        -: 1643:      FwChanIdType _id;
        -: 1644:      
        9: 1645:      _id = this->getIdBase() + CHANNELID_CS_CANCELCOMMANDS;
        -: 1646:      
        9: 1647:      this->m_tlmOut_OutputPort[0].invoke(
        -: 1648:          _id,
        -: 1649:          _tlmTime,
        -: 1650:          _tlmBuff
        9: 1651:      );
        -: 1652:    }
        -: 1653:
        9: 1654:  }
        -: 1655:
      207: 1656:  void CmdSequencerComponentBase ::
        -: 1657:    tlmWrite_CS_Errors(U32 arg)
        -: 1658:  {
        -: 1659:
      207: 1660:    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      414: 1661:      Fw::Time _tlmTime;
      207: 1662:      if (this->m_timeCaller_OutputPort[0].isConnected()) {
      207: 1663:         this->m_timeCaller_OutputPort[0].invoke( _tlmTime);
        -: 1664:      }
      414: 1665:      Fw::TlmBuffer _tlmBuff;
      207: 1666:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1667:      FW_ASSERT(
        -: 1668:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1669:          static_cast<AssertArg>(_stat)
      207: 1670:      );
        -: 1671:      
        -: 1672:      FwChanIdType _id;
        -: 1673:      
      207: 1674:      _id = this->getIdBase() + CHANNELID_CS_ERRORS;
        -: 1675:      
      207: 1676:      this->m_tlmOut_OutputPort[0].invoke(
        -: 1677:          _id,
        -: 1678:          _tlmTime,
        -: 1679:          _tlmBuff
      207: 1680:      );
        -: 1681:    }
        -: 1682:
      207: 1683:  }
        -: 1684:
      324: 1685:  void CmdSequencerComponentBase ::
        -: 1686:    tlmWrite_CS_CommandsExecuted(U32 arg)
        -: 1687:  {
        -: 1688:
      324: 1689:    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      648: 1690:      Fw::Time _tlmTime;
      324: 1691:      if (this->m_timeCaller_OutputPort[0].isConnected()) {
      324: 1692:         this->m_timeCaller_OutputPort[0].invoke( _tlmTime);
        -: 1693:      }
      648: 1694:      Fw::TlmBuffer _tlmBuff;
      324: 1695:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1696:      FW_ASSERT(
        -: 1697:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1698:          static_cast<AssertArg>(_stat)
      324: 1699:      );
        -: 1700:      
        -: 1701:      FwChanIdType _id;
        -: 1702:      
      324: 1703:      _id = this->getIdBase() + CHANNELID_CS_COMMANDSEXECUTED;
        -: 1704:      
      324: 1705:      this->m_tlmOut_OutputPort[0].invoke(
        -: 1706:          _id,
        -: 1707:          _tlmTime,
        -: 1708:          _tlmBuff
      324: 1709:      );
        -: 1710:    }
        -: 1711:
      324: 1712:  }
        -: 1713:
       72: 1714:  void CmdSequencerComponentBase ::
        -: 1715:    tlmWrite_CS_SequencesCompleted(U32 arg)
        -: 1716:  {
        -: 1717:
       72: 1718:    if (this->m_tlmOut_OutputPort[0].isConnected()) {
      144: 1719:      Fw::Time _tlmTime;
       72: 1720:      if (this->m_timeCaller_OutputPort[0].isConnected()) {
       72: 1721:         this->m_timeCaller_OutputPort[0].invoke( _tlmTime);
        -: 1722:      }
      144: 1723:      Fw::TlmBuffer _tlmBuff;
       72: 1724:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1725:      FW_ASSERT(
        -: 1726:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1727:          static_cast<AssertArg>(_stat)
       72: 1728:      );
        -: 1729:      
        -: 1730:      FwChanIdType _id;
        -: 1731:      
       72: 1732:      _id = this->getIdBase() + CHANNELID_CS_SEQUENCESCOMPLETED;
        -: 1733:      
       72: 1734:      this->m_tlmOut_OutputPort[0].invoke(
        -: 1735:          _id,
        -: 1736:          _tlmTime,
        -: 1737:          _tlmBuff
       72: 1738:      );
        -: 1739:    }
        -: 1740:
       72: 1741:  }
        -: 1742:
        -: 1743:  // ----------------------------------------------------------------------
        -: 1744:  // Time
        -: 1745:  // ----------------------------------------------------------------------
        -: 1746:
      943: 1747:  Fw::Time CmdSequencerComponentBase ::
        -: 1748:    getTime(void) 
        -: 1749:  {
      943: 1750:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
     1886: 1751:      Fw::Time _time;
      943: 1752:      this->m_timeCaller_OutputPort[0].invoke(_time);
      943: 1753:      return _time;
        -: 1754:    } else {
    #####: 1755:      return Fw::Time(TB_NONE,0,0);
        -: 1756:    }
        -: 1757:  }
        -: 1758:
        -: 1759:  // ----------------------------------------------------------------------
        -: 1760:  // Event handling functions
        -: 1761:  // ----------------------------------------------------------------------
        -: 1762:
      216: 1763:  void CmdSequencerComponentBase ::
        -: 1764:    log_ACTIVITY_LO_CS_SequenceLoaded(
        -: 1765:        Fw::LogStringArg& fileName
        -: 1766:    )
        -: 1767:  {
        -: 1768:  
        -: 1769:
        -: 1770:    // Get the time
      432: 1771:    Fw::Time _logTime;
      216: 1772:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      216: 1773:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 1774:    }
        -: 1775:    
      216: 1776:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1777:    
      216: 1778:    _id = this->getIdBase() + EVENTID_CS_SEQUENCELOADED;
        -: 1779:
        -: 1780:    // Emit the event on the log port
      216: 1781:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 1782:
      432: 1783:      Fw::LogBuffer _logBuff;
      216: 1784:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1785:
        -: 1786:#if FW_AMPCS_COMPATIBLE
        -: 1787:      // Serialize the number of arguments
        -: 1788:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1789:      FW_ASSERT(
        -: 1790:          _status == Fw::FW_SERIALIZE_OK,
        -: 1791:          static_cast<AssertArg>(_status)
        -: 1792:      );
        -: 1793:#endif
        -: 1794:
      216: 1795:      fileName.setMaxSerialize(60);
      216: 1796:      _status = _logBuff.serialize(fileName);
        -: 1797:      FW_ASSERT(
        -: 1798:          _status == Fw::FW_SERIALIZE_OK,
        -: 1799:          static_cast<AssertArg>(_status)
      216: 1800:      );
        -: 1801:
        -: 1802:
      216: 1803:      this->m_logOut_OutputPort[0].invoke(
        -: 1804:          _id,
        -: 1805:          _logTime,Fw::LOG_ACTIVITY_LO,
        -: 1806:          _logBuff
      216: 1807:      );
        -: 1808:
        -: 1809:    }
        -: 1810:
        -: 1811:    // Emit the event on the text log port
        -: 1812:#if FW_ENABLE_TEXT_LOGGING
      216: 1813:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1814:
        -: 1815:#if FW_OBJECT_NAMES == 1
        -: 1816:      const char* _formatString =
      216: 1817:        "(%s) %s: Loaded sequence %s";
        -: 1818:#else
        -: 1819:      const char* _formatString =
        -: 1820:        "%s: Loaded sequence %s";
        -: 1821:#endif
        -: 1822:
        -: 1823:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1824:
      216: 1825:      (void) snprintf(
        -: 1826:          _textBuffer,
        -: 1827:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1828:          _formatString,
        -: 1829:#if FW_OBJECT_NAMES == 1
        -: 1830:          this->m_objName,
        -: 1831:#endif
        -: 1832:          "CS_SequenceLoaded "
      216: 1833:        , fileName.toChar()
      216: 1834:      );
        -: 1835:
        -: 1836:      // Null terminate
      216: 1837:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      432: 1838:      Fw::TextLogString _logString = _textBuffer;
      216: 1839:      this->m_LogText_OutputPort[0].invoke(
        -: 1840:          _id,
        -: 1841:          _logTime,Fw::TEXT_LOG_ACTIVITY_LO,
        -: 1842:          _logString
      216: 1843:      );
        -: 1844:
        -: 1845:    }
        -: 1846:#endif
        -: 1847:
      216: 1848:  }
        -: 1849:  
        -: 1850:
        9: 1851:  void CmdSequencerComponentBase ::
        -: 1852:    log_ACTIVITY_HI_CS_SequenceCanceled(
        -: 1853:        Fw::LogStringArg& fileName
        -: 1854:    )
        -: 1855:  {
        -: 1856:  
        -: 1857:
        -: 1858:    // Get the time
       18: 1859:    Fw::Time _logTime;
        9: 1860:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 1861:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 1862:    }
        -: 1863:    
        9: 1864:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1865:    
        9: 1866:    _id = this->getIdBase() + EVENTID_CS_SEQUENCECANCELED;
        -: 1867:
        -: 1868:    // Emit the event on the log port
        9: 1869:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 1870:
       18: 1871:      Fw::LogBuffer _logBuff;
        9: 1872:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1873:
        -: 1874:#if FW_AMPCS_COMPATIBLE
        -: 1875:      // Serialize the number of arguments
        -: 1876:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1877:      FW_ASSERT(
        -: 1878:          _status == Fw::FW_SERIALIZE_OK,
        -: 1879:          static_cast<AssertArg>(_status)
        -: 1880:      );
        -: 1881:#endif
        -: 1882:
        9: 1883:      fileName.setMaxSerialize(60);
        9: 1884:      _status = _logBuff.serialize(fileName);
        -: 1885:      FW_ASSERT(
        -: 1886:          _status == Fw::FW_SERIALIZE_OK,
        -: 1887:          static_cast<AssertArg>(_status)
        9: 1888:      );
        -: 1889:
        -: 1890:
        9: 1891:      this->m_logOut_OutputPort[0].invoke(
        -: 1892:          _id,
        -: 1893:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1894:          _logBuff
        9: 1895:      );
        -: 1896:
        -: 1897:    }
        -: 1898:
        -: 1899:    // Emit the event on the text log port
        -: 1900:#if FW_ENABLE_TEXT_LOGGING
        9: 1901:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1902:
        -: 1903:#if FW_OBJECT_NAMES == 1
        -: 1904:      const char* _formatString =
        9: 1905:        "(%s) %s: Sequence file %s canceled";
        -: 1906:#else
        -: 1907:      const char* _formatString =
        -: 1908:        "%s: Sequence file %s canceled";
        -: 1909:#endif
        -: 1910:
        -: 1911:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1912:
        9: 1913:      (void) snprintf(
        -: 1914:          _textBuffer,
        -: 1915:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1916:          _formatString,
        -: 1917:#if FW_OBJECT_NAMES == 1
        -: 1918:          this->m_objName,
        -: 1919:#endif
        -: 1920:          "CS_SequenceCanceled "
        9: 1921:        , fileName.toChar()
        9: 1922:      );
        -: 1923:
        -: 1924:      // Null terminate
        9: 1925:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 1926:      Fw::TextLogString _logString = _textBuffer;
        9: 1927:      this->m_LogText_OutputPort[0].invoke(
        -: 1928:          _id,
        -: 1929:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1930:          _logString
        9: 1931:      );
        -: 1932:
        -: 1933:    }
        -: 1934:#endif
        -: 1935:
        9: 1936:  }
        -: 1937:  
        -: 1938:
        9: 1939:  void CmdSequencerComponentBase ::
        -: 1940:    log_WARNING_HI_CS_FileReadError(
        -: 1941:        Fw::LogStringArg& fileName
        -: 1942:    )
        -: 1943:  {
        -: 1944:  
        -: 1945:
        -: 1946:    // Get the time
       18: 1947:    Fw::Time _logTime;
        9: 1948:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 1949:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 1950:    }
        -: 1951:    
        9: 1952:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1953:    
        9: 1954:    _id = this->getIdBase() + EVENTID_CS_FILEREADERROR;
        -: 1955:
        -: 1956:    // Emit the event on the log port
        9: 1957:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 1958:
       18: 1959:      Fw::LogBuffer _logBuff;
        9: 1960:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1961:
        -: 1962:#if FW_AMPCS_COMPATIBLE
        -: 1963:      // Serialize the number of arguments
        -: 1964:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1965:      FW_ASSERT(
        -: 1966:          _status == Fw::FW_SERIALIZE_OK,
        -: 1967:          static_cast<AssertArg>(_status)
        -: 1968:      );
        -: 1969:#endif
        -: 1970:
        9: 1971:      fileName.setMaxSerialize(60);
        9: 1972:      _status = _logBuff.serialize(fileName);
        -: 1973:      FW_ASSERT(
        -: 1974:          _status == Fw::FW_SERIALIZE_OK,
        -: 1975:          static_cast<AssertArg>(_status)
        9: 1976:      );
        -: 1977:
        -: 1978:
        9: 1979:      this->m_logOut_OutputPort[0].invoke(
        -: 1980:          _id,
        -: 1981:          _logTime,Fw::LOG_WARNING_HI,
        -: 1982:          _logBuff
        9: 1983:      );
        -: 1984:
        -: 1985:    }
        -: 1986:
        -: 1987:    // Emit the event on the text log port
        -: 1988:#if FW_ENABLE_TEXT_LOGGING
        9: 1989:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1990:
        -: 1991:#if FW_OBJECT_NAMES == 1
        -: 1992:      const char* _formatString =
        9: 1993:        "(%s) %s: Error reading sequence file %s";
        -: 1994:#else
        -: 1995:      const char* _formatString =
        -: 1996:        "%s: Error reading sequence file %s";
        -: 1997:#endif
        -: 1998:
        -: 1999:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2000:
        9: 2001:      (void) snprintf(
        -: 2002:          _textBuffer,
        -: 2003:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2004:          _formatString,
        -: 2005:#if FW_OBJECT_NAMES == 1
        -: 2006:          this->m_objName,
        -: 2007:#endif
        -: 2008:          "CS_FileReadError "
        9: 2009:        , fileName.toChar()
        9: 2010:      );
        -: 2011:
        -: 2012:      // Null terminate
        9: 2013:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 2014:      Fw::TextLogString _logString = _textBuffer;
        9: 2015:      this->m_LogText_OutputPort[0].invoke(
        -: 2016:          _id,
        -: 2017:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2018:          _logString
        9: 2019:      );
        -: 2020:
        -: 2021:    }
        -: 2022:#endif
        -: 2023:
        9: 2024:  }
        -: 2025:  
        -: 2026:
       63: 2027:  void CmdSequencerComponentBase ::
        -: 2028:    log_WARNING_HI_CS_FileInvalid(
        -: 2029:        Fw::LogStringArg& fileName, FileReadStage stage, I32 error
        -: 2030:    )
        -: 2031:  {
        -: 2032:  
        -: 2033:
        -: 2034:    // Get the time
      126: 2035:    Fw::Time _logTime;
       63: 2036:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       63: 2037:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2038:    }
        -: 2039:    
       63: 2040:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2041:    
       63: 2042:    _id = this->getIdBase() + EVENTID_CS_FILEINVALID;
        -: 2043:
        -: 2044:    // Emit the event on the log port
       63: 2045:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2046:
      126: 2047:      Fw::LogBuffer _logBuff;
       63: 2048:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2049:
        -: 2050:#if FW_AMPCS_COMPATIBLE
        -: 2051:      // Serialize the number of arguments
        -: 2052:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 2053:      FW_ASSERT(
        -: 2054:          _status == Fw::FW_SERIALIZE_OK,
        -: 2055:          static_cast<AssertArg>(_status)
        -: 2056:      );
        -: 2057:#endif
        -: 2058:
       63: 2059:      fileName.setMaxSerialize(60);
       63: 2060:      _status = _logBuff.serialize(fileName);
        -: 2061:      FW_ASSERT(
        -: 2062:          _status == Fw::FW_SERIALIZE_OK,
        -: 2063:          static_cast<AssertArg>(_status)
       63: 2064:      );
        -: 2065:
        -: 2066:#if FW_AMPCS_COMPATIBLE
        -: 2067:      // Serialize the argument size
        -: 2068:      _status = _logBuff.serialize(static_cast<U8>(sizeof(FwEnumStoreType)));
        -: 2069:      FW_ASSERT(
        -: 2070:          _status == Fw::FW_SERIALIZE_OK,
        -: 2071:          static_cast<AssertArg>(_status)
        -: 2072:      );
        -: 2073:#endif
        -: 2074:
       63: 2075:      _status = _logBuff.serialize(
        -: 2076:          static_cast<FwEnumStoreType>(stage)
       63: 2077:      );
        -: 2078:      FW_ASSERT(
        -: 2079:          _status == Fw::FW_SERIALIZE_OK,
        -: 2080:          static_cast<AssertArg>(_status)
       63: 2081:      );
        -: 2082:
        -: 2083:#if FW_AMPCS_COMPATIBLE
        -: 2084:      // Serialize the argument size
        -: 2085:      _status = _logBuff.serialize(
        -: 2086:          static_cast<U8>(sizeof(error))
        -: 2087:      );
        -: 2088:      FW_ASSERT(
        -: 2089:          _status == Fw::FW_SERIALIZE_OK,
        -: 2090:          static_cast<AssertArg>(_status)
        -: 2091:      );
        -: 2092:#endif
        -: 2093:
       63: 2094:      _status = _logBuff.serialize(error);
        -: 2095:      FW_ASSERT(
        -: 2096:          _status == Fw::FW_SERIALIZE_OK,
        -: 2097:          static_cast<AssertArg>(_status)
       63: 2098:      );
        -: 2099:
        -: 2100:
       63: 2101:      this->m_logOut_OutputPort[0].invoke(
        -: 2102:          _id,
        -: 2103:          _logTime,Fw::LOG_WARNING_HI,
        -: 2104:          _logBuff
       63: 2105:      );
        -: 2106:
        -: 2107:    }
        -: 2108:
        -: 2109:    // Emit the event on the text log port
        -: 2110:#if FW_ENABLE_TEXT_LOGGING
       63: 2111:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2112:
        -: 2113:#if FW_OBJECT_NAMES == 1
        -: 2114:      const char* _formatString =
       63: 2115:        "(%s) %s: Sequence file %s invalid. Stage: %d Error: %d";
        -: 2116:#else
        -: 2117:      const char* _formatString =
        -: 2118:        "%s: Sequence file %s invalid. Stage: %d Error: %d";
        -: 2119:#endif
        -: 2120:
        -: 2121:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2122:
      126: 2123:      (void) snprintf(
        -: 2124:          _textBuffer,
        -: 2125:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2126:          _formatString,
        -: 2127:#if FW_OBJECT_NAMES == 1
        -: 2128:          this->m_objName,
        -: 2129:#endif
        -: 2130:          "CS_FileInvalid "
       63: 2131:        , fileName.toChar()
        -: 2132:        , stage
        -: 2133:        , error
       63: 2134:      );
        -: 2135:
        -: 2136:      // Null terminate
       63: 2137:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      126: 2138:      Fw::TextLogString _logString = _textBuffer;
       63: 2139:      this->m_LogText_OutputPort[0].invoke(
        -: 2140:          _id,
        -: 2141:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2142:          _logString
       63: 2143:      );
        -: 2144:
        -: 2145:    }
        -: 2146:#endif
        -: 2147:
       63: 2148:  }
        -: 2149:  
        -: 2150:
       72: 2151:  void CmdSequencerComponentBase ::
        -: 2152:    log_WARNING_HI_CS_RecordInvalid(
        -: 2153:        Fw::LogStringArg& fileName, U32 recordNumber, I32 error
        -: 2154:    )
        -: 2155:  {
        -: 2156:  
        -: 2157:
        -: 2158:    // Get the time
      144: 2159:    Fw::Time _logTime;
       72: 2160:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       72: 2161:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2162:    }
        -: 2163:    
       72: 2164:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2165:    
       72: 2166:    _id = this->getIdBase() + EVENTID_CS_RECORDINVALID;
        -: 2167:
        -: 2168:    // Emit the event on the log port
       72: 2169:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2170:
      144: 2171:      Fw::LogBuffer _logBuff;
       72: 2172:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2173:
        -: 2174:#if FW_AMPCS_COMPATIBLE
        -: 2175:      // Serialize the number of arguments
        -: 2176:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 2177:      FW_ASSERT(
        -: 2178:          _status == Fw::FW_SERIALIZE_OK,
        -: 2179:          static_cast<AssertArg>(_status)
        -: 2180:      );
        -: 2181:#endif
        -: 2182:
       72: 2183:      fileName.setMaxSerialize(60);
       72: 2184:      _status = _logBuff.serialize(fileName);
        -: 2185:      FW_ASSERT(
        -: 2186:          _status == Fw::FW_SERIALIZE_OK,
        -: 2187:          static_cast<AssertArg>(_status)
       72: 2188:      );
        -: 2189:
        -: 2190:#if FW_AMPCS_COMPATIBLE
        -: 2191:      // Serialize the argument size
        -: 2192:      _status = _logBuff.serialize(
        -: 2193:          static_cast<U8>(sizeof(recordNumber))
        -: 2194:      );
        -: 2195:      FW_ASSERT(
        -: 2196:          _status == Fw::FW_SERIALIZE_OK,
        -: 2197:          static_cast<AssertArg>(_status)
        -: 2198:      );
        -: 2199:#endif
        -: 2200:
       72: 2201:      _status = _logBuff.serialize(recordNumber);
        -: 2202:      FW_ASSERT(
        -: 2203:          _status == Fw::FW_SERIALIZE_OK,
        -: 2204:          static_cast<AssertArg>(_status)
       72: 2205:      );
        -: 2206:
        -: 2207:#if FW_AMPCS_COMPATIBLE
        -: 2208:      // Serialize the argument size
        -: 2209:      _status = _logBuff.serialize(
        -: 2210:          static_cast<U8>(sizeof(error))
        -: 2211:      );
        -: 2212:      FW_ASSERT(
        -: 2213:          _status == Fw::FW_SERIALIZE_OK,
        -: 2214:          static_cast<AssertArg>(_status)
        -: 2215:      );
        -: 2216:#endif
        -: 2217:
       72: 2218:      _status = _logBuff.serialize(error);
        -: 2219:      FW_ASSERT(
        -: 2220:          _status == Fw::FW_SERIALIZE_OK,
        -: 2221:          static_cast<AssertArg>(_status)
       72: 2222:      );
        -: 2223:
        -: 2224:
       72: 2225:      this->m_logOut_OutputPort[0].invoke(
        -: 2226:          _id,
        -: 2227:          _logTime,Fw::LOG_WARNING_HI,
        -: 2228:          _logBuff
       72: 2229:      );
        -: 2230:
        -: 2231:    }
        -: 2232:
        -: 2233:    // Emit the event on the text log port
        -: 2234:#if FW_ENABLE_TEXT_LOGGING
       72: 2235:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2236:
        -: 2237:#if FW_OBJECT_NAMES == 1
        -: 2238:      const char* _formatString =
       72: 2239:        "(%s) %s: Sequence file %s: Record %d invalid. Err: %d";
        -: 2240:#else
        -: 2241:      const char* _formatString =
        -: 2242:        "%s: Sequence file %s: Record %d invalid. Err: %d";
        -: 2243:#endif
        -: 2244:
        -: 2245:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2246:
       72: 2247:      (void) snprintf(
        -: 2248:          _textBuffer,
        -: 2249:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2250:          _formatString,
        -: 2251:#if FW_OBJECT_NAMES == 1
        -: 2252:          this->m_objName,
        -: 2253:#endif
        -: 2254:          "CS_RecordInvalid "
       72: 2255:        , fileName.toChar()
        -: 2256:        , recordNumber
        -: 2257:        , error
       72: 2258:      );
        -: 2259:
        -: 2260:      // Null terminate
       72: 2261:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      144: 2262:      Fw::TextLogString _logString = _textBuffer;
       72: 2263:      this->m_LogText_OutputPort[0].invoke(
        -: 2264:          _id,
        -: 2265:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2266:          _logString
       72: 2267:      );
        -: 2268:
        -: 2269:    }
        -: 2270:#endif
        -: 2271:
       72: 2272:  }
        -: 2273:  
        -: 2274:
        9: 2275:  void CmdSequencerComponentBase ::
        -: 2276:    log_WARNING_HI_CS_FileSizeError(
        -: 2277:        Fw::LogStringArg& fileName, U32 size
        -: 2278:    )
        -: 2279:  {
        -: 2280:  
        -: 2281:
        -: 2282:    // Get the time
       18: 2283:    Fw::Time _logTime;
        9: 2284:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 2285:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2286:    }
        -: 2287:    
        9: 2288:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2289:    
        9: 2290:    _id = this->getIdBase() + EVENTID_CS_FILESIZEERROR;
        -: 2291:
        -: 2292:    // Emit the event on the log port
        9: 2293:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2294:
       18: 2295:      Fw::LogBuffer _logBuff;
        9: 2296:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2297:
        -: 2298:#if FW_AMPCS_COMPATIBLE
        -: 2299:      // Serialize the number of arguments
        -: 2300:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 2301:      FW_ASSERT(
        -: 2302:          _status == Fw::FW_SERIALIZE_OK,
        -: 2303:          static_cast<AssertArg>(_status)
        -: 2304:      );
        -: 2305:#endif
        -: 2306:
        9: 2307:      fileName.setMaxSerialize(60);
        9: 2308:      _status = _logBuff.serialize(fileName);
        -: 2309:      FW_ASSERT(
        -: 2310:          _status == Fw::FW_SERIALIZE_OK,
        -: 2311:          static_cast<AssertArg>(_status)
        9: 2312:      );
        -: 2313:
        -: 2314:#if FW_AMPCS_COMPATIBLE
        -: 2315:      // Serialize the argument size
        -: 2316:      _status = _logBuff.serialize(
        -: 2317:          static_cast<U8>(sizeof(size))
        -: 2318:      );
        -: 2319:      FW_ASSERT(
        -: 2320:          _status == Fw::FW_SERIALIZE_OK,
        -: 2321:          static_cast<AssertArg>(_status)
        -: 2322:      );
        -: 2323:#endif
        -: 2324:
        9: 2325:      _status = _logBuff.serialize(size);
        -: 2326:      FW_ASSERT(
        -: 2327:          _status == Fw::FW_SERIALIZE_OK,
        -: 2328:          static_cast<AssertArg>(_status)
        9: 2329:      );
        -: 2330:
        -: 2331:
        9: 2332:      this->m_logOut_OutputPort[0].invoke(
        -: 2333:          _id,
        -: 2334:          _logTime,Fw::LOG_WARNING_HI,
        -: 2335:          _logBuff
        9: 2336:      );
        -: 2337:
        -: 2338:    }
        -: 2339:
        -: 2340:    // Emit the event on the text log port
        -: 2341:#if FW_ENABLE_TEXT_LOGGING
        9: 2342:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2343:
        -: 2344:#if FW_OBJECT_NAMES == 1
        -: 2345:      const char* _formatString =
        9: 2346:        "(%s) %s: Sequence file %s too large. Size: %d";
        -: 2347:#else
        -: 2348:      const char* _formatString =
        -: 2349:        "%s: Sequence file %s too large. Size: %d";
        -: 2350:#endif
        -: 2351:
        -: 2352:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2353:
        9: 2354:      (void) snprintf(
        -: 2355:          _textBuffer,
        -: 2356:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2357:          _formatString,
        -: 2358:#if FW_OBJECT_NAMES == 1
        -: 2359:          this->m_objName,
        -: 2360:#endif
        -: 2361:          "CS_FileSizeError "
        9: 2362:        , fileName.toChar()
        -: 2363:        , size
        9: 2364:      );
        -: 2365:
        -: 2366:      // Null terminate
        9: 2367:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 2368:      Fw::TextLogString _logString = _textBuffer;
        9: 2369:      this->m_LogText_OutputPort[0].invoke(
        -: 2370:          _id,
        -: 2371:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2372:          _logString
        9: 2373:      );
        -: 2374:
        -: 2375:    }
        -: 2376:#endif
        -: 2377:
        9: 2378:  }
        -: 2379:  
        -: 2380:
       18: 2381:  void CmdSequencerComponentBase ::
        -: 2382:    log_WARNING_HI_CS_FileNotFound(
        -: 2383:        Fw::LogStringArg& fileName
        -: 2384:    )
        -: 2385:  {
        -: 2386:  
        -: 2387:
        -: 2388:    // Get the time
       36: 2389:    Fw::Time _logTime;
       18: 2390:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       18: 2391:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2392:    }
        -: 2393:    
       18: 2394:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2395:    
       18: 2396:    _id = this->getIdBase() + EVENTID_CS_FILENOTFOUND;
        -: 2397:
        -: 2398:    // Emit the event on the log port
       18: 2399:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2400:
       36: 2401:      Fw::LogBuffer _logBuff;
       18: 2402:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2403:
        -: 2404:#if FW_AMPCS_COMPATIBLE
        -: 2405:      // Serialize the number of arguments
        -: 2406:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 2407:      FW_ASSERT(
        -: 2408:          _status == Fw::FW_SERIALIZE_OK,
        -: 2409:          static_cast<AssertArg>(_status)
        -: 2410:      );
        -: 2411:#endif
        -: 2412:
       18: 2413:      fileName.setMaxSerialize(60);
       18: 2414:      _status = _logBuff.serialize(fileName);
        -: 2415:      FW_ASSERT(
        -: 2416:          _status == Fw::FW_SERIALIZE_OK,
        -: 2417:          static_cast<AssertArg>(_status)
       18: 2418:      );
        -: 2419:
        -: 2420:
       18: 2421:      this->m_logOut_OutputPort[0].invoke(
        -: 2422:          _id,
        -: 2423:          _logTime,Fw::LOG_WARNING_HI,
        -: 2424:          _logBuff
       18: 2425:      );
        -: 2426:
        -: 2427:    }
        -: 2428:
        -: 2429:    // Emit the event on the text log port
        -: 2430:#if FW_ENABLE_TEXT_LOGGING
       18: 2431:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2432:
        -: 2433:#if FW_OBJECT_NAMES == 1
        -: 2434:      const char* _formatString =
       18: 2435:        "(%s) %s: Sequence file %s not found.";
        -: 2436:#else
        -: 2437:      const char* _formatString =
        -: 2438:        "%s: Sequence file %s not found.";
        -: 2439:#endif
        -: 2440:
        -: 2441:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2442:
       18: 2443:      (void) snprintf(
        -: 2444:          _textBuffer,
        -: 2445:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2446:          _formatString,
        -: 2447:#if FW_OBJECT_NAMES == 1
        -: 2448:          this->m_objName,
        -: 2449:#endif
        -: 2450:          "CS_FileNotFound "
       18: 2451:        , fileName.toChar()
       18: 2452:      );
        -: 2453:
        -: 2454:      // Null terminate
       18: 2455:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       36: 2456:      Fw::TextLogString _logString = _textBuffer;
       18: 2457:      this->m_LogText_OutputPort[0].invoke(
        -: 2458:          _id,
        -: 2459:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2460:          _logString
       18: 2461:      );
        -: 2462:
        -: 2463:    }
        -: 2464:#endif
        -: 2465:
       18: 2466:  }
        -: 2467:  
        -: 2468:
        9: 2469:  void CmdSequencerComponentBase ::
        -: 2470:    log_WARNING_HI_CS_FileCrcFailure(
        -: 2471:        Fw::LogStringArg& fileName, U32 storedCRC, U32 computedCRC
        -: 2472:    )
        -: 2473:  {
        -: 2474:  
        -: 2475:
        -: 2476:    // Get the time
       18: 2477:    Fw::Time _logTime;
        9: 2478:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 2479:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2480:    }
        -: 2481:    
        9: 2482:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2483:    
        9: 2484:    _id = this->getIdBase() + EVENTID_CS_FILECRCFAILURE;
        -: 2485:
        -: 2486:    // Emit the event on the log port
        9: 2487:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2488:
       18: 2489:      Fw::LogBuffer _logBuff;
        9: 2490:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2491:
        -: 2492:#if FW_AMPCS_COMPATIBLE
        -: 2493:      // Serialize the number of arguments
        -: 2494:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 2495:      FW_ASSERT(
        -: 2496:          _status == Fw::FW_SERIALIZE_OK,
        -: 2497:          static_cast<AssertArg>(_status)
        -: 2498:      );
        -: 2499:#endif
        -: 2500:
        9: 2501:      fileName.setMaxSerialize(60);
        9: 2502:      _status = _logBuff.serialize(fileName);
        -: 2503:      FW_ASSERT(
        -: 2504:          _status == Fw::FW_SERIALIZE_OK,
        -: 2505:          static_cast<AssertArg>(_status)
        9: 2506:      );
        -: 2507:
        -: 2508:#if FW_AMPCS_COMPATIBLE
        -: 2509:      // Serialize the argument size
        -: 2510:      _status = _logBuff.serialize(
        -: 2511:          static_cast<U8>(sizeof(storedCRC))
        -: 2512:      );
        -: 2513:      FW_ASSERT(
        -: 2514:          _status == Fw::FW_SERIALIZE_OK,
        -: 2515:          static_cast<AssertArg>(_status)
        -: 2516:      );
        -: 2517:#endif
        -: 2518:
        9: 2519:      _status = _logBuff.serialize(storedCRC);
        -: 2520:      FW_ASSERT(
        -: 2521:          _status == Fw::FW_SERIALIZE_OK,
        -: 2522:          static_cast<AssertArg>(_status)
        9: 2523:      );
        -: 2524:
        -: 2525:#if FW_AMPCS_COMPATIBLE
        -: 2526:      // Serialize the argument size
        -: 2527:      _status = _logBuff.serialize(
        -: 2528:          static_cast<U8>(sizeof(computedCRC))
        -: 2529:      );
        -: 2530:      FW_ASSERT(
        -: 2531:          _status == Fw::FW_SERIALIZE_OK,
        -: 2532:          static_cast<AssertArg>(_status)
        -: 2533:      );
        -: 2534:#endif
        -: 2535:
        9: 2536:      _status = _logBuff.serialize(computedCRC);
        -: 2537:      FW_ASSERT(
        -: 2538:          _status == Fw::FW_SERIALIZE_OK,
        -: 2539:          static_cast<AssertArg>(_status)
        9: 2540:      );
        -: 2541:
        -: 2542:
        9: 2543:      this->m_logOut_OutputPort[0].invoke(
        -: 2544:          _id,
        -: 2545:          _logTime,Fw::LOG_WARNING_HI,
        -: 2546:          _logBuff
        9: 2547:      );
        -: 2548:
        -: 2549:    }
        -: 2550:
        -: 2551:    // Emit the event on the text log port
        -: 2552:#if FW_ENABLE_TEXT_LOGGING
        9: 2553:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2554:
        -: 2555:#if FW_OBJECT_NAMES == 1
        -: 2556:      const char* _formatString =
        9: 2557:        "(%s) %s: Sequence file %s had invalid CRC. Stored 0x%08X, Computed 0x%08X.";
        -: 2558:#else
        -: 2559:      const char* _formatString =
        -: 2560:        "%s: Sequence file %s had invalid CRC. Stored 0x%08X, Computed 0x%08X.";
        -: 2561:#endif
        -: 2562:
        -: 2563:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2564:
        9: 2565:      (void) snprintf(
        -: 2566:          _textBuffer,
        -: 2567:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2568:          _formatString,
        -: 2569:#if FW_OBJECT_NAMES == 1
        -: 2570:          this->m_objName,
        -: 2571:#endif
        -: 2572:          "CS_FileCrcFailure "
        9: 2573:        , fileName.toChar()
        -: 2574:        , storedCRC
        -: 2575:        , computedCRC
        9: 2576:      );
        -: 2577:
        -: 2578:      // Null terminate
        9: 2579:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 2580:      Fw::TextLogString _logString = _textBuffer;
        9: 2581:      this->m_LogText_OutputPort[0].invoke(
        -: 2582:          _id,
        -: 2583:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2584:          _logString
        9: 2585:      );
        -: 2586:
        -: 2587:    }
        -: 2588:#endif
        -: 2589:
        9: 2590:  }
        -: 2591:  
        -: 2592:
      324: 2593:  void CmdSequencerComponentBase ::
        -: 2594:    log_ACTIVITY_LO_CS_CommandComplete(
        -: 2595:        Fw::LogStringArg& fileName, U32 recordNumber, U32 opCode
        -: 2596:    )
        -: 2597:  {
        -: 2598:  
        -: 2599:
        -: 2600:    // Get the time
      648: 2601:    Fw::Time _logTime;
      324: 2602:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      324: 2603:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2604:    }
        -: 2605:    
      324: 2606:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2607:    
      324: 2608:    _id = this->getIdBase() + EVENTID_CS_COMMANDCOMPLETE;
        -: 2609:
        -: 2610:    // Emit the event on the log port
      324: 2611:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2612:
      648: 2613:      Fw::LogBuffer _logBuff;
      324: 2614:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2615:
        -: 2616:#if FW_AMPCS_COMPATIBLE
        -: 2617:      // Serialize the number of arguments
        -: 2618:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 2619:      FW_ASSERT(
        -: 2620:          _status == Fw::FW_SERIALIZE_OK,
        -: 2621:          static_cast<AssertArg>(_status)
        -: 2622:      );
        -: 2623:#endif
        -: 2624:
      324: 2625:      fileName.setMaxSerialize(60);
      324: 2626:      _status = _logBuff.serialize(fileName);
        -: 2627:      FW_ASSERT(
        -: 2628:          _status == Fw::FW_SERIALIZE_OK,
        -: 2629:          static_cast<AssertArg>(_status)
      324: 2630:      );
        -: 2631:
        -: 2632:#if FW_AMPCS_COMPATIBLE
        -: 2633:      // Serialize the argument size
        -: 2634:      _status = _logBuff.serialize(
        -: 2635:          static_cast<U8>(sizeof(recordNumber))
        -: 2636:      );
        -: 2637:      FW_ASSERT(
        -: 2638:          _status == Fw::FW_SERIALIZE_OK,
        -: 2639:          static_cast<AssertArg>(_status)
        -: 2640:      );
        -: 2641:#endif
        -: 2642:
      324: 2643:      _status = _logBuff.serialize(recordNumber);
        -: 2644:      FW_ASSERT(
        -: 2645:          _status == Fw::FW_SERIALIZE_OK,
        -: 2646:          static_cast<AssertArg>(_status)
      324: 2647:      );
        -: 2648:
        -: 2649:#if FW_AMPCS_COMPATIBLE
        -: 2650:      // Serialize the argument size
        -: 2651:      _status = _logBuff.serialize(
        -: 2652:          static_cast<U8>(sizeof(opCode))
        -: 2653:      );
        -: 2654:      FW_ASSERT(
        -: 2655:          _status == Fw::FW_SERIALIZE_OK,
        -: 2656:          static_cast<AssertArg>(_status)
        -: 2657:      );
        -: 2658:#endif
        -: 2659:
      324: 2660:      _status = _logBuff.serialize(opCode);
        -: 2661:      FW_ASSERT(
        -: 2662:          _status == Fw::FW_SERIALIZE_OK,
        -: 2663:          static_cast<AssertArg>(_status)
      324: 2664:      );
        -: 2665:
        -: 2666:
      324: 2667:      this->m_logOut_OutputPort[0].invoke(
        -: 2668:          _id,
        -: 2669:          _logTime,Fw::LOG_ACTIVITY_LO,
        -: 2670:          _logBuff
      324: 2671:      );
        -: 2672:
        -: 2673:    }
        -: 2674:
        -: 2675:    // Emit the event on the text log port
        -: 2676:#if FW_ENABLE_TEXT_LOGGING
      324: 2677:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2678:
        -: 2679:#if FW_OBJECT_NAMES == 1
        -: 2680:      const char* _formatString =
      324: 2681:        "(%s) %s: Sequence file %s: Command %d (opcode %d) complete";
        -: 2682:#else
        -: 2683:      const char* _formatString =
        -: 2684:        "%s: Sequence file %s: Command %d (opcode %d) complete";
        -: 2685:#endif
        -: 2686:
        -: 2687:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2688:
      324: 2689:      (void) snprintf(
        -: 2690:          _textBuffer,
        -: 2691:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2692:          _formatString,
        -: 2693:#if FW_OBJECT_NAMES == 1
        -: 2694:          this->m_objName,
        -: 2695:#endif
        -: 2696:          "CS_CommandComplete "
      324: 2697:        , fileName.toChar()
        -: 2698:        , recordNumber
        -: 2699:        , opCode
      324: 2700:      );
        -: 2701:
        -: 2702:      // Null terminate
      324: 2703:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      648: 2704:      Fw::TextLogString _logString = _textBuffer;
      324: 2705:      this->m_LogText_OutputPort[0].invoke(
        -: 2706:          _id,
        -: 2707:          _logTime,Fw::TEXT_LOG_ACTIVITY_LO,
        -: 2708:          _logString
      324: 2709:      );
        -: 2710:
        -: 2711:    }
        -: 2712:#endif
        -: 2713:
      324: 2714:  }
        -: 2715:  
        -: 2716:
       72: 2717:  void CmdSequencerComponentBase ::
        -: 2718:    log_ACTIVITY_HI_CS_SequenceComplete(
        -: 2719:        Fw::LogStringArg& fileName
        -: 2720:    )
        -: 2721:  {
        -: 2722:  
        -: 2723:
        -: 2724:    // Get the time
      144: 2725:    Fw::Time _logTime;
       72: 2726:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       72: 2727:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2728:    }
        -: 2729:    
       72: 2730:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2731:    
       72: 2732:    _id = this->getIdBase() + EVENTID_CS_SEQUENCECOMPLETE;
        -: 2733:
        -: 2734:    // Emit the event on the log port
       72: 2735:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2736:
      144: 2737:      Fw::LogBuffer _logBuff;
       72: 2738:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2739:
        -: 2740:#if FW_AMPCS_COMPATIBLE
        -: 2741:      // Serialize the number of arguments
        -: 2742:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 2743:      FW_ASSERT(
        -: 2744:          _status == Fw::FW_SERIALIZE_OK,
        -: 2745:          static_cast<AssertArg>(_status)
        -: 2746:      );
        -: 2747:#endif
        -: 2748:
       72: 2749:      fileName.setMaxSerialize(60);
       72: 2750:      _status = _logBuff.serialize(fileName);
        -: 2751:      FW_ASSERT(
        -: 2752:          _status == Fw::FW_SERIALIZE_OK,
        -: 2753:          static_cast<AssertArg>(_status)
       72: 2754:      );
        -: 2755:
        -: 2756:
       72: 2757:      this->m_logOut_OutputPort[0].invoke(
        -: 2758:          _id,
        -: 2759:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 2760:          _logBuff
       72: 2761:      );
        -: 2762:
        -: 2763:    }
        -: 2764:
        -: 2765:    // Emit the event on the text log port
        -: 2766:#if FW_ENABLE_TEXT_LOGGING
       72: 2767:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2768:
        -: 2769:#if FW_OBJECT_NAMES == 1
        -: 2770:      const char* _formatString =
       72: 2771:        "(%s) %s: Sequence file %s complete";
        -: 2772:#else
        -: 2773:      const char* _formatString =
        -: 2774:        "%s: Sequence file %s complete";
        -: 2775:#endif
        -: 2776:
        -: 2777:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2778:
       72: 2779:      (void) snprintf(
        -: 2780:          _textBuffer,
        -: 2781:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2782:          _formatString,
        -: 2783:#if FW_OBJECT_NAMES == 1
        -: 2784:          this->m_objName,
        -: 2785:#endif
        -: 2786:          "CS_SequenceComplete "
       72: 2787:        , fileName.toChar()
       72: 2788:      );
        -: 2789:
        -: 2790:      // Null terminate
       72: 2791:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      144: 2792:      Fw::TextLogString _logString = _textBuffer;
       72: 2793:      this->m_LogText_OutputPort[0].invoke(
        -: 2794:          _id,
        -: 2795:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 2796:          _logString
       72: 2797:      );
        -: 2798:
        -: 2799:    }
        -: 2800:#endif
        -: 2801:
       72: 2802:  }
        -: 2803:  
        -: 2804:
        9: 2805:  void CmdSequencerComponentBase ::
        -: 2806:    log_WARNING_HI_CS_CommandError(
        -: 2807:        Fw::LogStringArg& fileName, U32 recordNumber, U32 opCode, U32 errorStatus
        -: 2808:    )
        -: 2809:  {
        -: 2810:  
        -: 2811:
        -: 2812:    // Get the time
       18: 2813:    Fw::Time _logTime;
        9: 2814:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 2815:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2816:    }
        -: 2817:    
        9: 2818:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2819:    
        9: 2820:    _id = this->getIdBase() + EVENTID_CS_COMMANDERROR;
        -: 2821:
        -: 2822:    // Emit the event on the log port
        9: 2823:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2824:
       18: 2825:      Fw::LogBuffer _logBuff;
        9: 2826:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2827:
        -: 2828:#if FW_AMPCS_COMPATIBLE
        -: 2829:      // Serialize the number of arguments
        -: 2830:      _status = _logBuff.serialize(static_cast<U8>(4));
        -: 2831:      FW_ASSERT(
        -: 2832:          _status == Fw::FW_SERIALIZE_OK,
        -: 2833:          static_cast<AssertArg>(_status)
        -: 2834:      );
        -: 2835:#endif
        -: 2836:
        9: 2837:      fileName.setMaxSerialize(60);
        9: 2838:      _status = _logBuff.serialize(fileName);
        -: 2839:      FW_ASSERT(
        -: 2840:          _status == Fw::FW_SERIALIZE_OK,
        -: 2841:          static_cast<AssertArg>(_status)
        9: 2842:      );
        -: 2843:
        -: 2844:#if FW_AMPCS_COMPATIBLE
        -: 2845:      // Serialize the argument size
        -: 2846:      _status = _logBuff.serialize(
        -: 2847:          static_cast<U8>(sizeof(recordNumber))
        -: 2848:      );
        -: 2849:      FW_ASSERT(
        -: 2850:          _status == Fw::FW_SERIALIZE_OK,
        -: 2851:          static_cast<AssertArg>(_status)
        -: 2852:      );
        -: 2853:#endif
        -: 2854:
        9: 2855:      _status = _logBuff.serialize(recordNumber);
        -: 2856:      FW_ASSERT(
        -: 2857:          _status == Fw::FW_SERIALIZE_OK,
        -: 2858:          static_cast<AssertArg>(_status)
        9: 2859:      );
        -: 2860:
        -: 2861:#if FW_AMPCS_COMPATIBLE
        -: 2862:      // Serialize the argument size
        -: 2863:      _status = _logBuff.serialize(
        -: 2864:          static_cast<U8>(sizeof(opCode))
        -: 2865:      );
        -: 2866:      FW_ASSERT(
        -: 2867:          _status == Fw::FW_SERIALIZE_OK,
        -: 2868:          static_cast<AssertArg>(_status)
        -: 2869:      );
        -: 2870:#endif
        -: 2871:
        9: 2872:      _status = _logBuff.serialize(opCode);
        -: 2873:      FW_ASSERT(
        -: 2874:          _status == Fw::FW_SERIALIZE_OK,
        -: 2875:          static_cast<AssertArg>(_status)
        9: 2876:      );
        -: 2877:
        -: 2878:#if FW_AMPCS_COMPATIBLE
        -: 2879:      // Serialize the argument size
        -: 2880:      _status = _logBuff.serialize(
        -: 2881:          static_cast<U8>(sizeof(errorStatus))
        -: 2882:      );
        -: 2883:      FW_ASSERT(
        -: 2884:          _status == Fw::FW_SERIALIZE_OK,
        -: 2885:          static_cast<AssertArg>(_status)
        -: 2886:      );
        -: 2887:#endif
        -: 2888:
        9: 2889:      _status = _logBuff.serialize(errorStatus);
        -: 2890:      FW_ASSERT(
        -: 2891:          _status == Fw::FW_SERIALIZE_OK,
        -: 2892:          static_cast<AssertArg>(_status)
        9: 2893:      );
        -: 2894:
        -: 2895:
        9: 2896:      this->m_logOut_OutputPort[0].invoke(
        -: 2897:          _id,
        -: 2898:          _logTime,Fw::LOG_WARNING_HI,
        -: 2899:          _logBuff
        9: 2900:      );
        -: 2901:
        -: 2902:    }
        -: 2903:
        -: 2904:    // Emit the event on the text log port
        -: 2905:#if FW_ENABLE_TEXT_LOGGING
        9: 2906:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2907:
        -: 2908:#if FW_OBJECT_NAMES == 1
        -: 2909:      const char* _formatString =
        9: 2910:        "(%s) %s: Sequence file %s: Command %d (opcode %d) completed with error %d";
        -: 2911:#else
        -: 2912:      const char* _formatString =
        -: 2913:        "%s: Sequence file %s: Command %d (opcode %d) completed with error %d";
        -: 2914:#endif
        -: 2915:
        -: 2916:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 2917:
        9: 2918:      (void) snprintf(
        -: 2919:          _textBuffer,
        -: 2920:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 2921:          _formatString,
        -: 2922:#if FW_OBJECT_NAMES == 1
        -: 2923:          this->m_objName,
        -: 2924:#endif
        -: 2925:          "CS_CommandError "
        9: 2926:        , fileName.toChar()
        -: 2927:        , recordNumber
        -: 2928:        , opCode
        -: 2929:        , errorStatus
        9: 2930:      );
        -: 2931:
        -: 2932:      // Null terminate
        9: 2933:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 2934:      Fw::TextLogString _logString = _textBuffer;
        9: 2935:      this->m_LogText_OutputPort[0].invoke(
        -: 2936:          _id,
        -: 2937:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 2938:          _logString
        9: 2939:      );
        -: 2940:
        -: 2941:    }
        -: 2942:#endif
        -: 2943:
        9: 2944:  }
        -: 2945:  
        -: 2946:
       63: 2947:  void CmdSequencerComponentBase ::
        -: 2948:    log_WARNING_HI_CS_InvalidMode(
        -: 2949:        void
        -: 2950:    )
        -: 2951:  {
        -: 2952:  
        -: 2953:
        -: 2954:    // Get the time
      126: 2955:    Fw::Time _logTime;
       63: 2956:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       63: 2957:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 2958:    }
        -: 2959:    
       63: 2960:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 2961:    
       63: 2962:    _id = this->getIdBase() + EVENTID_CS_INVALIDMODE;
        -: 2963:
        -: 2964:    // Emit the event on the log port
       63: 2965:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 2966:
      126: 2967:      Fw::LogBuffer _logBuff;
        -: 2968:#if FW_AMPCS_COMPATIBLE
        -: 2969:      // for AMPCS, need to encode zero arguments
        -: 2970:      Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
        -: 2971:      _zero_status = _logBuff.serialize(static_cast<U8>(0));
        -: 2972:      FW_ASSERT(
        -: 2973:          _zero_status == Fw::FW_SERIALIZE_OK,
        -: 2974:          static_cast<AssertArg>(_zero_status)
        -: 2975:      );
        -: 2976:#endif
        -: 2977:
        -: 2978:
       63: 2979:      this->m_logOut_OutputPort[0].invoke(
        -: 2980:          _id,
        -: 2981:          _logTime,Fw::LOG_WARNING_HI,
        -: 2982:          _logBuff
       63: 2983:      );
        -: 2984:
        -: 2985:    }
        -: 2986:
        -: 2987:    // Emit the event on the text log port
        -: 2988:#if FW_ENABLE_TEXT_LOGGING
       63: 2989:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 2990:
        -: 2991:#if FW_OBJECT_NAMES == 1
        -: 2992:      const char* _formatString =
       63: 2993:        "(%s) %s: Invalid mode";
        -: 2994:#else
        -: 2995:      const char* _formatString =
        -: 2996:        "%s: Invalid mode";
        -: 2997:#endif
        -: 2998:
        -: 2999:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3000:
       63: 3001:      (void) snprintf(
        -: 3002:          _textBuffer,
        -: 3003:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3004:          _formatString,
        -: 3005:#if FW_OBJECT_NAMES == 1
        -: 3006:          this->m_objName,
        -: 3007:#endif
        -: 3008:          "CS_InvalidMode "
       63: 3009:      );
        -: 3010:
        -: 3011:      // Null terminate
       63: 3012:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      126: 3013:      Fw::TextLogString _logString = _textBuffer;
       63: 3014:      this->m_LogText_OutputPort[0].invoke(
        -: 3015:          _id,
        -: 3016:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 3017:          _logString
       63: 3018:      );
        -: 3019:
        -: 3020:    }
        -: 3021:#endif
        -: 3022:
       63: 3023:  }
        -: 3024:  
        -: 3025:
        7: 3026:  void CmdSequencerComponentBase ::
        -: 3027:    log_WARNING_HI_CS_RecordMismatch(
        -: 3028:        Fw::LogStringArg& fileName, U32 header_records, U32 extra_bytes
        -: 3029:    )
        -: 3030:  {
        -: 3031:  
        -: 3032:
        -: 3033:    // Get the time
       14: 3034:    Fw::Time _logTime;
        7: 3035:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        7: 3036:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3037:    }
        -: 3038:    
        7: 3039:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3040:    
        7: 3041:    _id = this->getIdBase() + EVENTID_CS_RECORDMISMATCH;
        -: 3042:
        -: 3043:    // Emit the event on the log port
        7: 3044:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3045:
       14: 3046:      Fw::LogBuffer _logBuff;
        7: 3047:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3048:
        -: 3049:#if FW_AMPCS_COMPATIBLE
        -: 3050:      // Serialize the number of arguments
        -: 3051:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 3052:      FW_ASSERT(
        -: 3053:          _status == Fw::FW_SERIALIZE_OK,
        -: 3054:          static_cast<AssertArg>(_status)
        -: 3055:      );
        -: 3056:#endif
        -: 3057:
        7: 3058:      fileName.setMaxSerialize(60);
        7: 3059:      _status = _logBuff.serialize(fileName);
        -: 3060:      FW_ASSERT(
        -: 3061:          _status == Fw::FW_SERIALIZE_OK,
        -: 3062:          static_cast<AssertArg>(_status)
        7: 3063:      );
        -: 3064:
        -: 3065:#if FW_AMPCS_COMPATIBLE
        -: 3066:      // Serialize the argument size
        -: 3067:      _status = _logBuff.serialize(
        -: 3068:          static_cast<U8>(sizeof(header_records))
        -: 3069:      );
        -: 3070:      FW_ASSERT(
        -: 3071:          _status == Fw::FW_SERIALIZE_OK,
        -: 3072:          static_cast<AssertArg>(_status)
        -: 3073:      );
        -: 3074:#endif
        -: 3075:
        7: 3076:      _status = _logBuff.serialize(header_records);
        -: 3077:      FW_ASSERT(
        -: 3078:          _status == Fw::FW_SERIALIZE_OK,
        -: 3079:          static_cast<AssertArg>(_status)
        7: 3080:      );
        -: 3081:
        -: 3082:#if FW_AMPCS_COMPATIBLE
        -: 3083:      // Serialize the argument size
        -: 3084:      _status = _logBuff.serialize(
        -: 3085:          static_cast<U8>(sizeof(extra_bytes))
        -: 3086:      );
        -: 3087:      FW_ASSERT(
        -: 3088:          _status == Fw::FW_SERIALIZE_OK,
        -: 3089:          static_cast<AssertArg>(_status)
        -: 3090:      );
        -: 3091:#endif
        -: 3092:
        7: 3093:      _status = _logBuff.serialize(extra_bytes);
        -: 3094:      FW_ASSERT(
        -: 3095:          _status == Fw::FW_SERIALIZE_OK,
        -: 3096:          static_cast<AssertArg>(_status)
        7: 3097:      );
        -: 3098:
        -: 3099:
        7: 3100:      this->m_logOut_OutputPort[0].invoke(
        -: 3101:          _id,
        -: 3102:          _logTime,Fw::LOG_WARNING_HI,
        -: 3103:          _logBuff
        7: 3104:      );
        -: 3105:
        -: 3106:    }
        -: 3107:
        -: 3108:    // Emit the event on the text log port
        -: 3109:#if FW_ENABLE_TEXT_LOGGING
        7: 3110:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3111:
        -: 3112:#if FW_OBJECT_NAMES == 1
        -: 3113:      const char* _formatString =
        7: 3114:        "(%s) %s: Sequence file %s header records mismatch: %d in header, found %d extra bytes.";
        -: 3115:#else
        -: 3116:      const char* _formatString =
        -: 3117:        "%s: Sequence file %s header records mismatch: %d in header, found %d extra bytes.";
        -: 3118:#endif
        -: 3119:
        -: 3120:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3121:
        7: 3122:      (void) snprintf(
        -: 3123:          _textBuffer,
        -: 3124:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3125:          _formatString,
        -: 3126:#if FW_OBJECT_NAMES == 1
        -: 3127:          this->m_objName,
        -: 3128:#endif
        -: 3129:          "CS_RecordMismatch "
        7: 3130:        , fileName.toChar()
        -: 3131:        , header_records
        -: 3132:        , extra_bytes
        7: 3133:      );
        -: 3134:
        -: 3135:      // Null terminate
        7: 3136:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       14: 3137:      Fw::TextLogString _logString = _textBuffer;
        7: 3138:      this->m_LogText_OutputPort[0].invoke(
        -: 3139:          _id,
        -: 3140:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 3141:          _logString
        7: 3142:      );
        -: 3143:
        -: 3144:    }
        -: 3145:#endif
        -: 3146:
        7: 3147:  }
        -: 3148:  
        -: 3149:
        9: 3150:  void CmdSequencerComponentBase ::
        -: 3151:    log_WARNING_HI_CS_TimeBaseMismatch(
        -: 3152:        Fw::LogStringArg& fileName, U16 time_base, U16 seq_time_base
        -: 3153:    )
        -: 3154:  {
        -: 3155:  
        -: 3156:
        -: 3157:    // Get the time
       18: 3158:    Fw::Time _logTime;
        9: 3159:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 3160:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3161:    }
        -: 3162:    
        9: 3163:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3164:    
        9: 3165:    _id = this->getIdBase() + EVENTID_CS_TIMEBASEMISMATCH;
        -: 3166:
        -: 3167:    // Emit the event on the log port
        9: 3168:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3169:
       18: 3170:      Fw::LogBuffer _logBuff;
        9: 3171:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3172:
        -: 3173:#if FW_AMPCS_COMPATIBLE
        -: 3174:      // Serialize the number of arguments
        -: 3175:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 3176:      FW_ASSERT(
        -: 3177:          _status == Fw::FW_SERIALIZE_OK,
        -: 3178:          static_cast<AssertArg>(_status)
        -: 3179:      );
        -: 3180:#endif
        -: 3181:
        9: 3182:      fileName.setMaxSerialize(60);
        9: 3183:      _status = _logBuff.serialize(fileName);
        -: 3184:      FW_ASSERT(
        -: 3185:          _status == Fw::FW_SERIALIZE_OK,
        -: 3186:          static_cast<AssertArg>(_status)
        9: 3187:      );
        -: 3188:
        -: 3189:#if FW_AMPCS_COMPATIBLE
        -: 3190:      // Serialize the argument size
        -: 3191:      _status = _logBuff.serialize(
        -: 3192:          static_cast<U8>(sizeof(time_base))
        -: 3193:      );
        -: 3194:      FW_ASSERT(
        -: 3195:          _status == Fw::FW_SERIALIZE_OK,
        -: 3196:          static_cast<AssertArg>(_status)
        -: 3197:      );
        -: 3198:#endif
        -: 3199:
        9: 3200:      _status = _logBuff.serialize(time_base);
        -: 3201:      FW_ASSERT(
        -: 3202:          _status == Fw::FW_SERIALIZE_OK,
        -: 3203:          static_cast<AssertArg>(_status)
        9: 3204:      );
        -: 3205:
        -: 3206:#if FW_AMPCS_COMPATIBLE
        -: 3207:      // Serialize the argument size
        -: 3208:      _status = _logBuff.serialize(
        -: 3209:          static_cast<U8>(sizeof(seq_time_base))
        -: 3210:      );
        -: 3211:      FW_ASSERT(
        -: 3212:          _status == Fw::FW_SERIALIZE_OK,
        -: 3213:          static_cast<AssertArg>(_status)
        -: 3214:      );
        -: 3215:#endif
        -: 3216:
        9: 3217:      _status = _logBuff.serialize(seq_time_base);
        -: 3218:      FW_ASSERT(
        -: 3219:          _status == Fw::FW_SERIALIZE_OK,
        -: 3220:          static_cast<AssertArg>(_status)
        9: 3221:      );
        -: 3222:
        -: 3223:
        9: 3224:      this->m_logOut_OutputPort[0].invoke(
        -: 3225:          _id,
        -: 3226:          _logTime,Fw::LOG_WARNING_HI,
        -: 3227:          _logBuff
        9: 3228:      );
        -: 3229:
        -: 3230:    }
        -: 3231:
        -: 3232:    // Emit the event on the text log port
        -: 3233:#if FW_ENABLE_TEXT_LOGGING
        9: 3234:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3235:
        -: 3236:#if FW_OBJECT_NAMES == 1
        -: 3237:      const char* _formatString =
        9: 3238:        "(%s) %s: Sequence file %s: Current time base doesn't match sequence time: base: %d seq: %d";
        -: 3239:#else
        -: 3240:      const char* _formatString =
        -: 3241:        "%s: Sequence file %s: Current time base doesn't match sequence time: base: %d seq: %d";
        -: 3242:#endif
        -: 3243:
        -: 3244:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3245:
       18: 3246:      (void) snprintf(
        -: 3247:          _textBuffer,
        -: 3248:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3249:          _formatString,
        -: 3250:#if FW_OBJECT_NAMES == 1
        -: 3251:          this->m_objName,
        -: 3252:#endif
        -: 3253:          "CS_TimeBaseMismatch "
        9: 3254:        , fileName.toChar()
        -: 3255:        , time_base
        -: 3256:        , seq_time_base
        9: 3257:      );
        -: 3258:
        -: 3259:      // Null terminate
        9: 3260:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 3261:      Fw::TextLogString _logString = _textBuffer;
        9: 3262:      this->m_LogText_OutputPort[0].invoke(
        -: 3263:          _id,
        -: 3264:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 3265:          _logString
        9: 3266:      );
        -: 3267:
        -: 3268:    }
        -: 3269:#endif
        -: 3270:
        9: 3271:  }
        -: 3272:  
        -: 3273:
        9: 3274:  void CmdSequencerComponentBase ::
        -: 3275:    log_WARNING_HI_CS_TimeContextMismatch(
        -: 3276:        Fw::LogStringArg& fileName, U8 currTimeBase, U8 seqTimeBase
        -: 3277:    )
        -: 3278:  {
        -: 3279:  
        -: 3280:
        -: 3281:    // Get the time
       18: 3282:    Fw::Time _logTime;
        9: 3283:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 3284:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3285:    }
        -: 3286:    
        9: 3287:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3288:    
        9: 3289:    _id = this->getIdBase() + EVENTID_CS_TIMECONTEXTMISMATCH;
        -: 3290:
        -: 3291:    // Emit the event on the log port
        9: 3292:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3293:
       18: 3294:      Fw::LogBuffer _logBuff;
        9: 3295:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3296:
        -: 3297:#if FW_AMPCS_COMPATIBLE
        -: 3298:      // Serialize the number of arguments
        -: 3299:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 3300:      FW_ASSERT(
        -: 3301:          _status == Fw::FW_SERIALIZE_OK,
        -: 3302:          static_cast<AssertArg>(_status)
        -: 3303:      );
        -: 3304:#endif
        -: 3305:
        9: 3306:      fileName.setMaxSerialize(60);
        9: 3307:      _status = _logBuff.serialize(fileName);
        -: 3308:      FW_ASSERT(
        -: 3309:          _status == Fw::FW_SERIALIZE_OK,
        -: 3310:          static_cast<AssertArg>(_status)
        9: 3311:      );
        -: 3312:
        -: 3313:#if FW_AMPCS_COMPATIBLE
        -: 3314:      // Serialize the argument size
        -: 3315:      _status = _logBuff.serialize(
        -: 3316:          static_cast<U8>(sizeof(currTimeBase))
        -: 3317:      );
        -: 3318:      FW_ASSERT(
        -: 3319:          _status == Fw::FW_SERIALIZE_OK,
        -: 3320:          static_cast<AssertArg>(_status)
        -: 3321:      );
        -: 3322:#endif
        -: 3323:
        9: 3324:      _status = _logBuff.serialize(currTimeBase);
        -: 3325:      FW_ASSERT(
        -: 3326:          _status == Fw::FW_SERIALIZE_OK,
        -: 3327:          static_cast<AssertArg>(_status)
        9: 3328:      );
        -: 3329:
        -: 3330:#if FW_AMPCS_COMPATIBLE
        -: 3331:      // Serialize the argument size
        -: 3332:      _status = _logBuff.serialize(
        -: 3333:          static_cast<U8>(sizeof(seqTimeBase))
        -: 3334:      );
        -: 3335:      FW_ASSERT(
        -: 3336:          _status == Fw::FW_SERIALIZE_OK,
        -: 3337:          static_cast<AssertArg>(_status)
        -: 3338:      );
        -: 3339:#endif
        -: 3340:
        9: 3341:      _status = _logBuff.serialize(seqTimeBase);
        -: 3342:      FW_ASSERT(
        -: 3343:          _status == Fw::FW_SERIALIZE_OK,
        -: 3344:          static_cast<AssertArg>(_status)
        9: 3345:      );
        -: 3346:
        -: 3347:
        9: 3348:      this->m_logOut_OutputPort[0].invoke(
        -: 3349:          _id,
        -: 3350:          _logTime,Fw::LOG_WARNING_HI,
        -: 3351:          _logBuff
        9: 3352:      );
        -: 3353:
        -: 3354:    }
        -: 3355:
        -: 3356:    // Emit the event on the text log port
        -: 3357:#if FW_ENABLE_TEXT_LOGGING
        9: 3358:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3359:
        -: 3360:#if FW_OBJECT_NAMES == 1
        -: 3361:      const char* _formatString =
        9: 3362:        "(%s) %s: Sequence file %s: Current time context doesn't match sequence context: base: %d seq: %d";
        -: 3363:#else
        -: 3364:      const char* _formatString =
        -: 3365:        "%s: Sequence file %s: Current time context doesn't match sequence context: base: %d seq: %d";
        -: 3366:#endif
        -: 3367:
        -: 3368:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3369:
       18: 3370:      (void) snprintf(
        -: 3371:          _textBuffer,
        -: 3372:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3373:          _formatString,
        -: 3374:#if FW_OBJECT_NAMES == 1
        -: 3375:          this->m_objName,
        -: 3376:#endif
        -: 3377:          "CS_TimeContextMismatch "
        9: 3378:        , fileName.toChar()
        -: 3379:        , currTimeBase
        -: 3380:        , seqTimeBase
        9: 3381:      );
        -: 3382:
        -: 3383:      // Null terminate
        9: 3384:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 3385:      Fw::TextLogString _logString = _textBuffer;
        9: 3386:      this->m_LogText_OutputPort[0].invoke(
        -: 3387:          _id,
        -: 3388:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 3389:          _logString
        9: 3390:      );
        -: 3391:
        -: 3392:    }
        -: 3393:#endif
        -: 3394:
        9: 3395:  }
        -: 3396:  
        -: 3397:
        9: 3398:  void CmdSequencerComponentBase ::
        -: 3399:    log_ACTIVITY_HI_CS_PortSequenceStarted(
        -: 3400:        Fw::LogStringArg& filename
        -: 3401:    )
        -: 3402:  {
        -: 3403:  
        -: 3404:
        -: 3405:    // Get the time
       18: 3406:    Fw::Time _logTime;
        9: 3407:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 3408:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3409:    }
        -: 3410:    
        9: 3411:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3412:    
        9: 3413:    _id = this->getIdBase() + EVENTID_CS_PORTSEQUENCESTARTED;
        -: 3414:
        -: 3415:    // Emit the event on the log port
        9: 3416:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3417:
       18: 3418:      Fw::LogBuffer _logBuff;
        9: 3419:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3420:
        -: 3421:#if FW_AMPCS_COMPATIBLE
        -: 3422:      // Serialize the number of arguments
        -: 3423:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 3424:      FW_ASSERT(
        -: 3425:          _status == Fw::FW_SERIALIZE_OK,
        -: 3426:          static_cast<AssertArg>(_status)
        -: 3427:      );
        -: 3428:#endif
        -: 3429:
        9: 3430:      filename.setMaxSerialize(60);
        9: 3431:      _status = _logBuff.serialize(filename);
        -: 3432:      FW_ASSERT(
        -: 3433:          _status == Fw::FW_SERIALIZE_OK,
        -: 3434:          static_cast<AssertArg>(_status)
        9: 3435:      );
        -: 3436:
        -: 3437:
        9: 3438:      this->m_logOut_OutputPort[0].invoke(
        -: 3439:          _id,
        -: 3440:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 3441:          _logBuff
        9: 3442:      );
        -: 3443:
        -: 3444:    }
        -: 3445:
        -: 3446:    // Emit the event on the text log port
        -: 3447:#if FW_ENABLE_TEXT_LOGGING
        9: 3448:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3449:
        -: 3450:#if FW_OBJECT_NAMES == 1
        -: 3451:      const char* _formatString =
        9: 3452:        "(%s) %s: Local request for sequence %s started.";
        -: 3453:#else
        -: 3454:      const char* _formatString =
        -: 3455:        "%s: Local request for sequence %s started.";
        -: 3456:#endif
        -: 3457:
        -: 3458:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3459:
        9: 3460:      (void) snprintf(
        -: 3461:          _textBuffer,
        -: 3462:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3463:          _formatString,
        -: 3464:#if FW_OBJECT_NAMES == 1
        -: 3465:          this->m_objName,
        -: 3466:#endif
        -: 3467:          "CS_PortSequenceStarted "
        9: 3468:        , filename.toChar()
        9: 3469:      );
        -: 3470:
        -: 3471:      // Null terminate
        9: 3472:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 3473:      Fw::TextLogString _logString = _textBuffer;
        9: 3474:      this->m_LogText_OutputPort[0].invoke(
        -: 3475:          _id,
        -: 3476:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 3477:          _logString
        9: 3478:      );
        -: 3479:
        -: 3480:    }
        -: 3481:#endif
        -: 3482:
        9: 3483:  }
        -: 3484:  
        -: 3485:
        9: 3486:  void CmdSequencerComponentBase ::
        -: 3487:    log_WARNING_HI_CS_UnexpectedCompletion(
        -: 3488:        U32 opcode
        -: 3489:    )
        -: 3490:  {
        -: 3491:  
        -: 3492:
        -: 3493:    // Get the time
       18: 3494:    Fw::Time _logTime;
        9: 3495:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 3496:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3497:    }
        -: 3498:    
        9: 3499:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3500:    
        9: 3501:    _id = this->getIdBase() + EVENTID_CS_UNEXPECTEDCOMPLETION;
        -: 3502:
        -: 3503:    // Emit the event on the log port
        9: 3504:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3505:
       18: 3506:      Fw::LogBuffer _logBuff;
        9: 3507:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3508:
        -: 3509:#if FW_AMPCS_COMPATIBLE
        -: 3510:      // Serialize the number of arguments
        -: 3511:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 3512:      FW_ASSERT(
        -: 3513:          _status == Fw::FW_SERIALIZE_OK,
        -: 3514:          static_cast<AssertArg>(_status)
        -: 3515:      );
        -: 3516:#endif
        -: 3517:
        -: 3518:#if FW_AMPCS_COMPATIBLE
        -: 3519:      // Serialize the argument size
        -: 3520:      _status = _logBuff.serialize(
        -: 3521:          static_cast<U8>(sizeof(opcode))
        -: 3522:      );
        -: 3523:      FW_ASSERT(
        -: 3524:          _status == Fw::FW_SERIALIZE_OK,
        -: 3525:          static_cast<AssertArg>(_status)
        -: 3526:      );
        -: 3527:#endif
        -: 3528:
        9: 3529:      _status = _logBuff.serialize(opcode);
        -: 3530:      FW_ASSERT(
        -: 3531:          _status == Fw::FW_SERIALIZE_OK,
        -: 3532:          static_cast<AssertArg>(_status)
        9: 3533:      );
        -: 3534:
        -: 3535:
        9: 3536:      this->m_logOut_OutputPort[0].invoke(
        -: 3537:          _id,
        -: 3538:          _logTime,Fw::LOG_WARNING_HI,
        -: 3539:          _logBuff
        9: 3540:      );
        -: 3541:
        -: 3542:    }
        -: 3543:
        -: 3544:    // Emit the event on the text log port
        -: 3545:#if FW_ENABLE_TEXT_LOGGING
        9: 3546:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3547:
        -: 3548:#if FW_OBJECT_NAMES == 1
        -: 3549:      const char* _formatString =
        9: 3550:        "(%s) %s: Command complete status received while no sequences active. Opcode: %d";
        -: 3551:#else
        -: 3552:      const char* _formatString =
        -: 3553:        "%s: Command complete status received while no sequences active. Opcode: %d";
        -: 3554:#endif
        -: 3555:
        -: 3556:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3557:
        9: 3558:      (void) snprintf(
        -: 3559:          _textBuffer,
        -: 3560:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3561:          _formatString,
        -: 3562:#if FW_OBJECT_NAMES == 1
        -: 3563:          this->m_objName,
        -: 3564:#endif
        -: 3565:          "CS_UnexpectedCompletion "
        -: 3566:        , opcode
        9: 3567:      );
        -: 3568:
        -: 3569:      // Null terminate
        9: 3570:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 3571:      Fw::TextLogString _logString = _textBuffer;
        9: 3572:      this->m_LogText_OutputPort[0].invoke(
        -: 3573:          _id,
        -: 3574:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 3575:          _logString
        9: 3576:      );
        -: 3577:
        -: 3578:    }
        -: 3579:#endif
        -: 3580:
        9: 3581:  }
        -: 3582:  
        -: 3583:
       27: 3584:  void CmdSequencerComponentBase ::
        -: 3585:    log_ACTIVITY_HI_CS_ModeSwitched(
        -: 3586:        SeqMode mode
        -: 3587:    )
        -: 3588:  {
        -: 3589:  
        -: 3590:
        -: 3591:    // Get the time
       54: 3592:    Fw::Time _logTime;
       27: 3593:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       27: 3594:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3595:    }
        -: 3596:    
       27: 3597:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3598:    
       27: 3599:    _id = this->getIdBase() + EVENTID_CS_MODESWITCHED;
        -: 3600:
        -: 3601:    // Emit the event on the log port
       27: 3602:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3603:
       54: 3604:      Fw::LogBuffer _logBuff;
       27: 3605:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3606:
        -: 3607:#if FW_AMPCS_COMPATIBLE
        -: 3608:      // Serialize the number of arguments
        -: 3609:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 3610:      FW_ASSERT(
        -: 3611:          _status == Fw::FW_SERIALIZE_OK,
        -: 3612:          static_cast<AssertArg>(_status)
        -: 3613:      );
        -: 3614:#endif
        -: 3615:
        -: 3616:#if FW_AMPCS_COMPATIBLE
        -: 3617:      // Serialize the argument size
        -: 3618:      _status = _logBuff.serialize(static_cast<U8>(sizeof(FwEnumStoreType)));
        -: 3619:      FW_ASSERT(
        -: 3620:          _status == Fw::FW_SERIALIZE_OK,
        -: 3621:          static_cast<AssertArg>(_status)
        -: 3622:      );
        -: 3623:#endif
        -: 3624:
       27: 3625:      _status = _logBuff.serialize(
        -: 3626:          static_cast<FwEnumStoreType>(mode)
       27: 3627:      );
        -: 3628:      FW_ASSERT(
        -: 3629:          _status == Fw::FW_SERIALIZE_OK,
        -: 3630:          static_cast<AssertArg>(_status)
       27: 3631:      );
        -: 3632:
        -: 3633:
       27: 3634:      this->m_logOut_OutputPort[0].invoke(
        -: 3635:          _id,
        -: 3636:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 3637:          _logBuff
       27: 3638:      );
        -: 3639:
        -: 3640:    }
        -: 3641:
        -: 3642:    // Emit the event on the text log port
        -: 3643:#if FW_ENABLE_TEXT_LOGGING
       27: 3644:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3645:
        -: 3646:#if FW_OBJECT_NAMES == 1
        -: 3647:      const char* _formatString =
       27: 3648:        "(%s) %s: Sequencer switched to %d step mode";
        -: 3649:#else
        -: 3650:      const char* _formatString =
        -: 3651:        "%s: Sequencer switched to %d step mode";
        -: 3652:#endif
        -: 3653:
        -: 3654:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3655:
       27: 3656:      (void) snprintf(
        -: 3657:          _textBuffer,
        -: 3658:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3659:          _formatString,
        -: 3660:#if FW_OBJECT_NAMES == 1
        -: 3661:          this->m_objName,
        -: 3662:#endif
        -: 3663:          "CS_ModeSwitched "
        -: 3664:        , mode
       27: 3665:      );
        -: 3666:
        -: 3667:      // Null terminate
       27: 3668:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       54: 3669:      Fw::TextLogString _logString = _textBuffer;
       27: 3670:      this->m_LogText_OutputPort[0].invoke(
        -: 3671:          _id,
        -: 3672:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 3673:          _logString
       27: 3674:      );
        -: 3675:
        -: 3676:    }
        -: 3677:#endif
        -: 3678:
       27: 3679:  }
        -: 3680:  
        -: 3681:
       18: 3682:  void CmdSequencerComponentBase ::
        -: 3683:    log_WARNING_LO_CS_NoSequenceActive(
        -: 3684:        void
        -: 3685:    )
        -: 3686:  {
        -: 3687:  
        -: 3688:
        -: 3689:    // Get the time
       36: 3690:    Fw::Time _logTime;
       18: 3691:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       18: 3692:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3693:    }
        -: 3694:    
       18: 3695:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3696:    
       18: 3697:    _id = this->getIdBase() + EVENTID_CS_NOSEQUENCEACTIVE;
        -: 3698:
        -: 3699:    // Emit the event on the log port
       18: 3700:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3701:
       36: 3702:      Fw::LogBuffer _logBuff;
        -: 3703:#if FW_AMPCS_COMPATIBLE
        -: 3704:      // for AMPCS, need to encode zero arguments
        -: 3705:      Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
        -: 3706:      _zero_status = _logBuff.serialize(static_cast<U8>(0));
        -: 3707:      FW_ASSERT(
        -: 3708:          _zero_status == Fw::FW_SERIALIZE_OK,
        -: 3709:          static_cast<AssertArg>(_zero_status)
        -: 3710:      );
        -: 3711:#endif
        -: 3712:
        -: 3713:
       18: 3714:      this->m_logOut_OutputPort[0].invoke(
        -: 3715:          _id,
        -: 3716:          _logTime,Fw::LOG_WARNING_LO,
        -: 3717:          _logBuff
       18: 3718:      );
        -: 3719:
        -: 3720:    }
        -: 3721:
        -: 3722:    // Emit the event on the text log port
        -: 3723:#if FW_ENABLE_TEXT_LOGGING
       18: 3724:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3725:
        -: 3726:#if FW_OBJECT_NAMES == 1
        -: 3727:      const char* _formatString =
       18: 3728:        "(%s) %s: No sequence active.";
        -: 3729:#else
        -: 3730:      const char* _formatString =
        -: 3731:        "%s: No sequence active.";
        -: 3732:#endif
        -: 3733:
        -: 3734:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3735:
       18: 3736:      (void) snprintf(
        -: 3737:          _textBuffer,
        -: 3738:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3739:          _formatString,
        -: 3740:#if FW_OBJECT_NAMES == 1
        -: 3741:          this->m_objName,
        -: 3742:#endif
        -: 3743:          "CS_NoSequenceActive "
       18: 3744:      );
        -: 3745:
        -: 3746:      // Null terminate
       18: 3747:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       36: 3748:      Fw::TextLogString _logString = _textBuffer;
       18: 3749:      this->m_LogText_OutputPort[0].invoke(
        -: 3750:          _id,
        -: 3751:          _logTime,Fw::TEXT_LOG_WARNING_LO,
        -: 3752:          _logString
       18: 3753:      );
        -: 3754:
        -: 3755:    }
        -: 3756:#endif
        -: 3757:
       18: 3758:  }
        -: 3759:  
        -: 3760:
      108: 3761:  void CmdSequencerComponentBase ::
        -: 3762:    log_ACTIVITY_HI_CS_SequenceValid(
        -: 3763:        Fw::LogStringArg& filename
        -: 3764:    )
        -: 3765:  {
        -: 3766:  
        -: 3767:
        -: 3768:    // Get the time
      216: 3769:    Fw::Time _logTime;
      108: 3770:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
      108: 3771:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3772:    }
        -: 3773:    
      108: 3774:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3775:    
      108: 3776:    _id = this->getIdBase() + EVENTID_CS_SEQUENCEVALID;
        -: 3777:
        -: 3778:    // Emit the event on the log port
      108: 3779:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3780:
      216: 3781:      Fw::LogBuffer _logBuff;
      108: 3782:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3783:
        -: 3784:#if FW_AMPCS_COMPATIBLE
        -: 3785:      // Serialize the number of arguments
        -: 3786:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 3787:      FW_ASSERT(
        -: 3788:          _status == Fw::FW_SERIALIZE_OK,
        -: 3789:          static_cast<AssertArg>(_status)
        -: 3790:      );
        -: 3791:#endif
        -: 3792:
      108: 3793:      filename.setMaxSerialize(60);
      108: 3794:      _status = _logBuff.serialize(filename);
        -: 3795:      FW_ASSERT(
        -: 3796:          _status == Fw::FW_SERIALIZE_OK,
        -: 3797:          static_cast<AssertArg>(_status)
      108: 3798:      );
        -: 3799:
        -: 3800:
      108: 3801:      this->m_logOut_OutputPort[0].invoke(
        -: 3802:          _id,
        -: 3803:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 3804:          _logBuff
      108: 3805:      );
        -: 3806:
        -: 3807:    }
        -: 3808:
        -: 3809:    // Emit the event on the text log port
        -: 3810:#if FW_ENABLE_TEXT_LOGGING
      108: 3811:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3812:
        -: 3813:#if FW_OBJECT_NAMES == 1
        -: 3814:      const char* _formatString =
      108: 3815:        "(%s) %s: Sequence %s is valid.";
        -: 3816:#else
        -: 3817:      const char* _formatString =
        -: 3818:        "%s: Sequence %s is valid.";
        -: 3819:#endif
        -: 3820:
        -: 3821:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3822:
      108: 3823:      (void) snprintf(
        -: 3824:          _textBuffer,
        -: 3825:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3826:          _formatString,
        -: 3827:#if FW_OBJECT_NAMES == 1
        -: 3828:          this->m_objName,
        -: 3829:#endif
        -: 3830:          "CS_SequenceValid "
      108: 3831:        , filename.toChar()
      108: 3832:      );
        -: 3833:
        -: 3834:      // Null terminate
      108: 3835:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      216: 3836:      Fw::TextLogString _logString = _textBuffer;
      108: 3837:      this->m_LogText_OutputPort[0].invoke(
        -: 3838:          _id,
        -: 3839:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 3840:          _logString
      108: 3841:      );
        -: 3842:
        -: 3843:    }
        -: 3844:#endif
        -: 3845:
      108: 3846:  }
        -: 3847:  
        -: 3848:
        9: 3849:  void CmdSequencerComponentBase ::
        -: 3850:    log_WARNING_HI_CS_SequenceTimeout(
        -: 3851:        Fw::LogStringArg& filename, U32 command
        -: 3852:    )
        -: 3853:  {
        -: 3854:  
        -: 3855:
        -: 3856:    // Get the time
       18: 3857:    Fw::Time _logTime;
        9: 3858:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
        9: 3859:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3860:    }
        -: 3861:    
        9: 3862:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3863:    
        9: 3864:    _id = this->getIdBase() + EVENTID_CS_SEQUENCETIMEOUT;
        -: 3865:
        -: 3866:    // Emit the event on the log port
        9: 3867:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3868:
       18: 3869:      Fw::LogBuffer _logBuff;
        9: 3870:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3871:
        -: 3872:#if FW_AMPCS_COMPATIBLE
        -: 3873:      // Serialize the number of arguments
        -: 3874:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 3875:      FW_ASSERT(
        -: 3876:          _status == Fw::FW_SERIALIZE_OK,
        -: 3877:          static_cast<AssertArg>(_status)
        -: 3878:      );
        -: 3879:#endif
        -: 3880:
        9: 3881:      filename.setMaxSerialize(60);
        9: 3882:      _status = _logBuff.serialize(filename);
        -: 3883:      FW_ASSERT(
        -: 3884:          _status == Fw::FW_SERIALIZE_OK,
        -: 3885:          static_cast<AssertArg>(_status)
        9: 3886:      );
        -: 3887:
        -: 3888:#if FW_AMPCS_COMPATIBLE
        -: 3889:      // Serialize the argument size
        -: 3890:      _status = _logBuff.serialize(
        -: 3891:          static_cast<U8>(sizeof(command))
        -: 3892:      );
        -: 3893:      FW_ASSERT(
        -: 3894:          _status == Fw::FW_SERIALIZE_OK,
        -: 3895:          static_cast<AssertArg>(_status)
        -: 3896:      );
        -: 3897:#endif
        -: 3898:
        9: 3899:      _status = _logBuff.serialize(command);
        -: 3900:      FW_ASSERT(
        -: 3901:          _status == Fw::FW_SERIALIZE_OK,
        -: 3902:          static_cast<AssertArg>(_status)
        9: 3903:      );
        -: 3904:
        -: 3905:
        9: 3906:      this->m_logOut_OutputPort[0].invoke(
        -: 3907:          _id,
        -: 3908:          _logTime,Fw::LOG_WARNING_HI,
        -: 3909:          _logBuff
        9: 3910:      );
        -: 3911:
        -: 3912:    }
        -: 3913:
        -: 3914:    // Emit the event on the text log port
        -: 3915:#if FW_ENABLE_TEXT_LOGGING
        9: 3916:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 3917:
        -: 3918:#if FW_OBJECT_NAMES == 1
        -: 3919:      const char* _formatString =
        9: 3920:        "(%s) %s: Sequence %s timed out on command %d";
        -: 3921:#else
        -: 3922:      const char* _formatString =
        -: 3923:        "%s: Sequence %s timed out on command %d";
        -: 3924:#endif
        -: 3925:
        -: 3926:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 3927:
        9: 3928:      (void) snprintf(
        -: 3929:          _textBuffer,
        -: 3930:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 3931:          _formatString,
        -: 3932:#if FW_OBJECT_NAMES == 1
        -: 3933:          this->m_objName,
        -: 3934:#endif
        -: 3935:          "CS_SequenceTimeout "
        9: 3936:        , filename.toChar()
        -: 3937:        , command
        9: 3938:      );
        -: 3939:
        -: 3940:      // Null terminate
        9: 3941:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       18: 3942:      Fw::TextLogString _logString = _textBuffer;
        9: 3943:      this->m_LogText_OutputPort[0].invoke(
        -: 3944:          _id,
        -: 3945:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 3946:          _logString
        9: 3947:      );
        -: 3948:
        -: 3949:    }
        -: 3950:#endif
        -: 3951:
        9: 3952:  }
        -: 3953:  
        -: 3954:
       63: 3955:  void CmdSequencerComponentBase ::
        -: 3956:    log_ACTIVITY_HI_CS_CmdStepped(
        -: 3957:        Fw::LogStringArg& filename, U32 command
        -: 3958:    )
        -: 3959:  {
        -: 3960:  
        -: 3961:
        -: 3962:    // Get the time
      126: 3963:    Fw::Time _logTime;
       63: 3964:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       63: 3965:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 3966:    }
        -: 3967:    
       63: 3968:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 3969:    
       63: 3970:    _id = this->getIdBase() + EVENTID_CS_CMDSTEPPED;
        -: 3971:
        -: 3972:    // Emit the event on the log port
       63: 3973:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 3974:
      126: 3975:      Fw::LogBuffer _logBuff;
       63: 3976:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 3977:
        -: 3978:#if FW_AMPCS_COMPATIBLE
        -: 3979:      // Serialize the number of arguments
        -: 3980:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 3981:      FW_ASSERT(
        -: 3982:          _status == Fw::FW_SERIALIZE_OK,
        -: 3983:          static_cast<AssertArg>(_status)
        -: 3984:      );
        -: 3985:#endif
        -: 3986:
       63: 3987:      filename.setMaxSerialize(60);
       63: 3988:      _status = _logBuff.serialize(filename);
        -: 3989:      FW_ASSERT(
        -: 3990:          _status == Fw::FW_SERIALIZE_OK,
        -: 3991:          static_cast<AssertArg>(_status)
       63: 3992:      );
        -: 3993:
        -: 3994:#if FW_AMPCS_COMPATIBLE
        -: 3995:      // Serialize the argument size
        -: 3996:      _status = _logBuff.serialize(
        -: 3997:          static_cast<U8>(sizeof(command))
        -: 3998:      );
        -: 3999:      FW_ASSERT(
        -: 4000:          _status == Fw::FW_SERIALIZE_OK,
        -: 4001:          static_cast<AssertArg>(_status)
        -: 4002:      );
        -: 4003:#endif
        -: 4004:
       63: 4005:      _status = _logBuff.serialize(command);
        -: 4006:      FW_ASSERT(
        -: 4007:          _status == Fw::FW_SERIALIZE_OK,
        -: 4008:          static_cast<AssertArg>(_status)
       63: 4009:      );
        -: 4010:
        -: 4011:
       63: 4012:      this->m_logOut_OutputPort[0].invoke(
        -: 4013:          _id,
        -: 4014:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 4015:          _logBuff
       63: 4016:      );
        -: 4017:
        -: 4018:    }
        -: 4019:
        -: 4020:    // Emit the event on the text log port
        -: 4021:#if FW_ENABLE_TEXT_LOGGING
       63: 4022:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 4023:
        -: 4024:#if FW_OBJECT_NAMES == 1
        -: 4025:      const char* _formatString =
       63: 4026:        "(%s) %s: Sequence %s command %d stepped";
        -: 4027:#else
        -: 4028:      const char* _formatString =
        -: 4029:        "%s: Sequence %s command %d stepped";
        -: 4030:#endif
        -: 4031:
        -: 4032:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 4033:
       63: 4034:      (void) snprintf(
        -: 4035:          _textBuffer,
        -: 4036:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 4037:          _formatString,
        -: 4038:#if FW_OBJECT_NAMES == 1
        -: 4039:          this->m_objName,
        -: 4040:#endif
        -: 4041:          "CS_CmdStepped "
       63: 4042:        , filename.toChar()
        -: 4043:        , command
       63: 4044:      );
        -: 4045:
        -: 4046:      // Null terminate
       63: 4047:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      126: 4048:      Fw::TextLogString _logString = _textBuffer;
       63: 4049:      this->m_LogText_OutputPort[0].invoke(
        -: 4050:          _id,
        -: 4051:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 4052:          _logString
       63: 4053:      );
        -: 4054:
        -: 4055:    }
        -: 4056:#endif
        -: 4057:
       63: 4058:  }
        -: 4059:  
        -: 4060:
       18: 4061:  void CmdSequencerComponentBase ::
        -: 4062:    log_ACTIVITY_HI_CS_CmdStarted(
        -: 4063:        Fw::LogStringArg& filename
        -: 4064:    )
        -: 4065:  {
        -: 4066:  
        -: 4067:
        -: 4068:    // Get the time
       36: 4069:    Fw::Time _logTime;
       18: 4070:    if (this->m_timeCaller_OutputPort[0].isConnected()) {
       18: 4071:       this->m_timeCaller_OutputPort[0].invoke( _logTime);
        -: 4072:    }
        -: 4073:    
       18: 4074:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 4075:    
       18: 4076:    _id = this->getIdBase() + EVENTID_CS_CMDSTARTED;
        -: 4077:
        -: 4078:    // Emit the event on the log port
       18: 4079:    if (this->m_logOut_OutputPort[0].isConnected()) {
        -: 4080:
       36: 4081:      Fw::LogBuffer _logBuff;
       18: 4082:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 4083:
        -: 4084:#if FW_AMPCS_COMPATIBLE
        -: 4085:      // Serialize the number of arguments
        -: 4086:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 4087:      FW_ASSERT(
        -: 4088:          _status == Fw::FW_SERIALIZE_OK,
        -: 4089:          static_cast<AssertArg>(_status)
        -: 4090:      );
        -: 4091:#endif
        -: 4092:
       18: 4093:      filename.setMaxSerialize(60);
       18: 4094:      _status = _logBuff.serialize(filename);
        -: 4095:      FW_ASSERT(
        -: 4096:          _status == Fw::FW_SERIALIZE_OK,
        -: 4097:          static_cast<AssertArg>(_status)
       18: 4098:      );
        -: 4099:
        -: 4100:
       18: 4101:      this->m_logOut_OutputPort[0].invoke(
        -: 4102:          _id,
        -: 4103:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 4104:          _logBuff
       18: 4105:      );
        -: 4106:
        -: 4107:    }
        -: 4108:
        -: 4109:    // Emit the event on the text log port
        -: 4110:#if FW_ENABLE_TEXT_LOGGING
       18: 4111:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 4112:
        -: 4113:#if FW_OBJECT_NAMES == 1
        -: 4114:      const char* _formatString =
       18: 4115:        "(%s) %s: Sequence %s started";
        -: 4116:#else
        -: 4117:      const char* _formatString =
        -: 4118:        "%s: Sequence %s started";
        -: 4119:#endif
        -: 4120:
        -: 4121:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 4122:
       18: 4123:      (void) snprintf(
        -: 4124:          _textBuffer,
        -: 4125:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 4126:          _formatString,
        -: 4127:#if FW_OBJECT_NAMES == 1
        -: 4128:          this->m_objName,
        -: 4129:#endif
        -: 4130:          "CS_CmdStarted "
       18: 4131:        , filename.toChar()
       18: 4132:      );
        -: 4133:
        -: 4134:      // Null terminate
       18: 4135:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       36: 4136:      Fw::TextLogString _logString = _textBuffer;
       18: 4137:      this->m_LogText_OutputPort[0].invoke(
        -: 4138:          _id,
        -: 4139:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 4140:          _logString
       18: 4141:      );
        -: 4142:
        -: 4143:    }
        -: 4144:#endif
        -: 4145:
       18: 4146:  }
        -: 4147:  
        -: 4148:
        -: 4149:  // ----------------------------------------------------------------------
        -: 4150:  // Calls for invocations received on typed input ports
        -: 4151:  // ----------------------------------------------------------------------
        -: 4152:
        9: 4153:  void CmdSequencerComponentBase ::
        -: 4154:    m_p_pingIn_in(
        -: 4155:        Fw::PassiveComponentBase* callComp,
        -: 4156:        NATIVE_INT_TYPE portNum,
        -: 4157:        U32 key
        -: 4158:    )
        -: 4159:  {
        9: 4160:    FW_ASSERT(callComp);
        -: 4161:    CmdSequencerComponentBase* compPtr =
        9: 4162:      (CmdSequencerComponentBase*) callComp;
        9: 4163:    compPtr->pingIn_handlerBase(portNum, key);
        9: 4164:  }
        -: 4165:
      342: 4166:  void CmdSequencerComponentBase ::
        -: 4167:    m_p_cmdResponseIn_in(
        -: 4168:        Fw::PassiveComponentBase* callComp,
        -: 4169:        NATIVE_INT_TYPE portNum,
        -: 4170:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 4171:    )
        -: 4172:  {
      342: 4173:    FW_ASSERT(callComp);
        -: 4174:    CmdSequencerComponentBase* compPtr =
      342: 4175:      (CmdSequencerComponentBase*) callComp;
      342: 4176:    compPtr->cmdResponseIn_handlerBase(portNum, opCode, cmdSeq, response);
      342: 4177:  }
        -: 4178:
      108: 4179:  void CmdSequencerComponentBase ::
        -: 4180:    m_p_schedIn_in(
        -: 4181:        Fw::PassiveComponentBase* callComp,
        -: 4182:        NATIVE_INT_TYPE portNum,
        -: 4183:        NATIVE_UINT_TYPE context
        -: 4184:    )
        -: 4185:  {
      108: 4186:    FW_ASSERT(callComp);
        -: 4187:    CmdSequencerComponentBase* compPtr =
      108: 4188:      (CmdSequencerComponentBase*) callComp;
      108: 4189:    compPtr->schedIn_handlerBase(portNum, context);
      108: 4190:  }
        -: 4191:
       27: 4192:  void CmdSequencerComponentBase ::
        -: 4193:    m_p_seqRunIn_in(
        -: 4194:        Fw::PassiveComponentBase* callComp,
        -: 4195:        NATIVE_INT_TYPE portNum,
        -: 4196:        Fw::EightyCharString &filename
        -: 4197:    )
        -: 4198:  {
       27: 4199:    FW_ASSERT(callComp);
        -: 4200:    CmdSequencerComponentBase* compPtr =
       27: 4201:      (CmdSequencerComponentBase*) callComp;
       27: 4202:    compPtr->seqRunIn_handlerBase(portNum, filename);
       27: 4203:  }
        -: 4204:
        -: 4205:  // ----------------------------------------------------------------------
        -: 4206:  // Port handler base-class functions for typed input ports
        -: 4207:  // ----------------------------------------------------------------------
        -: 4208:
        9: 4209:  void CmdSequencerComponentBase ::
        -: 4210:    pingIn_handlerBase(
        -: 4211:        NATIVE_INT_TYPE portNum,
        -: 4212:        U32 key
        -: 4213:    )
        -: 4214:  {
        -: 4215:
        -: 4216:    // Make sure port number is valid
        9: 4217:    FW_ASSERT(portNum < this->getNum_pingIn_InputPorts(),static_cast<AssertArg>(portNum));
        -: 4218:
        -: 4219:    // Call pre-message hook
        -: 4220:    pingIn_preMsgHook(
        -: 4221:        portNum,
        -: 4222:        key
        9: 4223:    );
        -: 4224:
       18: 4225:    ComponentIpcSerializableBuffer msg;
        9: 4226:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 4227:
        -: 4228:    _status = msg.serialize(
        -: 4229:        static_cast<NATIVE_INT_TYPE>(PINGIN_PING)
        9: 4230:    );
        -: 4231:    FW_ASSERT (
        -: 4232:        _status == Fw::FW_SERIALIZE_OK,
        -: 4233:        static_cast<AssertArg>(_status)
        9: 4234:    );
        -: 4235:
        9: 4236:    _status = msg.serialize(portNum);
        -: 4237:    FW_ASSERT (
        -: 4238:        _status == Fw::FW_SERIALIZE_OK,
        -: 4239:        static_cast<AssertArg>(_status)
        9: 4240:    );
        -: 4241:
        -: 4242:    // Serialize argument key
        9: 4243:    _status = msg.serialize(key);
        -: 4244:    FW_ASSERT(
        -: 4245:        _status == Fw::FW_SERIALIZE_OK,
        -: 4246:        static_cast<AssertArg>(_status)
        9: 4247:    );
        -: 4248:
        -: 4249:      
        -: 4250:    // send message
        -: 4251:    Os::Queue::QueueBlocking _block = 
        9: 4252:      Os::Queue::QUEUE_NONBLOCKING;
        -: 4253:    Os::Queue::QueueStatus qStatus =
        9: 4254:      this->m_queue.send(msg, 0,_block);
        -: 4255:    FW_ASSERT(
        -: 4256:        qStatus == Os::Queue::QUEUE_OK,
        -: 4257:        static_cast<AssertArg>(qStatus)
        9: 4258:    );      
        -: 4259:      
        9: 4260:  }
        -: 4261:
      342: 4262:  void CmdSequencerComponentBase ::
        -: 4263:    cmdResponseIn_handlerBase(
        -: 4264:        NATIVE_INT_TYPE portNum,
        -: 4265:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 4266:    )
        -: 4267:  {
        -: 4268:
        -: 4269:    // Make sure port number is valid
      342: 4270:    FW_ASSERT(portNum < this->getNum_cmdResponseIn_InputPorts(),static_cast<AssertArg>(portNum));
        -: 4271:
        -: 4272:    // Call pre-message hook
        -: 4273:    cmdResponseIn_preMsgHook(
        -: 4274:        portNum,
        -: 4275:        opCode, cmdSeq, response
      342: 4276:    );
        -: 4277:
      684: 4278:    ComponentIpcSerializableBuffer msg;
      342: 4279:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 4280:
        -: 4281:    _status = msg.serialize(
        -: 4282:        static_cast<NATIVE_INT_TYPE>(CMDRESPONSEIN_CMDRESPONSE)
      342: 4283:    );
        -: 4284:    FW_ASSERT (
        -: 4285:        _status == Fw::FW_SERIALIZE_OK,
        -: 4286:        static_cast<AssertArg>(_status)
      342: 4287:    );
        -: 4288:
      342: 4289:    _status = msg.serialize(portNum);
        -: 4290:    FW_ASSERT (
        -: 4291:        _status == Fw::FW_SERIALIZE_OK,
        -: 4292:        static_cast<AssertArg>(_status)
      342: 4293:    );
        -: 4294:
        -: 4295:    // Serialize argument opCode
      342: 4296:    _status = msg.serialize(opCode);
        -: 4297:    FW_ASSERT(
        -: 4298:        _status == Fw::FW_SERIALIZE_OK,
        -: 4299:        static_cast<AssertArg>(_status)
      342: 4300:    );
        -: 4301:
        -: 4302:    // Serialize argument cmdSeq
      342: 4303:    _status = msg.serialize(cmdSeq);
        -: 4304:    FW_ASSERT(
        -: 4305:        _status == Fw::FW_SERIALIZE_OK,
        -: 4306:        static_cast<AssertArg>(_status)
      342: 4307:    );
        -: 4308:
        -: 4309:    // Serialize argument response
      342: 4310:    _status = msg.serialize(static_cast<FwEnumStoreType>(response));
        -: 4311:    FW_ASSERT(
        -: 4312:        _status == Fw::FW_SERIALIZE_OK,
        -: 4313:        static_cast<AssertArg>(_status)
      342: 4314:    );
        -: 4315:
        -: 4316:      
        -: 4317:    // send message
        -: 4318:    Os::Queue::QueueBlocking _block = 
      342: 4319:      Os::Queue::QUEUE_NONBLOCKING;
        -: 4320:    Os::Queue::QueueStatus qStatus =
      342: 4321:      this->m_queue.send(msg, 0,_block);
        -: 4322:    FW_ASSERT(
        -: 4323:        qStatus == Os::Queue::QUEUE_OK,
        -: 4324:        static_cast<AssertArg>(qStatus)
      342: 4325:    );      
        -: 4326:      
      342: 4327:  }
        -: 4328:
      108: 4329:  void CmdSequencerComponentBase ::
        -: 4330:    schedIn_handlerBase(
        -: 4331:        NATIVE_INT_TYPE portNum,
        -: 4332:        NATIVE_UINT_TYPE context
        -: 4333:    )
        -: 4334:  {
        -: 4335:
        -: 4336:    // Make sure port number is valid
      108: 4337:    FW_ASSERT(portNum < this->getNum_schedIn_InputPorts(),static_cast<AssertArg>(portNum));
        -: 4338:
        -: 4339:    // Call pre-message hook
        -: 4340:    schedIn_preMsgHook(
        -: 4341:        portNum,
        -: 4342:        context
      108: 4343:    );
        -: 4344:
      216: 4345:    ComponentIpcSerializableBuffer msg;
      108: 4346:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 4347:
        -: 4348:    _status = msg.serialize(
        -: 4349:        static_cast<NATIVE_INT_TYPE>(SCHEDIN_SCHED)
      108: 4350:    );
        -: 4351:    FW_ASSERT (
        -: 4352:        _status == Fw::FW_SERIALIZE_OK,
        -: 4353:        static_cast<AssertArg>(_status)
      108: 4354:    );
        -: 4355:
      108: 4356:    _status = msg.serialize(portNum);
        -: 4357:    FW_ASSERT (
        -: 4358:        _status == Fw::FW_SERIALIZE_OK,
        -: 4359:        static_cast<AssertArg>(_status)
      108: 4360:    );
        -: 4361:
        -: 4362:    // Serialize argument context
      108: 4363:    _status = msg.serialize(context);
        -: 4364:    FW_ASSERT(
        -: 4365:        _status == Fw::FW_SERIALIZE_OK,
        -: 4366:        static_cast<AssertArg>(_status)
      108: 4367:    );
        -: 4368:
        -: 4369:      
        -: 4370:    // send message
        -: 4371:    Os::Queue::QueueBlocking _block = 
      108: 4372:      Os::Queue::QUEUE_NONBLOCKING;
        -: 4373:    Os::Queue::QueueStatus qStatus =
      108: 4374:      this->m_queue.send(msg, 0,_block);
        -: 4375:    FW_ASSERT(
        -: 4376:        qStatus == Os::Queue::QUEUE_OK,
        -: 4377:        static_cast<AssertArg>(qStatus)
      108: 4378:    );      
        -: 4379:      
      108: 4380:  }
        -: 4381:
       27: 4382:  void CmdSequencerComponentBase ::
        -: 4383:    seqRunIn_handlerBase(
        -: 4384:        NATIVE_INT_TYPE portNum,
        -: 4385:        Fw::EightyCharString &filename
        -: 4386:    )
        -: 4387:  {
        -: 4388:
        -: 4389:    // Make sure port number is valid
       27: 4390:    FW_ASSERT(portNum < this->getNum_seqRunIn_InputPorts(),static_cast<AssertArg>(portNum));
        -: 4391:
        -: 4392:    // Call pre-message hook
        -: 4393:    seqRunIn_preMsgHook(
        -: 4394:        portNum,
        -: 4395:        filename
       27: 4396:    );
        -: 4397:
       54: 4398:    ComponentIpcSerializableBuffer msg;
       27: 4399:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 4400:
        -: 4401:    _status = msg.serialize(
        -: 4402:        static_cast<NATIVE_INT_TYPE>(SEQRUNIN_CMDSEQIN)
       27: 4403:    );
        -: 4404:    FW_ASSERT (
        -: 4405:        _status == Fw::FW_SERIALIZE_OK,
        -: 4406:        static_cast<AssertArg>(_status)
       27: 4407:    );
        -: 4408:
       27: 4409:    _status = msg.serialize(portNum);
        -: 4410:    FW_ASSERT (
        -: 4411:        _status == Fw::FW_SERIALIZE_OK,
        -: 4412:        static_cast<AssertArg>(_status)
       27: 4413:    );
        -: 4414:
        -: 4415:    // Serialize argument filename
       27: 4416:    _status = msg.serialize(filename);
        -: 4417:    FW_ASSERT(
        -: 4418:        _status == Fw::FW_SERIALIZE_OK,
        -: 4419:        static_cast<AssertArg>(_status)
       27: 4420:    );
        -: 4421:
        -: 4422:      
        -: 4423:    // send message
        -: 4424:    Os::Queue::QueueBlocking _block = 
       27: 4425:      Os::Queue::QUEUE_NONBLOCKING;
        -: 4426:    Os::Queue::QueueStatus qStatus =
       27: 4427:      this->m_queue.send(msg, 0,_block);
        -: 4428:    FW_ASSERT(
        -: 4429:        qStatus == Os::Queue::QUEUE_OK,
        -: 4430:        static_cast<AssertArg>(qStatus)
       27: 4431:    );      
        -: 4432:      
       27: 4433:  }
        -: 4434:
        -: 4435:  // ----------------------------------------------------------------------
        -: 4436:  // Pre-message hooks for async input ports
        -: 4437:  // ----------------------------------------------------------------------
        -: 4438:
        9: 4439:  void CmdSequencerComponentBase ::
        -: 4440:    pingIn_preMsgHook(
        -: 4441:        NATIVE_INT_TYPE portNum,
        -: 4442:        U32 key
        -: 4443:    )
        -: 4444:  {
        -: 4445:    // Default: no-op
        9: 4446:  }
        -: 4447:
      342: 4448:  void CmdSequencerComponentBase ::
        -: 4449:    cmdResponseIn_preMsgHook(
        -: 4450:        NATIVE_INT_TYPE portNum,
        -: 4451:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 4452:    )
        -: 4453:  {
        -: 4454:    // Default: no-op
      342: 4455:  }
        -: 4456:
      108: 4457:  void CmdSequencerComponentBase ::
        -: 4458:    schedIn_preMsgHook(
        -: 4459:        NATIVE_INT_TYPE portNum,
        -: 4460:        NATIVE_UINT_TYPE context
        -: 4461:    )
        -: 4462:  {
        -: 4463:    // Default: no-op
      108: 4464:  }
        -: 4465:
       27: 4466:  void CmdSequencerComponentBase ::
        -: 4467:    seqRunIn_preMsgHook(
        -: 4468:        NATIVE_INT_TYPE portNum,
        -: 4469:        Fw::EightyCharString &filename
        -: 4470:    )
        -: 4471:  {
        -: 4472:    // Default: no-op
       27: 4473:  }
        -: 4474:
        -: 4475:  // ----------------------------------------------------------------------
        -: 4476:  // Message dispatch method for active and queued components. Called
        -: 4477:  // by active component thread or implementation code for queued components
        -: 4478:  // ----------------------------------------------------------------------
        -: 4479:
     1087: 4480:  Fw::QueuedComponentBase::MsgDispatchStatus CmdSequencerComponentBase ::
        -: 4481:    doDispatch(void)
        -: 4482:  {
     2174: 4483:    ComponentIpcSerializableBuffer msg;
        -: 4484:    NATIVE_INT_TYPE priority;
        -: 4485:
     1087: 4486:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_BLOCKING);
        -: 4487:    FW_ASSERT(
        -: 4488:        msgStatus == Os::Queue::QUEUE_OK,
        -: 4489:        static_cast<AssertArg>(msgStatus)
     1087: 4490:    );
        -: 4491:
        -: 4492:    // Reset to beginning of buffer
     1087: 4493:    msg.resetDeser();
        -: 4494:
        -: 4495:    NATIVE_INT_TYPE desMsg;
     1087: 4496:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
        -: 4497:    FW_ASSERT(
        -: 4498:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4499:        static_cast<AssertArg>(deserStatus)
     1087: 4500:    );
        -: 4501:
     1087: 4502:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -: 4503:
     1087: 4504:    if (msgType == CMDSEQUENCER_COMPONENT_EXIT) {
    #####: 4505:      return MSG_DISPATCH_EXIT;
        -: 4506:    }
        -: 4507:
        -: 4508:    NATIVE_INT_TYPE portNum;
     1087: 4509:    deserStatus = msg.deserialize(portNum);
        -: 4510:    FW_ASSERT(
        -: 4511:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4512:        static_cast<AssertArg>(deserStatus)
     1087: 4513:    );
        -: 4514:
     1087: 4515:    switch (msgType) {
        -: 4516:
        -: 4517:      // Handle async input port pingIn
        -: 4518:      case PINGIN_PING: {
        -: 4519:
        -: 4520:        // Deserialize argument key
        -: 4521:        U32 key;
        9: 4522:        deserStatus = msg.deserialize(key);
        -: 4523:        FW_ASSERT(
        -: 4524:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4525:            static_cast<AssertArg>(deserStatus)
        9: 4526:        );
        -: 4527:
        -: 4528:        // Call handler function
        -: 4529:        this->pingIn_handler(
        -: 4530:            portNum,
        -: 4531:            key
        9: 4532:        );
        -: 4533:
        9: 4534:        break;
        -: 4535:
        -: 4536:      }
        -: 4537:
        -: 4538:      // Handle async input port cmdResponseIn
        -: 4539:      case CMDRESPONSEIN_CMDRESPONSE: {
        -: 4540:
        -: 4541:        // Deserialize argument opCode
        -: 4542:        FwOpcodeType opCode;
      342: 4543:        deserStatus = msg.deserialize(opCode);
        -: 4544:        FW_ASSERT(
        -: 4545:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4546:            static_cast<AssertArg>(deserStatus)
      342: 4547:        );
        -: 4548:
        -: 4549:        // Deserialize argument cmdSeq
        -: 4550:        U32 cmdSeq;
      342: 4551:        deserStatus = msg.deserialize(cmdSeq);
        -: 4552:        FW_ASSERT(
        -: 4553:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4554:            static_cast<AssertArg>(deserStatus)
      342: 4555:        );
        -: 4556:
        -: 4557:        // Deserialize argument response
        -: 4558:        Fw::CommandResponse response;
        -: 4559:        FwEnumStoreType responseInt;
      342: 4560:        deserStatus = msg.deserialize(responseInt);
      342: 4561:        response = (Fw::CommandResponse) responseInt;
        -: 4562:        FW_ASSERT(
        -: 4563:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4564:            static_cast<AssertArg>(deserStatus)
      342: 4565:        );
        -: 4566:
        -: 4567:        // Call handler function
        -: 4568:        this->cmdResponseIn_handler(
        -: 4569:            portNum,
        -: 4570:            opCode, cmdSeq, response
      342: 4571:        );
        -: 4572:
      342: 4573:        break;
        -: 4574:
        -: 4575:      }
        -: 4576:
        -: 4577:      // Handle async input port schedIn
        -: 4578:      case SCHEDIN_SCHED: {
        -: 4579:
        -: 4580:        // Deserialize argument context
        -: 4581:        NATIVE_UINT_TYPE context;
      108: 4582:        deserStatus = msg.deserialize(context);
        -: 4583:        FW_ASSERT(
        -: 4584:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4585:            static_cast<AssertArg>(deserStatus)
      108: 4586:        );
        -: 4587:
        -: 4588:        // Call handler function
        -: 4589:        this->schedIn_handler(
        -: 4590:            portNum,
        -: 4591:            context
      108: 4592:        );
        -: 4593:
      108: 4594:        break;
        -: 4595:
        -: 4596:      }
        -: 4597:
        -: 4598:      // Handle async input port seqRunIn
        -: 4599:      case SEQRUNIN_CMDSEQIN: {
        -: 4600:
        -: 4601:        // Deserialize argument filename
       54: 4602:        Fw::EightyCharString filename;
       27: 4603:        deserStatus = msg.deserialize(filename);
        -: 4604:        FW_ASSERT(
        -: 4605:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4606:            static_cast<AssertArg>(deserStatus)
       27: 4607:        );
        -: 4608:
        -: 4609:        // Call handler function
        -: 4610:        this->seqRunIn_handler(
        -: 4611:            portNum,
        -: 4612:            filename
       27: 4613:        );
        -: 4614:
       27: 4615:        break;
        -: 4616:
        -: 4617:      }
        -: 4618:
        -: 4619:      // Handle command CS_Run
        -: 4620:      case CMD_CS_RUN: {
        -: 4621:        // Deserialize opcode
        -: 4622:        FwOpcodeType opCode;
      190: 4623:        deserStatus = msg.deserialize(opCode);
        -: 4624:        FW_ASSERT (
        -: 4625:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4626:            static_cast<AssertArg>(deserStatus)
      190: 4627:        );
        -: 4628:
        -: 4629:        // Deserialize command sequence
        -: 4630:        U32 cmdSeq;
      190: 4631:        deserStatus = msg.deserialize(cmdSeq);
        -: 4632:        FW_ASSERT (
        -: 4633:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4634:            static_cast<AssertArg>(deserStatus)
      190: 4635:        );
        -: 4636:
        -: 4637:        // Deserialize command argument buffer
      380: 4638:        Fw::CmdArgBuffer args;
      190: 4639:        deserStatus = msg.deserialize(args);
        -: 4640:        FW_ASSERT (
        -: 4641:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4642:            static_cast<AssertArg>(deserStatus)
      190: 4643:        );
        -: 4644:
        -: 4645:        // Reset buffer
      190: 4646:        args.resetDeser();
        -: 4647:
        -: 4648:        // Deserialize argument fileName
      380: 4649:        Fw::CmdStringArg fileName;
      190: 4650:        deserStatus = args.deserialize(fileName);
      190: 4651:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 4652:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
        -: 4653:            this->cmdResponse_out(
        -: 4654:                opCode,
        -: 4655:                cmdSeq,
        -: 4656:                Fw::COMMAND_FORMAT_ERROR
    #####: 4657:            );
        -: 4658:          }
        -: 4659:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4660:          break;
        -: 4661:        }
        -: 4662:
        -: 4663:        // Make sure there was no data left over.
        -: 4664:        // That means the argument buffer size was incorrect.
        -: 4665:#if FW_CMD_CHECK_RESIDUAL        
      190: 4666:        if (args.getBuffLeft() != 0) {
    #####: 4667:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4668:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4669:          }
        -: 4670:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4671:          break;
        -: 4672:        }
        -: 4673:#endif
        -: 4674:        // Call handler function
        -: 4675:        this->CS_Run_cmdHandler(
        -: 4676:            opCode,
        -: 4677:            cmdSeq,
        -: 4678:            fileName
      190: 4679:        );
        -: 4680:
      190: 4681:        break;
        -: 4682:
        -: 4683:      }
        -: 4684:
        -: 4685:      // Handle command CS_Validate
        -: 4686:      case CMD_CS_VALIDATE: {
        -: 4687:        // Deserialize opcode
        -: 4688:        FwOpcodeType opCode;
      231: 4689:        deserStatus = msg.deserialize(opCode);
        -: 4690:        FW_ASSERT (
        -: 4691:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4692:            static_cast<AssertArg>(deserStatus)
      231: 4693:        );
        -: 4694:
        -: 4695:        // Deserialize command sequence
        -: 4696:        U32 cmdSeq;
      231: 4697:        deserStatus = msg.deserialize(cmdSeq);
        -: 4698:        FW_ASSERT (
        -: 4699:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4700:            static_cast<AssertArg>(deserStatus)
      231: 4701:        );
        -: 4702:
        -: 4703:        // Deserialize command argument buffer
      462: 4704:        Fw::CmdArgBuffer args;
      231: 4705:        deserStatus = msg.deserialize(args);
        -: 4706:        FW_ASSERT (
        -: 4707:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4708:            static_cast<AssertArg>(deserStatus)
      231: 4709:        );
        -: 4710:
        -: 4711:        // Reset buffer
      231: 4712:        args.resetDeser();
        -: 4713:
        -: 4714:        // Deserialize argument fileName
      462: 4715:        Fw::CmdStringArg fileName;
      231: 4716:        deserStatus = args.deserialize(fileName);
      231: 4717:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 4718:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
        -: 4719:            this->cmdResponse_out(
        -: 4720:                opCode,
        -: 4721:                cmdSeq,
        -: 4722:                Fw::COMMAND_FORMAT_ERROR
    #####: 4723:            );
        -: 4724:          }
        -: 4725:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4726:          break;
        -: 4727:        }
        -: 4728:
        -: 4729:        // Make sure there was no data left over.
        -: 4730:        // That means the argument buffer size was incorrect.
        -: 4731:#if FW_CMD_CHECK_RESIDUAL        
      231: 4732:        if (args.getBuffLeft() != 0) {
    #####: 4733:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4734:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4735:          }
        -: 4736:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4737:          break;
        -: 4738:        }
        -: 4739:#endif
        -: 4740:        // Call handler function
        -: 4741:        this->CS_Validate_cmdHandler(
        -: 4742:            opCode,
        -: 4743:            cmdSeq,
        -: 4744:            fileName
      231: 4745:        );
        -: 4746:
      231: 4747:        break;
        -: 4748:
        -: 4749:      }
        -: 4750:
        -: 4751:      // Handle command CS_Cancel
        -: 4752:      case CMD_CS_CANCEL: {
        -: 4753:        // Deserialize opcode
        -: 4754:        FwOpcodeType opCode;
       18: 4755:        deserStatus = msg.deserialize(opCode);
        -: 4756:        FW_ASSERT (
        -: 4757:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4758:            static_cast<AssertArg>(deserStatus)
       18: 4759:        );
        -: 4760:
        -: 4761:        // Deserialize command sequence
        -: 4762:        U32 cmdSeq;
       18: 4763:        deserStatus = msg.deserialize(cmdSeq);
        -: 4764:        FW_ASSERT (
        -: 4765:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4766:            static_cast<AssertArg>(deserStatus)
       18: 4767:        );
        -: 4768:
        -: 4769:        // Deserialize command argument buffer
       36: 4770:        Fw::CmdArgBuffer args;
       18: 4771:        deserStatus = msg.deserialize(args);
        -: 4772:        FW_ASSERT (
        -: 4773:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4774:            static_cast<AssertArg>(deserStatus)
       18: 4775:        );
        -: 4776:
        -: 4777:        // Reset buffer
       18: 4778:        args.resetDeser();
        -: 4779:
        -: 4780:        // Make sure there was no data left over.
        -: 4781:        // That means the argument buffer size was incorrect.
        -: 4782:#if FW_CMD_CHECK_RESIDUAL        
       18: 4783:        if (args.getBuffLeft() != 0) {
    #####: 4784:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4785:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4786:          }
        -: 4787:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4788:          break;
        -: 4789:        }
        -: 4790:#endif
        -: 4791:        // Call handler function
       18: 4792:        this->CS_Cancel_cmdHandler(opCode, cmdSeq);
        -: 4793:
       18: 4794:        break;
        -: 4795:
        -: 4796:      }
        -: 4797:
        -: 4798:      // Handle command CS_Start
        -: 4799:      case CMD_CS_START: {
        -: 4800:        // Deserialize opcode
        -: 4801:        FwOpcodeType opCode;
       36: 4802:        deserStatus = msg.deserialize(opCode);
        -: 4803:        FW_ASSERT (
        -: 4804:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4805:            static_cast<AssertArg>(deserStatus)
       36: 4806:        );
        -: 4807:
        -: 4808:        // Deserialize command sequence
        -: 4809:        U32 cmdSeq;
       36: 4810:        deserStatus = msg.deserialize(cmdSeq);
        -: 4811:        FW_ASSERT (
        -: 4812:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4813:            static_cast<AssertArg>(deserStatus)
       36: 4814:        );
        -: 4815:
        -: 4816:        // Deserialize command argument buffer
       72: 4817:        Fw::CmdArgBuffer args;
       36: 4818:        deserStatus = msg.deserialize(args);
        -: 4819:        FW_ASSERT (
        -: 4820:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4821:            static_cast<AssertArg>(deserStatus)
       36: 4822:        );
        -: 4823:
        -: 4824:        // Reset buffer
       36: 4825:        args.resetDeser();
        -: 4826:
        -: 4827:        // Make sure there was no data left over.
        -: 4828:        // That means the argument buffer size was incorrect.
        -: 4829:#if FW_CMD_CHECK_RESIDUAL        
       36: 4830:        if (args.getBuffLeft() != 0) {
    #####: 4831:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4832:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4833:          }
        -: 4834:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4835:          break;
        -: 4836:        }
        -: 4837:#endif
        -: 4838:        // Call handler function
       36: 4839:        this->CS_Start_cmdHandler(opCode, cmdSeq);
        -: 4840:
       36: 4841:        break;
        -: 4842:
        -: 4843:      }
        -: 4844:
        -: 4845:      // Handle command CS_Step
        -: 4846:      case CMD_CS_STEP: {
        -: 4847:        // Deserialize opcode
        -: 4848:        FwOpcodeType opCode;
       81: 4849:        deserStatus = msg.deserialize(opCode);
        -: 4850:        FW_ASSERT (
        -: 4851:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4852:            static_cast<AssertArg>(deserStatus)
       81: 4853:        );
        -: 4854:
        -: 4855:        // Deserialize command sequence
        -: 4856:        U32 cmdSeq;
       81: 4857:        deserStatus = msg.deserialize(cmdSeq);
        -: 4858:        FW_ASSERT (
        -: 4859:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4860:            static_cast<AssertArg>(deserStatus)
       81: 4861:        );
        -: 4862:
        -: 4863:        // Deserialize command argument buffer
      162: 4864:        Fw::CmdArgBuffer args;
       81: 4865:        deserStatus = msg.deserialize(args);
        -: 4866:        FW_ASSERT (
        -: 4867:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4868:            static_cast<AssertArg>(deserStatus)
       81: 4869:        );
        -: 4870:
        -: 4871:        // Reset buffer
       81: 4872:        args.resetDeser();
        -: 4873:
        -: 4874:        // Make sure there was no data left over.
        -: 4875:        // That means the argument buffer size was incorrect.
        -: 4876:#if FW_CMD_CHECK_RESIDUAL        
       81: 4877:        if (args.getBuffLeft() != 0) {
    #####: 4878:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4879:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4880:          }
        -: 4881:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4882:          break;
        -: 4883:        }
        -: 4884:#endif
        -: 4885:        // Call handler function
       81: 4886:        this->CS_Step_cmdHandler(opCode, cmdSeq);
        -: 4887:
       81: 4888:        break;
        -: 4889:
        -: 4890:      }
        -: 4891:
        -: 4892:      // Handle command CS_Auto
        -: 4893:      case CMD_CS_AUTO: {
        -: 4894:        // Deserialize opcode
        -: 4895:        FwOpcodeType opCode;
       18: 4896:        deserStatus = msg.deserialize(opCode);
        -: 4897:        FW_ASSERT (
        -: 4898:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4899:            static_cast<AssertArg>(deserStatus)
       18: 4900:        );
        -: 4901:
        -: 4902:        // Deserialize command sequence
        -: 4903:        U32 cmdSeq;
       18: 4904:        deserStatus = msg.deserialize(cmdSeq);
        -: 4905:        FW_ASSERT (
        -: 4906:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4907:            static_cast<AssertArg>(deserStatus)
       18: 4908:        );
        -: 4909:
        -: 4910:        // Deserialize command argument buffer
       36: 4911:        Fw::CmdArgBuffer args;
       18: 4912:        deserStatus = msg.deserialize(args);
        -: 4913:        FW_ASSERT (
        -: 4914:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4915:            static_cast<AssertArg>(deserStatus)
       18: 4916:        );
        -: 4917:
        -: 4918:        // Reset buffer
       18: 4919:        args.resetDeser();
        -: 4920:
        -: 4921:        // Make sure there was no data left over.
        -: 4922:        // That means the argument buffer size was incorrect.
        -: 4923:#if FW_CMD_CHECK_RESIDUAL        
       18: 4924:        if (args.getBuffLeft() != 0) {
    #####: 4925:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4926:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4927:          }
        -: 4928:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4929:          break;
        -: 4930:        }
        -: 4931:#endif
        -: 4932:        // Call handler function
       18: 4933:        this->CS_Auto_cmdHandler(opCode, cmdSeq);
        -: 4934:
       18: 4935:        break;
        -: 4936:
        -: 4937:      }
        -: 4938:
        -: 4939:      // Handle command CS_Manual
        -: 4940:      case CMD_CS_MANUAL: {
        -: 4941:        // Deserialize opcode
        -: 4942:        FwOpcodeType opCode;
       27: 4943:        deserStatus = msg.deserialize(opCode);
        -: 4944:        FW_ASSERT (
        -: 4945:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4946:            static_cast<AssertArg>(deserStatus)
       27: 4947:        );
        -: 4948:
        -: 4949:        // Deserialize command sequence
        -: 4950:        U32 cmdSeq;
       27: 4951:        deserStatus = msg.deserialize(cmdSeq);
        -: 4952:        FW_ASSERT (
        -: 4953:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4954:            static_cast<AssertArg>(deserStatus)
       27: 4955:        );
        -: 4956:
        -: 4957:        // Deserialize command argument buffer
       54: 4958:        Fw::CmdArgBuffer args;
       27: 4959:        deserStatus = msg.deserialize(args);
        -: 4960:        FW_ASSERT (
        -: 4961:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 4962:            static_cast<AssertArg>(deserStatus)
       27: 4963:        );
        -: 4964:
        -: 4965:        // Reset buffer
       27: 4966:        args.resetDeser();
        -: 4967:
        -: 4968:        // Make sure there was no data left over.
        -: 4969:        // That means the argument buffer size was incorrect.
        -: 4970:#if FW_CMD_CHECK_RESIDUAL        
       27: 4971:        if (args.getBuffLeft() != 0) {
    #####: 4972:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 4973:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 4974:          }
        -: 4975:          // Don't crash the task if bad arguments were passed from the ground
    #####: 4976:          break;
        -: 4977:        }
        -: 4978:#endif
        -: 4979:        // Call handler function
       27: 4980:        this->CS_Manual_cmdHandler(opCode, cmdSeq);
        -: 4981:
       27: 4982:        break;
        -: 4983:
        -: 4984:      }
        -: 4985:
        -: 4986:      default:
    #####: 4987:        return MSG_DISPATCH_ERROR;
        -: 4988:
        -: 4989:    }
        -: 4990:
     1087: 4991:    return MSG_DISPATCH_OK;
        -: 4992:
        -: 4993:  }
        -: 4994:
       27: 4995:} // end namespace Svc
