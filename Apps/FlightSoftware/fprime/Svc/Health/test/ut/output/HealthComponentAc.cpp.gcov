        -:    0:Source:/home/tim/source/isf/Svc/Health/HealthComponentAc.cpp
        -:    0:Programs:2
        -:    1:// ====================================================================== 
        -:    2:// \title  HealthComponentAc.hpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for Health component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   11:// 
        -:   18:// ====================================================================== 
        -:   19:
        -:   20:#include <stdio.h>
        -:   21:#include <Fw/Cfg/Config.hpp>
        -:   22:#include <Svc/Health/HealthComponentAc.hpp>
        -:   23:#include <Fw/Types/Assert.hpp>
        -:   24:#if FW_ENABLE_TEXT_LOGGING
        -:   25:#include <Fw/Types/EightyCharString.hpp>
        -:   26:#endif
        -:   27:
        -:   28:
        -:   29:namespace Svc {
        -:   30:
        -:   31:  // ----------------------------------------------------------------------
        -:   32:  // Anonymous namespace to prevent name collisions
        -:   33:  // ----------------------------------------------------------------------
        -:   34:
        -:   35:  namespace {
        -:   36:
        -:   37:    typedef enum {
        -:   38:      HEALTH_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   39:      PINGRETURN_PING,
        -:   40:      CMD_HLTH_ENABLE,
        -:   41:      CMD_HLTH_PING_ENABLE,
        -:   42:      CMD_HLTH_CHNG_PING
        -:   43:    } MsgTypeEnum;
        -:   44:
        -:   45:    // Get the max size by doing a union of the input port serialization sizes.
        -:   46:
        -:   47:    typedef union {
        -:   48:      BYTE port1[Svc::InputPingPort::SERIALIZED_SIZE];
        -:   49:      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
        -:   50:    } BuffUnion;
        -:   51:
        -:   52:    // Define a message buffer class large enough to handle all the
        -:   53:    // asynchronous inputs to the component
        -:   54:
     2014:   55:    class ComponentIpcSerializableBuffer : 
        -:   56:      public Fw::SerializeBufferBase
        -:   57:    {
        -:   58:
        -:   59:      public:
        -:   60:
        -:   61:        enum {
        -:   62:          // Max. message size = size of data + message id + port
        -:   63:          SERIALIZATION_SIZE =
        -:   64:            sizeof(BuffUnion) +
        -:   65:            sizeof(NATIVE_INT_TYPE) +
        -:   66:            sizeof(NATIVE_INT_TYPE)
        -:   67:        };
        -:   68:
     2134:   69:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
     2134:   70:          return sizeof(m_buff);
        -:   71:        }
        -:   72:
    11431:   73:        U8* getBuffAddr(void) {
    11431:   74:          return m_buff;
        -:   75:        }
        -:   76:
      341:   77:        const U8* getBuffAddr(void) const {
      341:   78:          return m_buff;
        -:   79:        }
        -:   80:
        -:   81:      private:
        -:   82:        // Should be the max of all the input ports serialized sizes...
        -:   83:        U8 m_buff[SERIALIZATION_SIZE];
        -:   84:
        -:   85:    };
        -:   86:
        -:   87:  }
        -:   88:
        -:   89:  // ----------------------------------------------------------------------
        -:   90:  // Getters for numbers of input ports
        -:   91:  // ----------------------------------------------------------------------
        -:   92:
      100:   93:  Svc::InputPingPort *HealthComponentBase ::
        -:   94:    get_PingReturn_InputPort(NATIVE_INT_TYPE portNum)
        -:   95:  {
      100:   96:    FW_ASSERT(portNum < this->getNum_PingReturn_InputPorts(),static_cast<AssertArg>(portNum));
      100:   97:    return &this->m_PingReturn_InputPort[portNum];
        -:   98:  }
        -:   99:
       10:  100:  Svc::InputSchedPort *HealthComponentBase ::
        -:  101:    get_Run_InputPort(NATIVE_INT_TYPE portNum)
        -:  102:  {
       10:  103:    FW_ASSERT(portNum < this->getNum_Run_InputPorts(),static_cast<AssertArg>(portNum));
       10:  104:    return &this->m_Run_InputPort[portNum];
        -:  105:  }
        -:  106:
       10:  107:  Fw::InputCmdPort *HealthComponentBase ::
        -:  108:    get_CmdDisp_InputPort(NATIVE_INT_TYPE portNum)
        -:  109:  {
       10:  110:    FW_ASSERT(portNum < this->getNum_CmdDisp_InputPorts(),static_cast<AssertArg>(portNum));
       10:  111:    return &this->m_CmdDisp_InputPort[portNum];
        -:  112:  }
        -:  113:
        -:  114:  // ----------------------------------------------------------------------
        -:  115:  // Typed connectors for output ports
        -:  116:  // ----------------------------------------------------------------------
        -:  117:
      100:  118:  void HealthComponentBase ::
        -:  119:    set_PingSend_OutputPort(
        -:  120:        NATIVE_INT_TYPE portNum,
        -:  121:        Svc::InputPingPort* port
        -:  122:    )
        -:  123:  {
      100:  124:    FW_ASSERT(portNum < this->getNum_PingSend_OutputPorts(),static_cast<AssertArg>(portNum));
      100:  125:    this->m_PingSend_OutputPort[portNum].addCallPort(port);
      100:  126:  }
        -:  127:
       10:  128:  void HealthComponentBase ::
        -:  129:    set_WdogStroke_OutputPort(
        -:  130:        NATIVE_INT_TYPE portNum,
        -:  131:        Svc::InputWatchDogPort* port
        -:  132:    )
        -:  133:  {
       10:  134:    FW_ASSERT(portNum < this->getNum_WdogStroke_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  135:    this->m_WdogStroke_OutputPort[portNum].addCallPort(port);
       10:  136:  }
        -:  137:
       10:  138:  void HealthComponentBase ::
        -:  139:    set_CmdStatus_OutputPort(
        -:  140:        NATIVE_INT_TYPE portNum,
        -:  141:        Fw::InputCmdResponsePort* port
        -:  142:    )
        -:  143:  {
       10:  144:    FW_ASSERT(portNum < this->getNum_CmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  145:    this->m_CmdStatus_OutputPort[portNum].addCallPort(port);
       10:  146:  }
        -:  147:
       10:  148:  void HealthComponentBase ::
        -:  149:    set_CmdReg_OutputPort(
        -:  150:        NATIVE_INT_TYPE portNum,
        -:  151:        Fw::InputCmdRegPort* port
        -:  152:    )
        -:  153:  {
       10:  154:    FW_ASSERT(portNum < this->getNum_CmdReg_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  155:    this->m_CmdReg_OutputPort[portNum].addCallPort(port);
       10:  156:  }
        -:  157:
       10:  158:  void HealthComponentBase ::
        -:  159:    set_Tlm_OutputPort(
        -:  160:        NATIVE_INT_TYPE portNum,
        -:  161:        Fw::InputTlmPort* port
        -:  162:    )
        -:  163:  {
       10:  164:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  165:    this->m_Tlm_OutputPort[portNum].addCallPort(port);
       10:  166:  }
        -:  167:
       10:  168:  void HealthComponentBase ::
        -:  169:    set_Time_OutputPort(
        -:  170:        NATIVE_INT_TYPE portNum,
        -:  171:        Fw::InputTimePort* port
        -:  172:    )
        -:  173:  {
       10:  174:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  175:    this->m_Time_OutputPort[portNum].addCallPort(port);
       10:  176:  }
        -:  177:
       10:  178:  void HealthComponentBase ::
        -:  179:    set_Log_OutputPort(
        -:  180:        NATIVE_INT_TYPE portNum,
        -:  181:        Fw::InputLogPort* port
        -:  182:    )
        -:  183:  {
       10:  184:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  185:    this->m_Log_OutputPort[portNum].addCallPort(port);
       10:  186:  }
        -:  187:
        -:  188:#if FW_ENABLE_TEXT_LOGGING == 1
       10:  189:  void HealthComponentBase ::
        -:  190:    set_LogText_OutputPort(
        -:  191:        NATIVE_INT_TYPE portNum,
        -:  192:        Fw::InputLogTextPort* port
        -:  193:    )
        -:  194:  {
       10:  195:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
       10:  196:    this->m_LogText_OutputPort[portNum].addCallPort(port);
       10:  197:  }
        -:  198:#endif
        -:  199:
        -:  200:  // ----------------------------------------------------------------------
        -:  201:  // Serialization connectors for output ports
        -:  202:  // ----------------------------------------------------------------------
        -:  203:
        -:  204:#if FW_PORT_SERIALIZATION
        -:  205:
    #####:  206:  void HealthComponentBase ::
        -:  207:    set_PingSend_OutputPort(
        -:  208:        NATIVE_INT_TYPE portNum,
        -:  209:        Fw::InputSerializePort *port
        -:  210:    )
        -:  211:  {
    #####:  212:    FW_ASSERT(portNum < this->getNum_PingSend_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  213:    return this->m_PingSend_OutputPort[portNum].registerSerialPort(port);
        -:  214:  }
        -:  215:
    #####:  216:  void HealthComponentBase ::
        -:  217:    set_WdogStroke_OutputPort(
        -:  218:        NATIVE_INT_TYPE portNum,
        -:  219:        Fw::InputSerializePort *port
        -:  220:    )
        -:  221:  {
    #####:  222:    FW_ASSERT(portNum < this->getNum_WdogStroke_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  223:    return this->m_WdogStroke_OutputPort[portNum].registerSerialPort(port);
        -:  224:  }
        -:  225:
    #####:  226:  void HealthComponentBase ::
        -:  227:    set_CmdStatus_OutputPort(
        -:  228:        NATIVE_INT_TYPE portNum,
        -:  229:        Fw::InputSerializePort *port
        -:  230:    )
        -:  231:  {
    #####:  232:    FW_ASSERT(portNum < this->getNum_CmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  233:    return this->m_CmdStatus_OutputPort[portNum].registerSerialPort(port);
        -:  234:  }
        -:  235:
    #####:  236:  void HealthComponentBase ::
        -:  237:    set_CmdReg_OutputPort(
        -:  238:        NATIVE_INT_TYPE portNum,
        -:  239:        Fw::InputSerializePort *port
        -:  240:    )
        -:  241:  {
    #####:  242:    FW_ASSERT(portNum < this->getNum_CmdReg_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  243:    return this->m_CmdReg_OutputPort[portNum].registerSerialPort(port);
        -:  244:  }
        -:  245:
    #####:  246:  void HealthComponentBase ::
        -:  247:    set_Tlm_OutputPort(
        -:  248:        NATIVE_INT_TYPE portNum,
        -:  249:        Fw::InputSerializePort *port
        -:  250:    )
        -:  251:  {
    #####:  252:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  253:    return this->m_Tlm_OutputPort[portNum].registerSerialPort(port);
        -:  254:  }
        -:  255:
    #####:  256:  void HealthComponentBase ::
        -:  257:    set_Time_OutputPort(
        -:  258:        NATIVE_INT_TYPE portNum,
        -:  259:        Fw::InputSerializePort *port
        -:  260:    )
        -:  261:  {
    #####:  262:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  263:    return this->m_Time_OutputPort[portNum].registerSerialPort(port);
        -:  264:  }
        -:  265:
    #####:  266:  void HealthComponentBase ::
        -:  267:    set_Log_OutputPort(
        -:  268:        NATIVE_INT_TYPE portNum,
        -:  269:        Fw::InputSerializePort *port
        -:  270:    )
        -:  271:  {
    #####:  272:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  273:    return this->m_Log_OutputPort[portNum].registerSerialPort(port);
        -:  274:  }
        -:  275:
        -:  276:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  277:  void HealthComponentBase ::
        -:  278:    set_LogText_OutputPort(
        -:  279:        NATIVE_INT_TYPE portNum,
        -:  280:        Fw::InputSerializePort *port
        -:  281:    )
        -:  282:  {
    #####:  283:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  284:    return this->m_LogText_OutputPort[portNum].registerSerialPort(port);
        -:  285:  }
        -:  286:#endif
        -:  287:
        -:  288:#endif
        -:  289:
        -:  290:  // ----------------------------------------------------------------------
        -:  291:  // Command registration
        -:  292:  // ----------------------------------------------------------------------
        -:  293:
    #####:  294:  void HealthComponentBase ::
        -:  295:    regCommands(void)
        -:  296:  {
    #####:  297:    FW_ASSERT(this->m_CmdReg_OutputPort[0].isConnected());
    #####:  298:    this->m_CmdReg_OutputPort[0].invoke(
        -:  299:        this->getIdBase() + OPCODE_HLTH_ENABLE
    #####:  300:    );
    #####:  301:    this->m_CmdReg_OutputPort[0].invoke(
    #####:  302:        this->getIdBase() + OPCODE_HLTH_PING_ENABLE
    #####:  303:    );
    #####:  304:    this->m_CmdReg_OutputPort[0].invoke(
    #####:  305:        this->getIdBase() + OPCODE_HLTH_CHNG_PING
    #####:  306:    );
    #####:  307:  }
        -:  308:
        -:  309:  // ----------------------------------------------------------------------
        -:  310:  // Component construction, initialization, and destruction
        -:  311:  // ----------------------------------------------------------------------
        -:  312:
       10:  313:  HealthComponentBase ::
        -:  314:#if FW_OBJECT_NAMES == 1
        -:  315:    HealthComponentBase(const char* compName) :
       10:  316:      Fw::QueuedComponentBase(compName)
        -:  317:#else
        -:  318:    HealthComponentBase() :
        -:  319:      Fw::QueuedComponentBase()
        -:  320:#endif
        -:  321:  {
        -:  322:
        -:  323:
        -:  324:  
        -:  325:  
       10:  326:  }
        -:  327:
       10:  328:  void HealthComponentBase ::
        -:  329:    init(
        -:  330:        NATIVE_INT_TYPE queueDepth,
        -:  331:        NATIVE_INT_TYPE instance
        -:  332:    )
        -:  333:  {
        -:  334:
        -:  335:    // Initialize base class
       10:  336:    Fw::QueuedComponentBase::init(instance);
        -:  337:
        -:  338:    // Connect input port PingReturn
      210:  339:    for (
       10:  340:        NATIVE_INT_TYPE port = 0;
      110:  341:        port < this->getNum_PingReturn_InputPorts();
        -:  342:        port++
        -:  343:    ) {
        -:  344:
      100:  345:      this->m_PingReturn_InputPort[port].init();
      100:  346:      this->m_PingReturn_InputPort[port].addCallComp(
        -:  347:          this,
        -:  348:          m_p_PingReturn_in
      100:  349:      );
      100:  350:      this->m_PingReturn_InputPort[port].setPortNum(port);
        -:  351:
        -:  352:#if FW_OBJECT_NAMES == 1
        -:  353:      char portName[80];
      100:  354:      (void) snprintf(
        -:  355:          portName,
        -:  356:          sizeof(portName),
        -:  357:          "%s_PingReturn_InputPort[%d]",
        -:  358:          this->m_objName,
        -:  359:          port
      100:  360:      );
      100:  361:      this->m_PingReturn_InputPort[port].setObjName(portName);
        -:  362:#endif
        -:  363:
        -:  364:    }
        -:  365:
        -:  366:    // Connect input port Run
       30:  367:    for (
       10:  368:        NATIVE_INT_TYPE port = 0;
       20:  369:        port < this->getNum_Run_InputPorts();
        -:  370:        port++
        -:  371:    ) {
        -:  372:
       10:  373:      this->m_Run_InputPort[port].init();
       10:  374:      this->m_Run_InputPort[port].addCallComp(
        -:  375:          this,
        -:  376:          m_p_Run_in
       10:  377:      );
       10:  378:      this->m_Run_InputPort[port].setPortNum(port);
        -:  379:
        -:  380:#if FW_OBJECT_NAMES == 1
        -:  381:      char portName[80];
       10:  382:      (void) snprintf(
        -:  383:          portName,
        -:  384:          sizeof(portName),
        -:  385:          "%s_Run_InputPort[%d]",
        -:  386:          this->m_objName,
        -:  387:          port
       10:  388:      );
       10:  389:      this->m_Run_InputPort[port].setObjName(portName);
        -:  390:#endif
        -:  391:
        -:  392:    }
        -:  393:
        -:  394:    // Connect input port CmdDisp
       30:  395:    for (
       10:  396:        NATIVE_INT_TYPE port = 0;
       20:  397:        port < this->getNum_CmdDisp_InputPorts();
        -:  398:        port++
        -:  399:    ) {
        -:  400:
       10:  401:      this->m_CmdDisp_InputPort[port].init();
       10:  402:      this->m_CmdDisp_InputPort[port].addCallComp(
        -:  403:          this,
        -:  404:          m_p_CmdDisp_in
       10:  405:      );
       10:  406:      this->m_CmdDisp_InputPort[port].setPortNum(port);
        -:  407:
        -:  408:#if FW_OBJECT_NAMES == 1
        -:  409:      char portName[80];
       10:  410:      (void) snprintf(
        -:  411:          portName,
        -:  412:          sizeof(portName),
        -:  413:          "%s_CmdDisp_InputPort[%d]",
        -:  414:          this->m_objName,
        -:  415:          port
       10:  416:      );
       10:  417:      this->m_CmdDisp_InputPort[port].setObjName(portName);
        -:  418:#endif
        -:  419:
        -:  420:    }
        -:  421:
        -:  422:    // Initialize output port PingSend
      210:  423:    for (
       10:  424:        NATIVE_INT_TYPE port = 0;
      110:  425:        port < this->getNum_PingSend_OutputPorts();
        -:  426:        port++
        -:  427:    ) {
      100:  428:      this->m_PingSend_OutputPort[port].init();
        -:  429:
        -:  430:#if FW_OBJECT_NAMES == 1
        -:  431:      char portName[80];
      100:  432:      (void) snprintf(
        -:  433:          portName,
        -:  434:          sizeof(portName),
        -:  435:          "%s_PingSend_OutputPort[%d]",
        -:  436:          this->m_objName,
        -:  437:          port
      100:  438:      );
      100:  439:      this->m_PingSend_OutputPort[port].setObjName(portName);
        -:  440:#endif
        -:  441:
        -:  442:    }
        -:  443:
        -:  444:    // Initialize output port WdogStroke
       30:  445:    for (
       10:  446:        NATIVE_INT_TYPE port = 0;
       20:  447:        port < this->getNum_WdogStroke_OutputPorts();
        -:  448:        port++
        -:  449:    ) {
       10:  450:      this->m_WdogStroke_OutputPort[port].init();
        -:  451:
        -:  452:#if FW_OBJECT_NAMES == 1
        -:  453:      char portName[80];
       10:  454:      (void) snprintf(
        -:  455:          portName,
        -:  456:          sizeof(portName),
        -:  457:          "%s_WdogStroke_OutputPort[%d]",
        -:  458:          this->m_objName,
        -:  459:          port
       10:  460:      );
       10:  461:      this->m_WdogStroke_OutputPort[port].setObjName(portName);
        -:  462:#endif
        -:  463:
        -:  464:    }
        -:  465:
        -:  466:    // Initialize output port CmdStatus
       30:  467:    for (
       10:  468:        NATIVE_INT_TYPE port = 0;
       20:  469:        port < this->getNum_CmdStatus_OutputPorts();
        -:  470:        port++
        -:  471:    ) {
       10:  472:      this->m_CmdStatus_OutputPort[port].init();
        -:  473:
        -:  474:#if FW_OBJECT_NAMES == 1
        -:  475:      char portName[80];
       10:  476:      (void) snprintf(
        -:  477:          portName,
        -:  478:          sizeof(portName),
        -:  479:          "%s_CmdStatus_OutputPort[%d]",
        -:  480:          this->m_objName,
        -:  481:          port
       10:  482:      );
       10:  483:      this->m_CmdStatus_OutputPort[port].setObjName(portName);
        -:  484:#endif
        -:  485:
        -:  486:    }
        -:  487:
        -:  488:    // Initialize output port CmdReg
       30:  489:    for (
       10:  490:        NATIVE_INT_TYPE port = 0;
       20:  491:        port < this->getNum_CmdReg_OutputPorts();
        -:  492:        port++
        -:  493:    ) {
       10:  494:      this->m_CmdReg_OutputPort[port].init();
        -:  495:
        -:  496:#if FW_OBJECT_NAMES == 1
        -:  497:      char portName[80];
       10:  498:      (void) snprintf(
        -:  499:          portName,
        -:  500:          sizeof(portName),
        -:  501:          "%s_CmdReg_OutputPort[%d]",
        -:  502:          this->m_objName,
        -:  503:          port
       10:  504:      );
       10:  505:      this->m_CmdReg_OutputPort[port].setObjName(portName);
        -:  506:#endif
        -:  507:
        -:  508:    }
        -:  509:
        -:  510:    // Initialize output port Tlm
       30:  511:    for (
       10:  512:        NATIVE_INT_TYPE port = 0;
       20:  513:        port < this->getNum_Tlm_OutputPorts();
        -:  514:        port++
        -:  515:    ) {
       10:  516:      this->m_Tlm_OutputPort[port].init();
        -:  517:
        -:  518:#if FW_OBJECT_NAMES == 1
        -:  519:      char portName[80];
       10:  520:      (void) snprintf(
        -:  521:          portName,
        -:  522:          sizeof(portName),
        -:  523:          "%s_Tlm_OutputPort[%d]",
        -:  524:          this->m_objName,
        -:  525:          port
       10:  526:      );
       10:  527:      this->m_Tlm_OutputPort[port].setObjName(portName);
        -:  528:#endif
        -:  529:
        -:  530:    }
        -:  531:
        -:  532:    // Initialize output port Time
       30:  533:    for (
       10:  534:        NATIVE_INT_TYPE port = 0;
       20:  535:        port < this->getNum_Time_OutputPorts();
        -:  536:        port++
        -:  537:    ) {
       10:  538:      this->m_Time_OutputPort[port].init();
        -:  539:
        -:  540:#if FW_OBJECT_NAMES == 1
        -:  541:      char portName[80];
       10:  542:      (void) snprintf(
        -:  543:          portName,
        -:  544:          sizeof(portName),
        -:  545:          "%s_Time_OutputPort[%d]",
        -:  546:          this->m_objName,
        -:  547:          port
       10:  548:      );
       10:  549:      this->m_Time_OutputPort[port].setObjName(portName);
        -:  550:#endif
        -:  551:
        -:  552:    }
        -:  553:
        -:  554:    // Initialize output port Log
       30:  555:    for (
       10:  556:        NATIVE_INT_TYPE port = 0;
       20:  557:        port < this->getNum_Log_OutputPorts();
        -:  558:        port++
        -:  559:    ) {
       10:  560:      this->m_Log_OutputPort[port].init();
        -:  561:
        -:  562:#if FW_OBJECT_NAMES == 1
        -:  563:      char portName[80];
       10:  564:      (void) snprintf(
        -:  565:          portName,
        -:  566:          sizeof(portName),
        -:  567:          "%s_Log_OutputPort[%d]",
        -:  568:          this->m_objName,
        -:  569:          port
       10:  570:      );
       10:  571:      this->m_Log_OutputPort[port].setObjName(portName);
        -:  572:#endif
        -:  573:
        -:  574:    }
        -:  575:
        -:  576:    // Initialize output port LogText
        -:  577:#if FW_ENABLE_TEXT_LOGGING == 1
       30:  578:    for (
       10:  579:        NATIVE_INT_TYPE port = 0;
       20:  580:        port < this->getNum_LogText_OutputPorts();
        -:  581:        port++
        -:  582:    ) {
       10:  583:      this->m_LogText_OutputPort[port].init();
        -:  584:
        -:  585:#if FW_OBJECT_NAMES == 1
        -:  586:      char portName[80];
       10:  587:      (void) snprintf(
        -:  588:          portName,
        -:  589:          sizeof(portName),
        -:  590:          "%s_LogText_OutputPort[%d]",
        -:  591:          this->m_objName,
        -:  592:          port
       10:  593:      );
       10:  594:      this->m_LogText_OutputPort[port].setObjName(portName);
        -:  595:#endif
        -:  596:
        -:  597:    }
        -:  598:#endif
        -:  599:
        -:  600:    Os::Queue::QueueStatus qStat =
       10:  601:    this->createQueue(
        -:  602:        queueDepth,
        -:  603:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
       10:  604:    );
        -:  605:    FW_ASSERT(
        -:  606:        Os::Queue::QUEUE_OK == qStat,
        -:  607:        static_cast<AssertArg>(qStat)
       10:  608:    );
        -:  609:
       10:  610:  }
        -:  611:
       10:  612:  HealthComponentBase::
       10:  613:    ~HealthComponentBase() {
        -:  614:
       10:  615:  }
        -:  616:
        -:  617:  // ----------------------------------------------------------------------
        -:  618:  // Invocation functions for output ports
        -:  619:  // ----------------------------------------------------------------------
        -:  620:
      421:  621:  void HealthComponentBase ::
        -:  622:    PingSend_out(
        -:  623:        NATIVE_INT_TYPE portNum,
        -:  624:        U32 key
        -:  625:    )
        -:  626:  {
      421:  627:    FW_ASSERT(portNum < this->getNum_PingSend_OutputPorts(),static_cast<AssertArg>(portNum));
      421:  628:    this->m_PingSend_OutputPort[portNum].invoke(key);
      421:  629:  }
        -:  630:
      302:  631:  void HealthComponentBase ::
        -:  632:    WdogStroke_out(
        -:  633:        NATIVE_INT_TYPE portNum,
        -:  634:        U32 code
        -:  635:    )
        -:  636:  {
      302:  637:    FW_ASSERT(portNum < this->getNum_WdogStroke_OutputPorts(),static_cast<AssertArg>(portNum));
      302:  638:    this->m_WdogStroke_OutputPort[portNum].invoke(code);
      302:  639:  }
        -:  640:
        -:  641:  // ----------------------------------------------------------------------
        -:  642:  // Getters for numbers of ports
        -:  643:  // ----------------------------------------------------------------------
        -:  644:
      741:  645:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  646:    getNum_PingSend_OutputPorts(void)
        -:  647:  {
      741:  648:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  649:        this->m_PingSend_OutputPort
        -:  650:    );
        -:  651:  }
        -:  652:
      620:  653:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  654:    getNum_PingReturn_InputPorts(void)
        -:  655:  {
      620:  656:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  657:        this->m_PingReturn_InputPort
        -:  658:    );
        -:  659:  }
        -:  660:
      332:  661:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  662:    getNum_Run_InputPorts(void)
        -:  663:  {
      332:  664:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  665:        this->m_Run_InputPort
        -:  666:    );
        -:  667:  }
        -:  668:
      634:  669:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  670:    getNum_WdogStroke_OutputPorts(void)
        -:  671:  {
      634:  672:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  673:        this->m_WdogStroke_OutputPort
        -:  674:    );
        -:  675:  }
        -:  676:
       30:  677:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  678:    getNum_CmdDisp_InputPorts(void)
        -:  679:  {
       30:  680:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  681:        this->m_CmdDisp_InputPort
        -:  682:    );
        -:  683:  }
        -:  684:
       30:  685:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  686:    getNum_CmdStatus_OutputPorts(void)
        -:  687:  {
       30:  688:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  689:        this->m_CmdStatus_OutputPort
        -:  690:    );
        -:  691:  }
        -:  692:
       30:  693:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  694:    getNum_CmdReg_OutputPorts(void)
        -:  695:  {
       30:  696:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  697:        this->m_CmdReg_OutputPort
        -:  698:    );
        -:  699:  }
        -:  700:
       30:  701:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  702:    getNum_Tlm_OutputPorts(void)
        -:  703:  {
       30:  704:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  705:        this->m_Tlm_OutputPort
        -:  706:    );
        -:  707:  }
        -:  708:
       30:  709:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  710:    getNum_Time_OutputPorts(void)
        -:  711:  {
       30:  712:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  713:        this->m_Time_OutputPort
        -:  714:    );
        -:  715:  }
        -:  716:
       30:  717:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  718:    getNum_Log_OutputPorts(void)
        -:  719:  {
       30:  720:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  721:        this->m_Log_OutputPort
        -:  722:    );
        -:  723:  }
        -:  724:
        -:  725:#if FW_ENABLE_TEXT_LOGGING == 1
       30:  726:  NATIVE_INT_TYPE HealthComponentBase ::
        -:  727:    getNum_LogText_OutputPorts(void)
        -:  728:  {
       30:  729:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  730:        this->m_LogText_OutputPort
        -:  731:    );
        -:  732:  }
        -:  733:#endif
        -:  734:
        -:  735:  // ----------------------------------------------------------------------
        -:  736:  // Port connection status queries
        -:  737:  // ----------------------------------------------------------------------
        -:  738:
    #####:  739:  bool HealthComponentBase ::
        -:  740:    isConnected_PingSend_OutputPort(NATIVE_INT_TYPE portNum)
        -:  741:  {
    #####:  742:     FW_ASSERT(
        -:  743:        portNum < this->getNum_PingSend_OutputPorts(),
        -:  744:        static_cast<AssertArg>(portNum)
    #####:  745:     );
    #####:  746:     return this->m_PingSend_OutputPort[portNum].isConnected();
        -:  747:  }
        -:  748:
      302:  749:  bool HealthComponentBase ::
        -:  750:    isConnected_WdogStroke_OutputPort(NATIVE_INT_TYPE portNum)
        -:  751:  {
      302:  752:     FW_ASSERT(
        -:  753:        portNum < this->getNum_WdogStroke_OutputPorts(),
        -:  754:        static_cast<AssertArg>(portNum)
      302:  755:     );
      302:  756:     return this->m_WdogStroke_OutputPort[portNum].isConnected();
        -:  757:  }
        -:  758:
    #####:  759:  bool HealthComponentBase ::
        -:  760:    isConnected_CmdStatus_OutputPort(NATIVE_INT_TYPE portNum)
        -:  761:  {
    #####:  762:     FW_ASSERT(
        -:  763:        portNum < this->getNum_CmdStatus_OutputPorts(),
        -:  764:        static_cast<AssertArg>(portNum)
    #####:  765:     );
    #####:  766:     return this->m_CmdStatus_OutputPort[portNum].isConnected();
        -:  767:  }
        -:  768:
    #####:  769:  bool HealthComponentBase ::
        -:  770:    isConnected_CmdReg_OutputPort(NATIVE_INT_TYPE portNum)
        -:  771:  {
    #####:  772:     FW_ASSERT(
        -:  773:        portNum < this->getNum_CmdReg_OutputPorts(),
        -:  774:        static_cast<AssertArg>(portNum)
    #####:  775:     );
    #####:  776:     return this->m_CmdReg_OutputPort[portNum].isConnected();
        -:  777:  }
        -:  778:
    #####:  779:  bool HealthComponentBase ::
        -:  780:    isConnected_Tlm_OutputPort(NATIVE_INT_TYPE portNum)
        -:  781:  {
    #####:  782:     FW_ASSERT(
        -:  783:        portNum < this->getNum_Tlm_OutputPorts(),
        -:  784:        static_cast<AssertArg>(portNum)
    #####:  785:     );
    #####:  786:     return this->m_Tlm_OutputPort[portNum].isConnected();
        -:  787:  }
        -:  788:
    #####:  789:  bool HealthComponentBase ::
        -:  790:    isConnected_Time_OutputPort(NATIVE_INT_TYPE portNum)
        -:  791:  {
    #####:  792:     FW_ASSERT(
        -:  793:        portNum < this->getNum_Time_OutputPorts(),
        -:  794:        static_cast<AssertArg>(portNum)
    #####:  795:     );
    #####:  796:     return this->m_Time_OutputPort[portNum].isConnected();
        -:  797:  }
        -:  798:
    #####:  799:  bool HealthComponentBase ::
        -:  800:    isConnected_Log_OutputPort(NATIVE_INT_TYPE portNum)
        -:  801:  {
    #####:  802:     FW_ASSERT(
        -:  803:        portNum < this->getNum_Log_OutputPorts(),
        -:  804:        static_cast<AssertArg>(portNum)
    #####:  805:     );
    #####:  806:     return this->m_Log_OutputPort[portNum].isConnected();
        -:  807:  }
        -:  808:
        -:  809:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  810:  bool HealthComponentBase ::
        -:  811:    isConnected_LogText_OutputPort(NATIVE_INT_TYPE portNum)
        -:  812:  {
    #####:  813:     FW_ASSERT(
        -:  814:        portNum < this->getNum_LogText_OutputPorts(),
        -:  815:        static_cast<AssertArg>(portNum)
    #####:  816:     );
    #####:  817:     return this->m_LogText_OutputPort[portNum].isConnected();
        -:  818:  }
        -:  819:#endif
        -:  820:
        -:  821:  // ----------------------------------------------------------------------
        -:  822:  // Calls for messages received on command input ports
        -:  823:  // ----------------------------------------------------------------------
        -:  824:
       41:  825:  void HealthComponentBase ::
        -:  826:    m_p_CmdDisp_in(
        -:  827:        Fw::PassiveComponentBase* callComp,
        -:  828:        NATIVE_INT_TYPE portNum,
        -:  829:        FwOpcodeType opCode,
        -:  830:        U32 cmdSeq,
        -:  831:        Fw::CmdArgBuffer &args
        -:  832:    )
        -:  833:  {
        -:  834:
        -:  835:    // Select base class function based on opcode
       41:  836:    FW_ASSERT(callComp);
        -:  837:    HealthComponentBase* compPtr =
       41:  838:      (HealthComponentBase*) callComp;
        -:  839:
       41:  840:    const U32 idBase = callComp->getIdBase();
       41:  841:    FW_ASSERT(opCode >= idBase, opCode, idBase);
       41:  842:    switch (opCode - idBase) {
        -:  843:
        -:  844:      case OPCODE_HLTH_ENABLE: /*!< A command to enable or disable health checks */
        -:  845:        compPtr->HLTH_ENABLE_cmdHandlerBase(
        -:  846:            opCode,
        -:  847:            cmdSeq,
        -:  848:            args
        5:  849:        );
        5:  850:        break;
        -:  851:        
        -:  852:      case OPCODE_HLTH_PING_ENABLE: /*!< Ignore a particular ping entry */
        -:  853:        compPtr->HLTH_PING_ENABLE_cmdHandlerBase(
        -:  854:            opCode,
        -:  855:            cmdSeq,
        -:  856:            args
       23:  857:        );
       23:  858:        break;
        -:  859:        
        -:  860:      case OPCODE_HLTH_CHNG_PING: /*!< Change ping value */
        -:  861:        compPtr->HLTH_CHNG_PING_cmdHandlerBase(
        -:  862:            opCode,
        -:  863:            cmdSeq,
        -:  864:            args
       13:  865:        );
       13:  866:        break;
        -:  867:        
        -:  868:      default: {
        -:  869:        compPtr->cmdResponse_out(
        -:  870:            opCode,cmdSeq,
        -:  871:            Fw::COMMAND_INVALID_OPCODE
    #####:  872:        );
    #####:  873:        break;
        -:  874:      }
        -:  875:
        -:  876:    }
        -:  877:
       41:  878:  }
        -:  879:
       41:  880:  void HealthComponentBase ::
        -:  881:    cmdResponse_out(
        -:  882:        FwOpcodeType opCode,
        -:  883:        U32 cmdSeq,
        -:  884:        Fw::CommandResponse response
        -:  885:    )
        -:  886:  {
       41:  887:    FW_ASSERT(this->m_CmdStatus_OutputPort[0].isConnected());
       41:  888:    this->m_CmdStatus_OutputPort[0].invoke(opCode,cmdSeq,response);
       41:  889:  }
        -:  890:
        -:  891:  // ----------------------------------------------------------------------
        -:  892:  // Base class command functions
        -:  893:  // ----------------------------------------------------------------------
        -:  894:
        5:  895:  void HealthComponentBase ::
        -:  896:    HLTH_ENABLE_cmdHandlerBase(
        -:  897:        FwOpcodeType opCode,
        -:  898:        U32 cmdSeq,
        -:  899:        Fw::CmdArgBuffer &args
        -:  900:    )
        -:  901:  {
        -:  902:
        -:  903:    // Call pre-message hook
        5:  904:    this->HLTH_ENABLE_preMsgHook(opCode,cmdSeq);
        -:  905:
        -:  906:    // Defer deserializing arguments to the message dispatcher
        -:  907:    // to avoid deserializing and reserializing just for IPC
       10:  908:    ComponentIpcSerializableBuffer msg;
        5:  909:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  910:
        -:  911:    // Serialize for IPC
        5:  912:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_HLTH_ENABLE);
        -:  913:    FW_ASSERT (
        -:  914:        _status == Fw::FW_SERIALIZE_OK,
        -:  915:        static_cast<AssertArg>(_status)
        5:  916:        );
        -:  917:
        -:  918:    // Fake port number to make message dequeue work
        5:  919:    NATIVE_INT_TYPE port = 0;
        5:  920:    _status = msg.serialize(port);
        -:  921:    FW_ASSERT (
        -:  922:        _status == Fw::FW_SERIALIZE_OK,
        -:  923:        static_cast<AssertArg>(_status)
        5:  924:    );
        -:  925:
        5:  926:    _status = msg.serialize(opCode);
        -:  927:    FW_ASSERT (
        -:  928:        _status == Fw::FW_SERIALIZE_OK,
        -:  929:        static_cast<AssertArg>(_status)
        5:  930:    );
        -:  931:
        5:  932:    _status = msg.serialize(cmdSeq);
        -:  933:    FW_ASSERT (
        -:  934:        _status == Fw::FW_SERIALIZE_OK,
        -:  935:        static_cast<AssertArg>(_status)
        5:  936:    );
        -:  937:
        5:  938:    _status = msg.serialize(args);
        -:  939:    FW_ASSERT (
        -:  940:        _status == Fw::FW_SERIALIZE_OK,
        -:  941:        static_cast<AssertArg>(_status)
        5:  942:    );
        -:  943:    
        -:  944:    // send message
        -:  945:    Os::Queue::QueueBlocking _block = 
        5:  946:      Os::Queue::QUEUE_NONBLOCKING;
        -:  947:    Os::Queue::QueueStatus qStatus =
        5:  948:      this->m_queue.send(msg, 0,_block);
        -:  949:    FW_ASSERT(
        -:  950:        qStatus == Os::Queue::QUEUE_OK,
        -:  951:        static_cast<AssertArg>(qStatus)
        5:  952:    );    
        -:  953:
        5:  954:  }
        -:  955:
        5:  956:  void HealthComponentBase::
        -:  957:    HLTH_ENABLE_preMsgHook(
        -:  958:        FwOpcodeType opCode,
        -:  959:        U32 cmdSeq
        -:  960:    )
        -:  961:  {
        -:  962:    // Defaults to no-op; can be overridden
        5:  963:  }
        -:  964:
       23:  965:  void HealthComponentBase ::
        -:  966:    HLTH_PING_ENABLE_cmdHandlerBase(
        -:  967:        FwOpcodeType opCode,
        -:  968:        U32 cmdSeq,
        -:  969:        Fw::CmdArgBuffer &args
        -:  970:    )
        -:  971:  {
        -:  972:
        -:  973:    // Call pre-message hook
       23:  974:    this->HLTH_PING_ENABLE_preMsgHook(opCode,cmdSeq);
        -:  975:
        -:  976:    // Defer deserializing arguments to the message dispatcher
        -:  977:    // to avoid deserializing and reserializing just for IPC
       46:  978:    ComponentIpcSerializableBuffer msg;
       23:  979:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  980:
        -:  981:    // Serialize for IPC
       23:  982:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_HLTH_PING_ENABLE);
        -:  983:    FW_ASSERT (
        -:  984:        _status == Fw::FW_SERIALIZE_OK,
        -:  985:        static_cast<AssertArg>(_status)
       23:  986:        );
        -:  987:
        -:  988:    // Fake port number to make message dequeue work
       23:  989:    NATIVE_INT_TYPE port = 0;
       23:  990:    _status = msg.serialize(port);
        -:  991:    FW_ASSERT (
        -:  992:        _status == Fw::FW_SERIALIZE_OK,
        -:  993:        static_cast<AssertArg>(_status)
       23:  994:    );
        -:  995:
       23:  996:    _status = msg.serialize(opCode);
        -:  997:    FW_ASSERT (
        -:  998:        _status == Fw::FW_SERIALIZE_OK,
        -:  999:        static_cast<AssertArg>(_status)
       23: 1000:    );
        -: 1001:
       23: 1002:    _status = msg.serialize(cmdSeq);
        -: 1003:    FW_ASSERT (
        -: 1004:        _status == Fw::FW_SERIALIZE_OK,
        -: 1005:        static_cast<AssertArg>(_status)
       23: 1006:    );
        -: 1007:
       23: 1008:    _status = msg.serialize(args);
        -: 1009:    FW_ASSERT (
        -: 1010:        _status == Fw::FW_SERIALIZE_OK,
        -: 1011:        static_cast<AssertArg>(_status)
       23: 1012:    );
        -: 1013:    
        -: 1014:    // send message
        -: 1015:    Os::Queue::QueueBlocking _block = 
       23: 1016:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1017:    Os::Queue::QueueStatus qStatus =
       23: 1018:      this->m_queue.send(msg, 0,_block);
        -: 1019:    FW_ASSERT(
        -: 1020:        qStatus == Os::Queue::QUEUE_OK,
        -: 1021:        static_cast<AssertArg>(qStatus)
       23: 1022:    );    
        -: 1023:
       23: 1024:  }
        -: 1025:
       23: 1026:  void HealthComponentBase::
        -: 1027:    HLTH_PING_ENABLE_preMsgHook(
        -: 1028:        FwOpcodeType opCode,
        -: 1029:        U32 cmdSeq
        -: 1030:    )
        -: 1031:  {
        -: 1032:    // Defaults to no-op; can be overridden
       23: 1033:  }
        -: 1034:
       13: 1035:  void HealthComponentBase ::
        -: 1036:    HLTH_CHNG_PING_cmdHandlerBase(
        -: 1037:        FwOpcodeType opCode,
        -: 1038:        U32 cmdSeq,
        -: 1039:        Fw::CmdArgBuffer &args
        -: 1040:    )
        -: 1041:  {
        -: 1042:
        -: 1043:    // Call pre-message hook
       13: 1044:    this->HLTH_CHNG_PING_preMsgHook(opCode,cmdSeq);
        -: 1045:
        -: 1046:    // Defer deserializing arguments to the message dispatcher
        -: 1047:    // to avoid deserializing and reserializing just for IPC
       26: 1048:    ComponentIpcSerializableBuffer msg;
       13: 1049:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1050:
        -: 1051:    // Serialize for IPC
       13: 1052:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_HLTH_CHNG_PING);
        -: 1053:    FW_ASSERT (
        -: 1054:        _status == Fw::FW_SERIALIZE_OK,
        -: 1055:        static_cast<AssertArg>(_status)
       13: 1056:        );
        -: 1057:
        -: 1058:    // Fake port number to make message dequeue work
       13: 1059:    NATIVE_INT_TYPE port = 0;
       13: 1060:    _status = msg.serialize(port);
        -: 1061:    FW_ASSERT (
        -: 1062:        _status == Fw::FW_SERIALIZE_OK,
        -: 1063:        static_cast<AssertArg>(_status)
       13: 1064:    );
        -: 1065:
       13: 1066:    _status = msg.serialize(opCode);
        -: 1067:    FW_ASSERT (
        -: 1068:        _status == Fw::FW_SERIALIZE_OK,
        -: 1069:        static_cast<AssertArg>(_status)
       13: 1070:    );
        -: 1071:
       13: 1072:    _status = msg.serialize(cmdSeq);
        -: 1073:    FW_ASSERT (
        -: 1074:        _status == Fw::FW_SERIALIZE_OK,
        -: 1075:        static_cast<AssertArg>(_status)
       13: 1076:    );
        -: 1077:
       13: 1078:    _status = msg.serialize(args);
        -: 1079:    FW_ASSERT (
        -: 1080:        _status == Fw::FW_SERIALIZE_OK,
        -: 1081:        static_cast<AssertArg>(_status)
       13: 1082:    );
        -: 1083:    
        -: 1084:    // send message
        -: 1085:    Os::Queue::QueueBlocking _block = 
       13: 1086:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1087:    Os::Queue::QueueStatus qStatus =
       13: 1088:      this->m_queue.send(msg, 0,_block);
        -: 1089:    FW_ASSERT(
        -: 1090:        qStatus == Os::Queue::QUEUE_OK,
        -: 1091:        static_cast<AssertArg>(qStatus)
       13: 1092:    );    
        -: 1093:
       13: 1094:  }
        -: 1095:
       13: 1096:  void HealthComponentBase::
        -: 1097:    HLTH_CHNG_PING_preMsgHook(
        -: 1098:        FwOpcodeType opCode,
        -: 1099:        U32 cmdSeq
        -: 1100:    )
        -: 1101:  {
        -: 1102:    // Defaults to no-op; can be overridden
       13: 1103:  }
        -: 1104:
        -: 1105:  // ----------------------------------------------------------------------
        -: 1106:  // Telemetry write functions
        -: 1107:  // ----------------------------------------------------------------------
        -: 1108:
       21: 1109:  void HealthComponentBase ::
        -: 1110:    tlmWrite_PingLateWarnings(U32 arg)
        -: 1111:  {
        -: 1112:
       21: 1113:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       42: 1114:      Fw::Time _tlmTime;
       21: 1115:      if (this->m_Time_OutputPort[0].isConnected()) {
       21: 1116:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1117:      }
       42: 1118:      Fw::TlmBuffer _tlmBuff;
       21: 1119:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        -: 1120:      FW_ASSERT(
        -: 1121:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1122:          static_cast<AssertArg>(_stat)
       21: 1123:      );
        -: 1124:      
        -: 1125:      FwChanIdType _id;
        -: 1126:      
       21: 1127:      _id = this->getIdBase() + CHANNELID_PINGLATEWARNINGS;
        -: 1128:      
       21: 1129:      this->m_Tlm_OutputPort[0].invoke(
        -: 1130:          _id,
        -: 1131:          _tlmTime,
        -: 1132:          _tlmBuff
       21: 1133:      );
        -: 1134:    }
        -: 1135:
       21: 1136:  }
        -: 1137:
        -: 1138:  // ----------------------------------------------------------------------
        -: 1139:  // Time
        -: 1140:  // ----------------------------------------------------------------------
        -: 1141:
    #####: 1142:  Fw::Time HealthComponentBase ::
        -: 1143:    getTime(void) 
        -: 1144:  {
    #####: 1145:    if (this->m_Time_OutputPort[0].isConnected()) {
    #####: 1146:      Fw::Time _time;
    #####: 1147:      this->m_Time_OutputPort[0].invoke(_time);
    #####: 1148:      return _time;
        -: 1149:    } else {
    #####: 1150:      return Fw::Time(TB_NONE,0,0);
        -: 1151:    }
        -: 1152:  }
        -: 1153:
        -: 1154:  // ----------------------------------------------------------------------
        -: 1155:  // Event handling functions
        -: 1156:  // ----------------------------------------------------------------------
        -: 1157:
       21: 1158:  void HealthComponentBase ::
        -: 1159:    log_WARNING_HI_HLTH_PING_WARN(
        -: 1160:        Fw::LogStringArg& entry
        -: 1161:    )
        -: 1162:  {
        -: 1163:  
        -: 1164:
        -: 1165:    // Get the time
       42: 1166:    Fw::Time _logTime;
       21: 1167:    if (this->m_Time_OutputPort[0].isConnected()) {
       21: 1168:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1169:    }
        -: 1170:    
       21: 1171:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1172:    
       21: 1173:    _id = this->getIdBase() + EVENTID_HLTH_PING_WARN;
        -: 1174:
        -: 1175:    // Emit the event on the log port
       21: 1176:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1177:
       42: 1178:      Fw::LogBuffer _logBuff;
       21: 1179:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1180:
        -: 1181:#if FW_AMPCS_COMPATIBLE
        -: 1182:      // Serialize the number of arguments
        -: 1183:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1184:      FW_ASSERT(
        -: 1185:          _status == Fw::FW_SERIALIZE_OK,
        -: 1186:          static_cast<AssertArg>(_status)
        -: 1187:      );
        -: 1188:#endif
        -: 1189:
       21: 1190:      entry.setMaxSerialize(40);
       21: 1191:      _status = _logBuff.serialize(entry);
        -: 1192:      FW_ASSERT(
        -: 1193:          _status == Fw::FW_SERIALIZE_OK,
        -: 1194:          static_cast<AssertArg>(_status)
       21: 1195:      );
        -: 1196:
        -: 1197:
       21: 1198:      this->m_Log_OutputPort[0].invoke(
        -: 1199:          _id,
        -: 1200:          _logTime,Fw::LOG_WARNING_HI,
        -: 1201:          _logBuff
       21: 1202:      );
        -: 1203:
        -: 1204:    }
        -: 1205:
        -: 1206:    // Emit the event on the text log port
        -: 1207:#if FW_ENABLE_TEXT_LOGGING
       21: 1208:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1209:
        -: 1210:#if FW_OBJECT_NAMES == 1
        -: 1211:      const char* _formatString =
       21: 1212:        "(%s) %s: Ping entry %s late warning";
        -: 1213:#else
        -: 1214:      const char* _formatString =
        -: 1215:        "%s: Ping entry %s late warning";
        -: 1216:#endif
        -: 1217:
        -: 1218:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1219:
       21: 1220:      (void) snprintf(
        -: 1221:          _textBuffer,
        -: 1222:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1223:          _formatString,
        -: 1224:#if FW_OBJECT_NAMES == 1
        -: 1225:          this->m_objName,
        -: 1226:#endif
        -: 1227:          "HLTH_PING_WARN "
       21: 1228:        , entry.toChar()
       21: 1229:      );
        -: 1230:
        -: 1231:      // Null terminate
       21: 1232:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       42: 1233:      Fw::TextLogString _logString = _textBuffer;
       21: 1234:      this->m_LogText_OutputPort[0].invoke(
        -: 1235:          _id,
        -: 1236:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1237:          _logString
       21: 1238:      );
        -: 1239:
        -: 1240:    }
        -: 1241:#endif
        -: 1242:
       21: 1243:  }
        -: 1244:  
        -: 1245:
       20: 1246:  void HealthComponentBase ::
        -: 1247:    log_FATAL_HLTH_PING_LATE(
        -: 1248:        Fw::LogStringArg& entry
        -: 1249:    )
        -: 1250:  {
        -: 1251:  
        -: 1252:
        -: 1253:    // Get the time
       40: 1254:    Fw::Time _logTime;
       20: 1255:    if (this->m_Time_OutputPort[0].isConnected()) {
       20: 1256:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1257:    }
        -: 1258:    
       20: 1259:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1260:    
       20: 1261:    _id = this->getIdBase() + EVENTID_HLTH_PING_LATE;
        -: 1262:
        -: 1263:    // Emit the event on the log port
       20: 1264:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1265:
       40: 1266:      Fw::LogBuffer _logBuff;
       20: 1267:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1268:
        -: 1269:#if FW_AMPCS_COMPATIBLE
        -: 1270:      // Serialize the number of arguments
        -: 1271:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1272:      FW_ASSERT(
        -: 1273:          _status == Fw::FW_SERIALIZE_OK,
        -: 1274:          static_cast<AssertArg>(_status)
        -: 1275:      );
        -: 1276:#endif
        -: 1277:
       20: 1278:      entry.setMaxSerialize(40);
       20: 1279:      _status = _logBuff.serialize(entry);
        -: 1280:      FW_ASSERT(
        -: 1281:          _status == Fw::FW_SERIALIZE_OK,
        -: 1282:          static_cast<AssertArg>(_status)
       20: 1283:      );
        -: 1284:
        -: 1285:
       20: 1286:      this->m_Log_OutputPort[0].invoke(
        -: 1287:          _id,
        -: 1288:          _logTime,Fw::LOG_FATAL,
        -: 1289:          _logBuff
       20: 1290:      );
        -: 1291:
        -: 1292:    }
        -: 1293:
        -: 1294:    // Emit the event on the text log port
        -: 1295:#if FW_ENABLE_TEXT_LOGGING
       20: 1296:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1297:
        -: 1298:#if FW_OBJECT_NAMES == 1
        -: 1299:      const char* _formatString =
       20: 1300:        "(%s) %s: Ping entry %s did not respond";
        -: 1301:#else
        -: 1302:      const char* _formatString =
        -: 1303:        "%s: Ping entry %s did not respond";
        -: 1304:#endif
        -: 1305:
        -: 1306:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1307:
       20: 1308:      (void) snprintf(
        -: 1309:          _textBuffer,
        -: 1310:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1311:          _formatString,
        -: 1312:#if FW_OBJECT_NAMES == 1
        -: 1313:          this->m_objName,
        -: 1314:#endif
        -: 1315:          "HLTH_PING_LATE "
       20: 1316:        , entry.toChar()
       20: 1317:      );
        -: 1318:
        -: 1319:      // Null terminate
       20: 1320:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       40: 1321:      Fw::TextLogString _logString = _textBuffer;
       20: 1322:      this->m_LogText_OutputPort[0].invoke(
        -: 1323:          _id,
        -: 1324:          _logTime,Fw::TEXT_LOG_FATAL,
        -: 1325:          _logString
       20: 1326:      );
        -: 1327:
        -: 1328:    }
        -: 1329:#endif
        -: 1330:
       20: 1331:  }
        -: 1332:  
        -: 1333:
       10: 1334:  void HealthComponentBase ::
        -: 1335:    log_FATAL_HLTH_PING_WRONG_KEY(
        -: 1336:        Fw::LogStringArg& entry, U32 badKey
        -: 1337:    )
        -: 1338:  {
        -: 1339:  
        -: 1340:
        -: 1341:    // Get the time
       20: 1342:    Fw::Time _logTime;
       10: 1343:    if (this->m_Time_OutputPort[0].isConnected()) {
       10: 1344:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1345:    }
        -: 1346:    
       10: 1347:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1348:    
       10: 1349:    _id = this->getIdBase() + EVENTID_HLTH_PING_WRONG_KEY;
        -: 1350:
        -: 1351:    // Emit the event on the log port
       10: 1352:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1353:
       20: 1354:      Fw::LogBuffer _logBuff;
       10: 1355:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1356:
        -: 1357:#if FW_AMPCS_COMPATIBLE
        -: 1358:      // Serialize the number of arguments
        -: 1359:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1360:      FW_ASSERT(
        -: 1361:          _status == Fw::FW_SERIALIZE_OK,
        -: 1362:          static_cast<AssertArg>(_status)
        -: 1363:      );
        -: 1364:#endif
        -: 1365:
       10: 1366:      entry.setMaxSerialize(40);
       10: 1367:      _status = _logBuff.serialize(entry);
        -: 1368:      FW_ASSERT(
        -: 1369:          _status == Fw::FW_SERIALIZE_OK,
        -: 1370:          static_cast<AssertArg>(_status)
       10: 1371:      );
        -: 1372:
        -: 1373:#if FW_AMPCS_COMPATIBLE
        -: 1374:      // Serialize the argument size
        -: 1375:      _status = _logBuff.serialize(
        -: 1376:          static_cast<U8>(sizeof(badKey))
        -: 1377:      );
        -: 1378:      FW_ASSERT(
        -: 1379:          _status == Fw::FW_SERIALIZE_OK,
        -: 1380:          static_cast<AssertArg>(_status)
        -: 1381:      );
        -: 1382:#endif
        -: 1383:
       10: 1384:      _status = _logBuff.serialize(badKey);
        -: 1385:      FW_ASSERT(
        -: 1386:          _status == Fw::FW_SERIALIZE_OK,
        -: 1387:          static_cast<AssertArg>(_status)
       10: 1388:      );
        -: 1389:
        -: 1390:
       10: 1391:      this->m_Log_OutputPort[0].invoke(
        -: 1392:          _id,
        -: 1393:          _logTime,Fw::LOG_FATAL,
        -: 1394:          _logBuff
       10: 1395:      );
        -: 1396:
        -: 1397:    }
        -: 1398:
        -: 1399:    // Emit the event on the text log port
        -: 1400:#if FW_ENABLE_TEXT_LOGGING
       10: 1401:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1402:
        -: 1403:#if FW_OBJECT_NAMES == 1
        -: 1404:      const char* _formatString =
       10: 1405:        "(%s) %s: Ping entry %s responded with wrong key 0x%08X";
        -: 1406:#else
        -: 1407:      const char* _formatString =
        -: 1408:        "%s: Ping entry %s responded with wrong key 0x%08X";
        -: 1409:#endif
        -: 1410:
        -: 1411:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1412:
       10: 1413:      (void) snprintf(
        -: 1414:          _textBuffer,
        -: 1415:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1416:          _formatString,
        -: 1417:#if FW_OBJECT_NAMES == 1
        -: 1418:          this->m_objName,
        -: 1419:#endif
        -: 1420:          "HLTH_PING_WRONG_KEY "
       10: 1421:        , entry.toChar()
        -: 1422:        , badKey
       10: 1423:      );
        -: 1424:
        -: 1425:      // Null terminate
       10: 1426:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       20: 1427:      Fw::TextLogString _logString = _textBuffer;
       10: 1428:      this->m_LogText_OutputPort[0].invoke(
        -: 1429:          _id,
        -: 1430:          _logTime,Fw::TEXT_LOG_FATAL,
        -: 1431:          _logString
       10: 1432:      );
        -: 1433:
        -: 1434:    }
        -: 1435:#endif
        -: 1436:
       10: 1437:  }
        -: 1438:  
        -: 1439:
        5: 1440:  void HealthComponentBase ::
        -: 1441:    log_ACTIVITY_HI_HLTH_CHECK_ENABLE(
        -: 1442:        HealthIsEnabled enabled
        -: 1443:    )
        -: 1444:  {
        -: 1445:  
        -: 1446:
        -: 1447:    // Get the time
       10: 1448:    Fw::Time _logTime;
        5: 1449:    if (this->m_Time_OutputPort[0].isConnected()) {
        5: 1450:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1451:    }
        -: 1452:    
        5: 1453:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1454:    
        5: 1455:    _id = this->getIdBase() + EVENTID_HLTH_CHECK_ENABLE;
        -: 1456:
        -: 1457:    // Emit the event on the log port
        5: 1458:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1459:
       10: 1460:      Fw::LogBuffer _logBuff;
        5: 1461:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1462:
        -: 1463:#if FW_AMPCS_COMPATIBLE
        -: 1464:      // Serialize the number of arguments
        -: 1465:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1466:      FW_ASSERT(
        -: 1467:          _status == Fw::FW_SERIALIZE_OK,
        -: 1468:          static_cast<AssertArg>(_status)
        -: 1469:      );
        -: 1470:#endif
        -: 1471:
        -: 1472:#if FW_AMPCS_COMPATIBLE
        -: 1473:      // Serialize the argument size
        -: 1474:      _status = _logBuff.serialize(static_cast<U8>(sizeof(FwEnumStoreType)));
        -: 1475:      FW_ASSERT(
        -: 1476:          _status == Fw::FW_SERIALIZE_OK,
        -: 1477:          static_cast<AssertArg>(_status)
        -: 1478:      );
        -: 1479:#endif
        -: 1480:
        5: 1481:      _status = _logBuff.serialize(
        -: 1482:          static_cast<FwEnumStoreType>(enabled)
        5: 1483:      );
        -: 1484:      FW_ASSERT(
        -: 1485:          _status == Fw::FW_SERIALIZE_OK,
        -: 1486:          static_cast<AssertArg>(_status)
        5: 1487:      );
        -: 1488:
        -: 1489:
        5: 1490:      this->m_Log_OutputPort[0].invoke(
        -: 1491:          _id,
        -: 1492:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1493:          _logBuff
        5: 1494:      );
        -: 1495:
        -: 1496:    }
        -: 1497:
        -: 1498:    // Emit the event on the text log port
        -: 1499:#if FW_ENABLE_TEXT_LOGGING
        5: 1500:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1501:
        -: 1502:#if FW_OBJECT_NAMES == 1
        -: 1503:      const char* _formatString =
        5: 1504:        "(%s) %s: Health checking set to %d";
        -: 1505:#else
        -: 1506:      const char* _formatString =
        -: 1507:        "%s: Health checking set to %d";
        -: 1508:#endif
        -: 1509:
        -: 1510:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1511:
        5: 1512:      (void) snprintf(
        -: 1513:          _textBuffer,
        -: 1514:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1515:          _formatString,
        -: 1516:#if FW_OBJECT_NAMES == 1
        -: 1517:          this->m_objName,
        -: 1518:#endif
        -: 1519:          "HLTH_CHECK_ENABLE "
        -: 1520:        , enabled
        5: 1521:      );
        -: 1522:
        -: 1523:      // Null terminate
        5: 1524:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       10: 1525:      Fw::TextLogString _logString = _textBuffer;
        5: 1526:      this->m_LogText_OutputPort[0].invoke(
        -: 1527:          _id,
        -: 1528:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1529:          _logString
        5: 1530:      );
        -: 1531:
        -: 1532:    }
        -: 1533:#endif
        -: 1534:
        5: 1535:  }
        -: 1536:  
        -: 1537:
       21: 1538:  void HealthComponentBase ::
        -: 1539:    log_ACTIVITY_HI_HLTH_CHECK_PING(
        -: 1540:        HealthPingIsEnabled enabled, Fw::LogStringArg& entry
        -: 1541:    )
        -: 1542:  {
        -: 1543:  
        -: 1544:
        -: 1545:    // Get the time
       42: 1546:    Fw::Time _logTime;
       21: 1547:    if (this->m_Time_OutputPort[0].isConnected()) {
       21: 1548:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1549:    }
        -: 1550:    
       21: 1551:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1552:    
       21: 1553:    _id = this->getIdBase() + EVENTID_HLTH_CHECK_PING;
        -: 1554:
        -: 1555:    // Emit the event on the log port
       21: 1556:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1557:
       42: 1558:      Fw::LogBuffer _logBuff;
       21: 1559:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1560:
        -: 1561:#if FW_AMPCS_COMPATIBLE
        -: 1562:      // Serialize the number of arguments
        -: 1563:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1564:      FW_ASSERT(
        -: 1565:          _status == Fw::FW_SERIALIZE_OK,
        -: 1566:          static_cast<AssertArg>(_status)
        -: 1567:      );
        -: 1568:#endif
        -: 1569:
        -: 1570:#if FW_AMPCS_COMPATIBLE
        -: 1571:      // Serialize the argument size
        -: 1572:      _status = _logBuff.serialize(static_cast<U8>(sizeof(FwEnumStoreType)));
        -: 1573:      FW_ASSERT(
        -: 1574:          _status == Fw::FW_SERIALIZE_OK,
        -: 1575:          static_cast<AssertArg>(_status)
        -: 1576:      );
        -: 1577:#endif
        -: 1578:
       21: 1579:      _status = _logBuff.serialize(
        -: 1580:          static_cast<FwEnumStoreType>(enabled)
       21: 1581:      );
        -: 1582:      FW_ASSERT(
        -: 1583:          _status == Fw::FW_SERIALIZE_OK,
        -: 1584:          static_cast<AssertArg>(_status)
       21: 1585:      );
        -: 1586:
       21: 1587:      entry.setMaxSerialize(40);
       21: 1588:      _status = _logBuff.serialize(entry);
        -: 1589:      FW_ASSERT(
        -: 1590:          _status == Fw::FW_SERIALIZE_OK,
        -: 1591:          static_cast<AssertArg>(_status)
       21: 1592:      );
        -: 1593:
        -: 1594:
       21: 1595:      this->m_Log_OutputPort[0].invoke(
        -: 1596:          _id,
        -: 1597:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1598:          _logBuff
       21: 1599:      );
        -: 1600:
        -: 1601:    }
        -: 1602:
        -: 1603:    // Emit the event on the text log port
        -: 1604:#if FW_ENABLE_TEXT_LOGGING
       21: 1605:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1606:
        -: 1607:#if FW_OBJECT_NAMES == 1
        -: 1608:      const char* _formatString =
       21: 1609:        "(%s) %s: Health checking set to %d for %s";
        -: 1610:#else
        -: 1611:      const char* _formatString =
        -: 1612:        "%s: Health checking set to %d for %s";
        -: 1613:#endif
        -: 1614:
        -: 1615:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1616:
       21: 1617:      (void) snprintf(
        -: 1618:          _textBuffer,
        -: 1619:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1620:          _formatString,
        -: 1621:#if FW_OBJECT_NAMES == 1
        -: 1622:          this->m_objName,
        -: 1623:#endif
        -: 1624:          "HLTH_CHECK_PING "
        -: 1625:        , enabled
       21: 1626:        , entry.toChar()
       21: 1627:      );
        -: 1628:
        -: 1629:      // Null terminate
       21: 1630:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       42: 1631:      Fw::TextLogString _logString = _textBuffer;
       21: 1632:      this->m_LogText_OutputPort[0].invoke(
        -: 1633:          _id,
        -: 1634:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1635:          _logString
       21: 1636:      );
        -: 1637:
        -: 1638:    }
        -: 1639:#endif
        -: 1640:
       21: 1641:  }
        -: 1642:  
        -: 1643:
        2: 1644:  void HealthComponentBase ::
        -: 1645:    log_WARNING_LO_HLTH_CHECK_LOOKUP_ERROR(
        -: 1646:        Fw::LogStringArg& entry
        -: 1647:    )
        -: 1648:  {
        -: 1649:  
        -: 1650:
        -: 1651:    // Get the time
        4: 1652:    Fw::Time _logTime;
        2: 1653:    if (this->m_Time_OutputPort[0].isConnected()) {
        2: 1654:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1655:    }
        -: 1656:    
        2: 1657:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1658:    
        2: 1659:    _id = this->getIdBase() + EVENTID_HLTH_CHECK_LOOKUP_ERROR;
        -: 1660:
        -: 1661:    // Emit the event on the log port
        2: 1662:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1663:
        4: 1664:      Fw::LogBuffer _logBuff;
        2: 1665:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1666:
        -: 1667:#if FW_AMPCS_COMPATIBLE
        -: 1668:      // Serialize the number of arguments
        -: 1669:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1670:      FW_ASSERT(
        -: 1671:          _status == Fw::FW_SERIALIZE_OK,
        -: 1672:          static_cast<AssertArg>(_status)
        -: 1673:      );
        -: 1674:#endif
        -: 1675:
        2: 1676:      entry.setMaxSerialize(40);
        2: 1677:      _status = _logBuff.serialize(entry);
        -: 1678:      FW_ASSERT(
        -: 1679:          _status == Fw::FW_SERIALIZE_OK,
        -: 1680:          static_cast<AssertArg>(_status)
        2: 1681:      );
        -: 1682:
        -: 1683:
        2: 1684:      this->m_Log_OutputPort[0].invoke(
        -: 1685:          _id,
        -: 1686:          _logTime,Fw::LOG_WARNING_LO,
        -: 1687:          _logBuff
        2: 1688:      );
        -: 1689:
        -: 1690:    }
        -: 1691:
        -: 1692:    // Emit the event on the text log port
        -: 1693:#if FW_ENABLE_TEXT_LOGGING
        2: 1694:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1695:
        -: 1696:#if FW_OBJECT_NAMES == 1
        -: 1697:      const char* _formatString =
        2: 1698:        "(%s) %s: Couldn't find entry %s";
        -: 1699:#else
        -: 1700:      const char* _formatString =
        -: 1701:        "%s: Couldn't find entry %s";
        -: 1702:#endif
        -: 1703:
        -: 1704:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1705:
        2: 1706:      (void) snprintf(
        -: 1707:          _textBuffer,
        -: 1708:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1709:          _formatString,
        -: 1710:#if FW_OBJECT_NAMES == 1
        -: 1711:          this->m_objName,
        -: 1712:#endif
        -: 1713:          "HLTH_CHECK_LOOKUP_ERROR "
        2: 1714:        , entry.toChar()
        2: 1715:      );
        -: 1716:
        -: 1717:      // Null terminate
        2: 1718:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        4: 1719:      Fw::TextLogString _logString = _textBuffer;
        2: 1720:      this->m_LogText_OutputPort[0].invoke(
        -: 1721:          _id,
        -: 1722:          _logTime,Fw::TEXT_LOG_WARNING_LO,
        -: 1723:          _logString
        2: 1724:      );
        -: 1725:
        -: 1726:    }
        -: 1727:#endif
        -: 1728:
        2: 1729:  }
        -: 1730:  
        -: 1731:
       11: 1732:  void HealthComponentBase ::
        -: 1733:    log_ACTIVITY_HI_HLTH_PING_UPDATED(
        -: 1734:        Fw::LogStringArg& entry, U32 warn, U32 fatal
        -: 1735:    )
        -: 1736:  {
        -: 1737:  
        -: 1738:
        -: 1739:    // Get the time
       22: 1740:    Fw::Time _logTime;
       11: 1741:    if (this->m_Time_OutputPort[0].isConnected()) {
       11: 1742:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1743:    }
        -: 1744:    
       11: 1745:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1746:    
       11: 1747:    _id = this->getIdBase() + EVENTID_HLTH_PING_UPDATED;
        -: 1748:
        -: 1749:    // Emit the event on the log port
       11: 1750:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1751:
       22: 1752:      Fw::LogBuffer _logBuff;
       11: 1753:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1754:
        -: 1755:#if FW_AMPCS_COMPATIBLE
        -: 1756:      // Serialize the number of arguments
        -: 1757:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 1758:      FW_ASSERT(
        -: 1759:          _status == Fw::FW_SERIALIZE_OK,
        -: 1760:          static_cast<AssertArg>(_status)
        -: 1761:      );
        -: 1762:#endif
        -: 1763:
       11: 1764:      entry.setMaxSerialize(40);
       11: 1765:      _status = _logBuff.serialize(entry);
        -: 1766:      FW_ASSERT(
        -: 1767:          _status == Fw::FW_SERIALIZE_OK,
        -: 1768:          static_cast<AssertArg>(_status)
       11: 1769:      );
        -: 1770:
        -: 1771:#if FW_AMPCS_COMPATIBLE
        -: 1772:      // Serialize the argument size
        -: 1773:      _status = _logBuff.serialize(
        -: 1774:          static_cast<U8>(sizeof(warn))
        -: 1775:      );
        -: 1776:      FW_ASSERT(
        -: 1777:          _status == Fw::FW_SERIALIZE_OK,
        -: 1778:          static_cast<AssertArg>(_status)
        -: 1779:      );
        -: 1780:#endif
        -: 1781:
       11: 1782:      _status = _logBuff.serialize(warn);
        -: 1783:      FW_ASSERT(
        -: 1784:          _status == Fw::FW_SERIALIZE_OK,
        -: 1785:          static_cast<AssertArg>(_status)
       11: 1786:      );
        -: 1787:
        -: 1788:#if FW_AMPCS_COMPATIBLE
        -: 1789:      // Serialize the argument size
        -: 1790:      _status = _logBuff.serialize(
        -: 1791:          static_cast<U8>(sizeof(fatal))
        -: 1792:      );
        -: 1793:      FW_ASSERT(
        -: 1794:          _status == Fw::FW_SERIALIZE_OK,
        -: 1795:          static_cast<AssertArg>(_status)
        -: 1796:      );
        -: 1797:#endif
        -: 1798:
       11: 1799:      _status = _logBuff.serialize(fatal);
        -: 1800:      FW_ASSERT(
        -: 1801:          _status == Fw::FW_SERIALIZE_OK,
        -: 1802:          static_cast<AssertArg>(_status)
       11: 1803:      );
        -: 1804:
        -: 1805:
       11: 1806:      this->m_Log_OutputPort[0].invoke(
        -: 1807:          _id,
        -: 1808:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1809:          _logBuff
       11: 1810:      );
        -: 1811:
        -: 1812:    }
        -: 1813:
        -: 1814:    // Emit the event on the text log port
        -: 1815:#if FW_ENABLE_TEXT_LOGGING
       11: 1816:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1817:
        -: 1818:#if FW_OBJECT_NAMES == 1
        -: 1819:      const char* _formatString =
       11: 1820:        "(%s) %s: Health ping for %s changed to WARN %d FATAL %d";
        -: 1821:#else
        -: 1822:      const char* _formatString =
        -: 1823:        "%s: Health ping for %s changed to WARN %d FATAL %d";
        -: 1824:#endif
        -: 1825:
        -: 1826:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1827:
       11: 1828:      (void) snprintf(
        -: 1829:          _textBuffer,
        -: 1830:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1831:          _formatString,
        -: 1832:#if FW_OBJECT_NAMES == 1
        -: 1833:          this->m_objName,
        -: 1834:#endif
        -: 1835:          "HLTH_PING_UPDATED "
       11: 1836:        , entry.toChar()
        -: 1837:        , warn
        -: 1838:        , fatal
       11: 1839:      );
        -: 1840:
        -: 1841:      // Null terminate
       11: 1842:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       22: 1843:      Fw::TextLogString _logString = _textBuffer;
       11: 1844:      this->m_LogText_OutputPort[0].invoke(
        -: 1845:          _id,
        -: 1846:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1847:          _logString
       11: 1848:      );
        -: 1849:
        -: 1850:    }
        -: 1851:#endif
        -: 1852:
       11: 1853:  }
        -: 1854:  
        -: 1855:
        1: 1856:  void HealthComponentBase ::
        -: 1857:    log_WARNING_HI_HLTH_PING_INVALID_VALUES(
        -: 1858:        Fw::LogStringArg& entry, U32 warn, U32 fatal
        -: 1859:    )
        -: 1860:  {
        -: 1861:  
        -: 1862:
        -: 1863:    // Get the time
        2: 1864:    Fw::Time _logTime;
        1: 1865:    if (this->m_Time_OutputPort[0].isConnected()) {
        1: 1866:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1867:    }
        -: 1868:    
        1: 1869:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1870:    
        1: 1871:    _id = this->getIdBase() + EVENTID_HLTH_PING_INVALID_VALUES;
        -: 1872:
        -: 1873:    // Emit the event on the log port
        1: 1874:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1875:
        2: 1876:      Fw::LogBuffer _logBuff;
        1: 1877:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1878:
        -: 1879:#if FW_AMPCS_COMPATIBLE
        -: 1880:      // Serialize the number of arguments
        -: 1881:      _status = _logBuff.serialize(static_cast<U8>(3));
        -: 1882:      FW_ASSERT(
        -: 1883:          _status == Fw::FW_SERIALIZE_OK,
        -: 1884:          static_cast<AssertArg>(_status)
        -: 1885:      );
        -: 1886:#endif
        -: 1887:
        1: 1888:      entry.setMaxSerialize(40);
        1: 1889:      _status = _logBuff.serialize(entry);
        -: 1890:      FW_ASSERT(
        -: 1891:          _status == Fw::FW_SERIALIZE_OK,
        -: 1892:          static_cast<AssertArg>(_status)
        1: 1893:      );
        -: 1894:
        -: 1895:#if FW_AMPCS_COMPATIBLE
        -: 1896:      // Serialize the argument size
        -: 1897:      _status = _logBuff.serialize(
        -: 1898:          static_cast<U8>(sizeof(warn))
        -: 1899:      );
        -: 1900:      FW_ASSERT(
        -: 1901:          _status == Fw::FW_SERIALIZE_OK,
        -: 1902:          static_cast<AssertArg>(_status)
        -: 1903:      );
        -: 1904:#endif
        -: 1905:
        1: 1906:      _status = _logBuff.serialize(warn);
        -: 1907:      FW_ASSERT(
        -: 1908:          _status == Fw::FW_SERIALIZE_OK,
        -: 1909:          static_cast<AssertArg>(_status)
        1: 1910:      );
        -: 1911:
        -: 1912:#if FW_AMPCS_COMPATIBLE
        -: 1913:      // Serialize the argument size
        -: 1914:      _status = _logBuff.serialize(
        -: 1915:          static_cast<U8>(sizeof(fatal))
        -: 1916:      );
        -: 1917:      FW_ASSERT(
        -: 1918:          _status == Fw::FW_SERIALIZE_OK,
        -: 1919:          static_cast<AssertArg>(_status)
        -: 1920:      );
        -: 1921:#endif
        -: 1922:
        1: 1923:      _status = _logBuff.serialize(fatal);
        -: 1924:      FW_ASSERT(
        -: 1925:          _status == Fw::FW_SERIALIZE_OK,
        -: 1926:          static_cast<AssertArg>(_status)
        1: 1927:      );
        -: 1928:
        -: 1929:
        1: 1930:      this->m_Log_OutputPort[0].invoke(
        -: 1931:          _id,
        -: 1932:          _logTime,Fw::LOG_WARNING_HI,
        -: 1933:          _logBuff
        1: 1934:      );
        -: 1935:
        -: 1936:    }
        -: 1937:
        -: 1938:    // Emit the event on the text log port
        -: 1939:#if FW_ENABLE_TEXT_LOGGING
        1: 1940:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1941:
        -: 1942:#if FW_OBJECT_NAMES == 1
        -: 1943:      const char* _formatString =
        1: 1944:        "(%s) %s: Health ping for %s invalid values: WARN %d FATAL %d";
        -: 1945:#else
        -: 1946:      const char* _formatString =
        -: 1947:        "%s: Health ping for %s invalid values: WARN %d FATAL %d";
        -: 1948:#endif
        -: 1949:
        -: 1950:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1951:
        1: 1952:      (void) snprintf(
        -: 1953:          _textBuffer,
        -: 1954:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1955:          _formatString,
        -: 1956:#if FW_OBJECT_NAMES == 1
        -: 1957:          this->m_objName,
        -: 1958:#endif
        -: 1959:          "HLTH_PING_INVALID_VALUES "
        1: 1960:        , entry.toChar()
        -: 1961:        , warn
        -: 1962:        , fatal
        1: 1963:      );
        -: 1964:
        -: 1965:      // Null terminate
        1: 1966:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        2: 1967:      Fw::TextLogString _logString = _textBuffer;
        1: 1968:      this->m_LogText_OutputPort[0].invoke(
        -: 1969:          _id,
        -: 1970:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1971:          _logString
        1: 1972:      );
        -: 1973:
        -: 1974:    }
        -: 1975:#endif
        -: 1976:
        1: 1977:  }
        -: 1978:  
        -: 1979:
        -: 1980:  // ----------------------------------------------------------------------
        -: 1981:  // Calls for invocations received on typed input ports
        -: 1982:  // ----------------------------------------------------------------------
        -: 1983:
      300: 1984:  void HealthComponentBase ::
        -: 1985:    m_p_PingReturn_in(
        -: 1986:        Fw::PassiveComponentBase* callComp,
        -: 1987:        NATIVE_INT_TYPE portNum,
        -: 1988:        U32 key
        -: 1989:    )
        -: 1990:  {
      300: 1991:    FW_ASSERT(callComp);
        -: 1992:    HealthComponentBase* compPtr =
      300: 1993:      (HealthComponentBase*) callComp;
      300: 1994:    compPtr->PingReturn_handlerBase(portNum, key);
      300: 1995:  }
        -: 1996:
      302: 1997:  void HealthComponentBase ::
        -: 1998:    m_p_Run_in(
        -: 1999:        Fw::PassiveComponentBase* callComp,
        -: 2000:        NATIVE_INT_TYPE portNum,
        -: 2001:        NATIVE_UINT_TYPE context
        -: 2002:    )
        -: 2003:  {
      302: 2004:    FW_ASSERT(callComp);
        -: 2005:    HealthComponentBase* compPtr =
      302: 2006:      (HealthComponentBase*) callComp;
      302: 2007:    compPtr->Run_handlerBase(portNum, context);
      302: 2008:  }
        -: 2009:
        -: 2010:  // ----------------------------------------------------------------------
        -: 2011:  // Port handler base-class functions for typed input ports
        -: 2012:  // ----------------------------------------------------------------------
        -: 2013:
      300: 2014:  void HealthComponentBase ::
        -: 2015:    PingReturn_handlerBase(
        -: 2016:        NATIVE_INT_TYPE portNum,
        -: 2017:        U32 key
        -: 2018:    )
        -: 2019:  {
        -: 2020:
        -: 2021:    // Make sure port number is valid
      300: 2022:    FW_ASSERT(portNum < this->getNum_PingReturn_InputPorts(),static_cast<AssertArg>(portNum));
        -: 2023:
        -: 2024:    // Call pre-message hook
        -: 2025:    PingReturn_preMsgHook(
        -: 2026:        portNum,
        -: 2027:        key
      300: 2028:    );
        -: 2029:
      600: 2030:    ComponentIpcSerializableBuffer msg;
      300: 2031:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 2032:
        -: 2033:    _status = msg.serialize(
        -: 2034:        static_cast<NATIVE_INT_TYPE>(PINGRETURN_PING)
      300: 2035:    );
        -: 2036:    FW_ASSERT (
        -: 2037:        _status == Fw::FW_SERIALIZE_OK,
        -: 2038:        static_cast<AssertArg>(_status)
      300: 2039:    );
        -: 2040:
      300: 2041:    _status = msg.serialize(portNum);
        -: 2042:    FW_ASSERT (
        -: 2043:        _status == Fw::FW_SERIALIZE_OK,
        -: 2044:        static_cast<AssertArg>(_status)
      300: 2045:    );
        -: 2046:
        -: 2047:    // Serialize argument key
      300: 2048:    _status = msg.serialize(key);
        -: 2049:    FW_ASSERT(
        -: 2050:        _status == Fw::FW_SERIALIZE_OK,
        -: 2051:        static_cast<AssertArg>(_status)
      300: 2052:    );
        -: 2053:
        -: 2054:      
        -: 2055:    // send message
        -: 2056:    Os::Queue::QueueBlocking _block = 
      300: 2057:      Os::Queue::QUEUE_NONBLOCKING;
        -: 2058:    Os::Queue::QueueStatus qStatus =
      300: 2059:      this->m_queue.send(msg, 0,_block);
        -: 2060:    FW_ASSERT(
        -: 2061:        qStatus == Os::Queue::QUEUE_OK,
        -: 2062:        static_cast<AssertArg>(qStatus)
      300: 2063:    );      
        -: 2064:      
      300: 2065:  }
        -: 2066:
      302: 2067:  void HealthComponentBase ::
        -: 2068:    Run_handlerBase(
        -: 2069:        NATIVE_INT_TYPE portNum,
        -: 2070:        NATIVE_UINT_TYPE context
        -: 2071:    )
        -: 2072:  {
        -: 2073:
        -: 2074:    // Make sure port number is valid
      302: 2075:    FW_ASSERT(portNum < this->getNum_Run_InputPorts(),static_cast<AssertArg>(portNum));
        -: 2076:
        -: 2077:    // Down call to pure virtual handler method implemented in Impl class
      302: 2078:    this->Run_handler(portNum, context);
        -: 2079:
      302: 2080:  }
        -: 2081:
        -: 2082:  // ----------------------------------------------------------------------
        -: 2083:  // Pre-message hooks for async input ports
        -: 2084:  // ----------------------------------------------------------------------
        -: 2085:
      300: 2086:  void HealthComponentBase ::
        -: 2087:    PingReturn_preMsgHook(
        -: 2088:        NATIVE_INT_TYPE portNum,
        -: 2089:        U32 key
        -: 2090:    )
        -: 2091:  {
        -: 2092:    // Default: no-op
      300: 2093:  }
        -: 2094:
        -: 2095:  // ----------------------------------------------------------------------
        -: 2096:  // Message dispatch method for active and queued components. Called
        -: 2097:  // by active component thread or implementation code for queued components
        -: 2098:  // ----------------------------------------------------------------------
        -: 2099:
      666: 2100:  Fw::QueuedComponentBase::MsgDispatchStatus HealthComponentBase ::
        -: 2101:    doDispatch(void)
        -: 2102:  {
     1332: 2103:    ComponentIpcSerializableBuffer msg;
        -: 2104:    NATIVE_INT_TYPE priority;
        -: 2105:
      666: 2106:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_NONBLOCKING);
      666: 2107:    if (Os::Queue::QUEUE_NO_MORE_MSGS == msgStatus) {
      344: 2108:      return Fw::QueuedComponentBase::MSG_DISPATCH_EMPTY;
        -: 2109:    } else {
        -: 2110:      FW_ASSERT(
        -: 2111:          msgStatus == Os::Queue::QUEUE_OK,
        -: 2112:          static_cast<AssertArg>(msgStatus)
      322: 2113:      );
        -: 2114:    }
        -: 2115:
        -: 2116:    // Reset to beginning of buffer
      322: 2117:    msg.resetDeser();
        -: 2118:
        -: 2119:    NATIVE_INT_TYPE desMsg;
      322: 2120:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
        -: 2121:    FW_ASSERT(
        -: 2122:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2123:        static_cast<AssertArg>(deserStatus)
      322: 2124:    );
        -: 2125:
      322: 2126:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -: 2127:
      322: 2128:    if (msgType == HEALTH_COMPONENT_EXIT) {
    #####: 2129:      return MSG_DISPATCH_EXIT;
        -: 2130:    }
        -: 2131:
        -: 2132:    NATIVE_INT_TYPE portNum;
      322: 2133:    deserStatus = msg.deserialize(portNum);
        -: 2134:    FW_ASSERT(
        -: 2135:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2136:        static_cast<AssertArg>(deserStatus)
      322: 2137:    );
        -: 2138:
      322: 2139:    switch (msgType) {
        -: 2140:
        -: 2141:      // Handle async input port PingReturn
        -: 2142:      case PINGRETURN_PING: {
        -: 2143:
        -: 2144:        // Deserialize argument key
        -: 2145:        U32 key;
      281: 2146:        deserStatus = msg.deserialize(key);
        -: 2147:        FW_ASSERT(
        -: 2148:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2149:            static_cast<AssertArg>(deserStatus)
      281: 2150:        );
        -: 2151:
        -: 2152:        // Call handler function
        -: 2153:        this->PingReturn_handler(
        -: 2154:            portNum,
        -: 2155:            key
      281: 2156:        );
        -: 2157:
      281: 2158:        break;
        -: 2159:
        -: 2160:      }
        -: 2161:
        -: 2162:      // Handle command HLTH_ENABLE
        -: 2163:      case CMD_HLTH_ENABLE: {
        -: 2164:        // Deserialize opcode
        -: 2165:        FwOpcodeType opCode;
        5: 2166:        deserStatus = msg.deserialize(opCode);
        -: 2167:        FW_ASSERT (
        -: 2168:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2169:            static_cast<AssertArg>(deserStatus)
        5: 2170:        );
        -: 2171:
        -: 2172:        // Deserialize command sequence
        -: 2173:        U32 cmdSeq;
        5: 2174:        deserStatus = msg.deserialize(cmdSeq);
        -: 2175:        FW_ASSERT (
        -: 2176:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2177:            static_cast<AssertArg>(deserStatus)
        5: 2178:        );
        -: 2179:
        -: 2180:        // Deserialize command argument buffer
       10: 2181:        Fw::CmdArgBuffer args;
        5: 2182:        deserStatus = msg.deserialize(args);
        -: 2183:        FW_ASSERT (
        -: 2184:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2185:            static_cast<AssertArg>(deserStatus)
        5: 2186:        );
        -: 2187:
        -: 2188:        // Reset buffer
        5: 2189:        args.resetDeser();
        -: 2190:
        -: 2191:        // Deserialize argument enable
        -: 2192:        HealthEnabled enable;
        -: 2193:        FwEnumStoreType enableInt;
        5: 2194:        deserStatus = args.deserialize(enableInt);
        5: 2195:        enable = (HealthEnabled)enableInt;
        5: 2196:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2197:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2198:            this->cmdResponse_out(
        -: 2199:                opCode,
        -: 2200:                cmdSeq,
        -: 2201:                Fw::COMMAND_FORMAT_ERROR
    #####: 2202:            );
        -: 2203:          }
        -: 2204:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2205:          break;
        -: 2206:        }
        -: 2207:
        -: 2208:        // Make sure there was no data left over.
        -: 2209:        // That means the argument buffer size was incorrect.
        -: 2210:#if FW_CMD_CHECK_RESIDUAL        
        5: 2211:        if (args.getBuffLeft() != 0) {
    #####: 2212:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2213:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2214:          }
        -: 2215:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2216:          break;
        -: 2217:        }
        -: 2218:#endif
        -: 2219:        // Call handler function
        -: 2220:        this->HLTH_ENABLE_cmdHandler(
        -: 2221:            opCode,
        -: 2222:            cmdSeq,
        -: 2223:            enable
        5: 2224:        );
        -: 2225:
        5: 2226:        break;
        -: 2227:
        -: 2228:      }
        -: 2229:
        -: 2230:      // Handle command HLTH_PING_ENABLE
        -: 2231:      case CMD_HLTH_PING_ENABLE: {
        -: 2232:        // Deserialize opcode
        -: 2233:        FwOpcodeType opCode;
       23: 2234:        deserStatus = msg.deserialize(opCode);
        -: 2235:        FW_ASSERT (
        -: 2236:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2237:            static_cast<AssertArg>(deserStatus)
       23: 2238:        );
        -: 2239:
        -: 2240:        // Deserialize command sequence
        -: 2241:        U32 cmdSeq;
       23: 2242:        deserStatus = msg.deserialize(cmdSeq);
        -: 2243:        FW_ASSERT (
        -: 2244:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2245:            static_cast<AssertArg>(deserStatus)
       23: 2246:        );
        -: 2247:
        -: 2248:        // Deserialize command argument buffer
       46: 2249:        Fw::CmdArgBuffer args;
       23: 2250:        deserStatus = msg.deserialize(args);
        -: 2251:        FW_ASSERT (
        -: 2252:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2253:            static_cast<AssertArg>(deserStatus)
       23: 2254:        );
        -: 2255:
        -: 2256:        // Reset buffer
       23: 2257:        args.resetDeser();
        -: 2258:
        -: 2259:        // Deserialize argument entry
       46: 2260:        Fw::CmdStringArg entry;
       23: 2261:        deserStatus = args.deserialize(entry);
       23: 2262:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2263:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2264:            this->cmdResponse_out(
        -: 2265:                opCode,
        -: 2266:                cmdSeq,
        -: 2267:                Fw::COMMAND_FORMAT_ERROR
    #####: 2268:            );
        -: 2269:          }
        -: 2270:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2271:          break;
        -: 2272:        }
        -: 2273:
        -: 2274:        // Deserialize argument enable
        -: 2275:        PingEnabled enable;
        -: 2276:        FwEnumStoreType enableInt;
       23: 2277:        deserStatus = args.deserialize(enableInt);
       23: 2278:        enable = (PingEnabled)enableInt;
       23: 2279:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2280:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2281:            this->cmdResponse_out(
        -: 2282:                opCode,
        -: 2283:                cmdSeq,
        -: 2284:                Fw::COMMAND_FORMAT_ERROR
    #####: 2285:            );
        -: 2286:          }
        -: 2287:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2288:          break;
        -: 2289:        }
        -: 2290:
        -: 2291:        // Make sure there was no data left over.
        -: 2292:        // That means the argument buffer size was incorrect.
        -: 2293:#if FW_CMD_CHECK_RESIDUAL        
       23: 2294:        if (args.getBuffLeft() != 0) {
    #####: 2295:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2296:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2297:          }
        -: 2298:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2299:          break;
        -: 2300:        }
        -: 2301:#endif
        -: 2302:        // Call handler function
        -: 2303:        this->HLTH_PING_ENABLE_cmdHandler(
        -: 2304:            opCode,
        -: 2305:            cmdSeq,
        -: 2306:            entry, enable
       23: 2307:        );
        -: 2308:
       23: 2309:        break;
        -: 2310:
        -: 2311:      }
        -: 2312:
        -: 2313:      // Handle command HLTH_CHNG_PING
        -: 2314:      case CMD_HLTH_CHNG_PING: {
        -: 2315:        // Deserialize opcode
        -: 2316:        FwOpcodeType opCode;
       13: 2317:        deserStatus = msg.deserialize(opCode);
        -: 2318:        FW_ASSERT (
        -: 2319:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2320:            static_cast<AssertArg>(deserStatus)
       13: 2321:        );
        -: 2322:
        -: 2323:        // Deserialize command sequence
        -: 2324:        U32 cmdSeq;
       13: 2325:        deserStatus = msg.deserialize(cmdSeq);
        -: 2326:        FW_ASSERT (
        -: 2327:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2328:            static_cast<AssertArg>(deserStatus)
       13: 2329:        );
        -: 2330:
        -: 2331:        // Deserialize command argument buffer
       26: 2332:        Fw::CmdArgBuffer args;
       13: 2333:        deserStatus = msg.deserialize(args);
        -: 2334:        FW_ASSERT (
        -: 2335:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2336:            static_cast<AssertArg>(deserStatus)
       13: 2337:        );
        -: 2338:
        -: 2339:        // Reset buffer
       13: 2340:        args.resetDeser();
        -: 2341:
        -: 2342:        // Deserialize argument entry
       26: 2343:        Fw::CmdStringArg entry;
       13: 2344:        deserStatus = args.deserialize(entry);
       13: 2345:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2346:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2347:            this->cmdResponse_out(
        -: 2348:                opCode,
        -: 2349:                cmdSeq,
        -: 2350:                Fw::COMMAND_FORMAT_ERROR
    #####: 2351:            );
        -: 2352:          }
        -: 2353:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2354:          break;
        -: 2355:        }
        -: 2356:
        -: 2357:        // Deserialize argument warningValue
        -: 2358:        U32 warningValue;
       13: 2359:        deserStatus = args.deserialize(warningValue);
       13: 2360:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2361:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2362:            this->cmdResponse_out(
        -: 2363:                opCode,
        -: 2364:                cmdSeq,
        -: 2365:                Fw::COMMAND_FORMAT_ERROR
    #####: 2366:            );
        -: 2367:          }
        -: 2368:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2369:          break;
        -: 2370:        }
        -: 2371:
        -: 2372:        // Deserialize argument fatalValue
        -: 2373:        U32 fatalValue;
       13: 2374:        deserStatus = args.deserialize(fatalValue);
       13: 2375:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2376:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
        -: 2377:            this->cmdResponse_out(
        -: 2378:                opCode,
        -: 2379:                cmdSeq,
        -: 2380:                Fw::COMMAND_FORMAT_ERROR
    #####: 2381:            );
        -: 2382:          }
        -: 2383:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2384:          break;
        -: 2385:        }
        -: 2386:
        -: 2387:        // Make sure there was no data left over.
        -: 2388:        // That means the argument buffer size was incorrect.
        -: 2389:#if FW_CMD_CHECK_RESIDUAL        
       13: 2390:        if (args.getBuffLeft() != 0) {
    #####: 2391:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2392:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2393:          }
        -: 2394:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2395:          break;
        -: 2396:        }
        -: 2397:#endif
        -: 2398:        // Call handler function
        -: 2399:        this->HLTH_CHNG_PING_cmdHandler(
        -: 2400:            opCode,
        -: 2401:            cmdSeq,
        -: 2402:            entry, warningValue, fatalValue
       13: 2403:        );
        -: 2404:
       13: 2405:        break;
        -: 2406:
        -: 2407:      }
        -: 2408:
        -: 2409:      default:
    #####: 2410:        return MSG_DISPATCH_ERROR;
        -: 2411:
        -: 2412:    }
        -: 2413:
      322: 2414:    return MSG_DISPATCH_OK;
        -: 2415:
        -: 2416:  }
        -: 2417:
        3: 2418:} // end namespace Svc
