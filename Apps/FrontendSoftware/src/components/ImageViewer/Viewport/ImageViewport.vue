<!--
Displays the selected image at a large scale for navigation and allows for
editing via preset filters.

Author: Connor Colombo, CMU
Created: 3/05/2019
Last Updated: 08/30/2020, Colombo

TODO:
  - Better Denoise
  - Toggles on whether an adjustment is active
-->

<template>
  <div class="image-viewport">
    <img
      v-show="false"
      id="imgsrc"
      class="port"
      :src="imageSource"
      alt="IMAGE NOT FOUND"
      @load="onImageUpdate"
    >
    <div id="portContainer">
      <canvas
        id="imgvp"
        :key="imageSource"
        class="port"
        style="z-index: 0"
      >
        Oops! Something went wrong and really weird. Somehow Electron doesn't support HTML5 Canvas now. What did you do?
      </canvas>
      <canvas
        id="featurevp"
        class="port"
        style="z-index: 1;"
      />

      <transition name="overlay">
        <img
          v-if="radialGrid"
          class="port port_overlay"
          src="~@/assets/polar_grid10.png"
        >
      </transition>
      <transition name="overlay">
        <img
          v-if="cartesianGrid"
          class="port port_overlay"
          src="~@/assets/cartesian_grid.png"
        >
      </transition>
    </div>
  </div>
</template>

<script>
import { screen } from '@electron/remote';
import { mapState, mapGetters } from 'vuex';
import { sha256 } from 'js-sha256';
import fx from '@/lib/glfx/glfx.js';

// Helper function to remaps the given number n from a range of (min0 to max0)
// to a range of (minf to maxf) using linear interpolation.
function remap(n, min0,max0, minf,maxf){
    return (n-min0)*(maxf-minf)/(max0-min0) + minf;
}

export default {
    name: 'ImageViewport',
    props: {
        data: {
            type: ImageData,
            required: false
        }
    },

    data(){
        return {
            portContainer: {},
            canvas: {},
            featureLayer: {},
            texture: {},
            textureInitialized: false
        };
    },

    computed: {
        ...mapGetters({
            selectedImage: 'selectedImage'
        }),
        ...mapState({
            radialGrid: state => state.IMG.radialGrid,
            cartesianGrid: state => state.IMG.cartesianGrid,
            // LookupID of the Selected Image:
            lookupID: state => state.IMG.selectedImageLookupID,
            images: state => state.IMG.images,
            // Adjustments currently being edited with sliders:
            editorAdjustments: state => state.IMG.adjustmentsEditorState.adjustments,
            presets: state => state.IMG.Presets
        }),

        imageSource(){
            return this.selectedImage.failed ? '' : this.selectedImage.url;
        },

        imageDOM(){
            return document.getElementById('imgsrc');
        },

        // Keys of the All Adjustments:
        adjustmentKeys(){
            return Object.keys(this.editorAdjustments);
        },
        // Preset adjustment filters applied to this image:
        appliedPresets(){
            return this.selectedImage && this.selectedImage.data.name ? this.presets.filter( p => p.data.global || p.data.imageList.includes(this.selectedImage.data.name) ) : [];
        },
        // Combined adjustments from the editor and the applied presets.
        totalAdjustments(){
            let tot = Object.assign({}, this.editorAdjustments); // make a copy
            this.appliedPresets.forEach(p => {
                this.adjustmentKeys.forEach(k => tot[k] += p.data.adjustments[k]);
            });
            return tot;
        },
        adjustmentsHash(){
            // TODO: Should use flags / events on update, not this.
            return sha256(JSON.stringify(this.totalAdjustments));
        }
    },
    watch: {
        adjustmentsHash: function(){
            this.applyEffects();
        }
    },

    mounted(){
        this.rehookDOM();
    },

    methods: {
    // Update DOM Hooks:
        rehookDOM(){
            this.portContainer = document.getElementById('portContainer');
            this.featureLayer = document.getElementById('featurevp');
            if(1||!this.canvas || !this.canvas.texture){
                this.canvas = document.getElementById('imgvp');
                fx.canvas(this.canvas); // Initialize canvas for glfx
            }
        },

        onImageUpdate(){
            this.rehookDOM();
            /* First, Direct the Canvas (by changing its source image) to Have the
      Right Aspect Ratio but be way bigger than it could ever need to be - this
      prevents size capping (where a small canvas sized by a small source image
      stops growing to fit the container but the images around it continue to grow).
      Pretty hacky fix but it works with minimal cost. */
            // Fetch info about all available displays:
            let displays = screen.getAllDisplays();
            // Get the largest value for vertical and horizontal size of any display:
            let maxWidth = displays.reduce((max,d) => d.bounds.width > max ? d.bounds.width : max, 0);
            let maxHeight = displays.reduce((max,d) => d.bounds.height > max ? d.bounds.height : max, 0);
            // Determine the largest scaling factor needed to for the image to fill the largest display:
            let maxScale = Math.max(maxWidth / this.imageDOM.width, maxHeight / this.imageDOM.height);
            // Direct the Size of the Image to a Size Sufficiently Larger than this Scale to Prevent Clipping:
            this.imageDOM.width = 1.5 * maxScale * this.imageDOM.width;
            this.imageDOM.height = 1.5 * maxScale * this.imageDOM.height;

            // (re)Texture the base canvas with the image:
            if(!this.textureInitialized){
                this.texture = this.canvas.texture(this.imageDOM); // Only create texture once
                this.textureInitialized = true;
            } else{
                this.texture = this.canvas.texture(this.imageDOM); // Only create texture once
                //this.texture.loadContentsOf(this.imageDOM); // Faster to update
            }
            this.applyEffects(); // Reapply effects
        },

        applyEffects(){
            if(this.canvas && this.textureInitialized){ // Ensure DOM has been loaded
                try {
                    // Redraw Image:
                    let result = this.canvas.draw(this.texture);

                    // Apply Effects:
                    result = result.brightnessContrast(this.totalAdjustments.Exposure, this.totalAdjustments.Contrast)
                        .vibrance(this.totalAdjustments.Shadows);
                    if(this.totalAdjustments.Denoise > 0.02 || this.totalAdjustments.Denoise < -0.02){ // slider has been moved
                        result = result.denoise(remap(this.totalAdjustments.Denoise, -1,1, 0,75));
                    }

                    // Update Canvas:
                    result.update();

                } catch (e) {
                    console.error(e);
                }
            }
        }
    }
};
</script>

<style lang="scss" scoped>
  @import '@/styles/_colors.scss';

  .image-viewport {
    padding: 2rem;
    max-width: 100%;
    max-height: 100%;
  }

  #portContainer {
    user-select: none;
    display: grid;
    grid-template-rows: minmax(0,1fr);
    grid-template-columns: auto minmax(0,1fr) auto;
    grid-template-areas: "buffa main buffb";
    align-items: center;
    justify-items: center;
    width: 100%;
    height: 100%;
  }

  .port {
    grid-area: main;
    object-fit: contain;
    max-height: 100%;
    max-width: 100%;
  }

  /* port fade animation: */
  $overlay-opacity: 0.925;
  .port_overlay {
    z-index: 2;
    opacity: $overlay-opacity;
  }

  .overlay-enter-active {
    animation: overlay-fade-in 0.9s;
  }
  .overlay-leave-active {
    animation: overlay-fade-out 0.9s;
  }
  @keyframes overlay-fade-in {
    0% {
      opacity: 0;
    }
    100% {
      opacity: $overlay-opacity;
    }
  }
  @keyframes overlay-fade-out {
    /* Can't just reverse overlay-fade-in because simultaneous fade-in and
    fade-out don't work if they're both using the same keyframe. */
    0% {
      opacity: $overlay-opacity;
    }
    100% {
      opacity: 0;
    }
  }

</style>
