Module IrisBackendv3.codec.packet_classes.custom_payload
========================================================
Abstract implementation of `CustomPayloadPacket` which is used as superclass
for Packets which extract a number of Payloads (`CustomPayload`) from a single
large payload, often, in part, as a bitfield. This is used almost exclusively 
for communication with the Watchdog which doesn't use the Iris Common Packet
format for its telemetry (to minimize bandwidth use).

@author: Connor W. Colombo (CMU)
@last-updated: 03/05/2023

Classes
-------

`CustomPayloadPacket(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC

    ### Descendants

    * IrisBackendv3.codec.packet_classes.watchdog_command_response.WatchdogCommandResponsePacketInterface
    * IrisBackendv3.codec.packet_classes.watchdog_detailed_status.WatchdogDetailedStatusPacketInterface
    * IrisBackendv3.codec.packet_classes.watchdog_heartbeat.WatchdogHeartbeatPacketInterface
    * IrisBackendv3.codec.packet_classes.watchdog_tvac_heartbeat.WatchdogTvacHeartbeatPacketInterface

    ### Class variables

    `CUSTOM_PAYLOAD_CLASS: Optional[Type[~CPCT]]`
    :

    `PREBUILT_MODULE_NAME: ClassVar[Optional[str]]`
    :

    ### Static methods

    `get_ds_module() ‑> IrisBackendv3.data_standards.module.Module`
    :   Returns the corresponding prebuilt `DataStandards` `Module` used for
        mapping this packet's data to telemetry streams.

    ### Instance variables

    `custom_payload: ~CPCT`
    :

    ### Methods

    `pack_payloads_into_custom_payload(self, payloads: EnhancedPayloadCollection) ‑> ~CPCT`
    :   Reconstructs the `custom_payload` (instance of
        `cls.CUSTOM_PAYLOAD_CLASS`) which was used to construct all the
        payloads.
        `custom_payload` is used as an intermediary between the packet bytes
        which contain all the fields used to create the `payloads`
        `PayloadCollection`.
        After construction, this field is normally redundant since it
        necessarily contains the same data as in `payloads`.
        This getter is required to maintain backward compatibility with legacy
        code written when `custom_payload` was a member of all
        `CustomPayloadPacket` classes (and thus expected to exist).
        The `custom_payload` field is also convenient since it allows for a
        compact representation of all data in al fields and
        `cls.CUSTOM_PAYLOAD_CLASS` classes often contain a concise way of
        handling and displaying all the data they contain.
        
        NOTE: This does not automatically replace `_custom_payload`, though you could
        do that by `self._custom_payload=self.unpack_custom_payload_to_payloads(...)`
        if desired.

    `unpack_custom_payload_to_payloads(self, custom_payload: CPCT, endianness_code: str = '<') ‑> IrisBackendv3.codec.payload_collection.EnhancedPayloadCollection`
    :   Unpacks the given `custom_payload` object into an
        `EnhancedPayloadCollection`.
        
        NOTE: This does not automatically replace `payloads`, though you could
        do that by `self.payloads=self.unpack_custom_payload_to_payloads(...)`
        if desired.