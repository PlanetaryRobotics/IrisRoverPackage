Module IrisBackendv3.codec.packet_classes.watchdog_command_response
===================================================================
Implementation of Watchdog Command Response Packet and its Interface.
This is used as a dense and minimally sized way to communicate the most
important Watchdog statuses during cis-lunar transit.

@author: Connor W. Colombo (CMU)
@last-updated: 06/01/2023

Classes
-------

`WatchdogCommandResponsePacket(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.watchdog_command_response.WatchdogCommandResponsePacketInterface
    * IrisBackendv3.codec.packet_classes.custom_payload.CustomPayloadPacket
    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC
    * IrisBackendv3.codec.packet_classes.gds_packet_event_mixin.GdsPacketEventMixin

    ### Class variables

    `CUSTOM_PAYLOAD_CLASS: Optional[Type[IrisBackendv3.codec.packet_classes.watchdog_command_response.WatchdogCommandResponsePacketInterface.CustomPayload]]`
    :   Core custom WatchdogCommandResponse payload.
        Members must have same names as corresponding telemetry channels in the
        `WatchdogCommandResponse` prebuilt module.
        Note: an error will get thrown by `WatchdogCommandResponsePacket.__init__`
        when building `payloads` from the `custom_payload` if all the channels
        in the `WatchdogCommandResponse` prebuilt module don't have a corresponding
        attr in this `CustomPayload`.
        
        *NOTE:* For this to work effectively, all fields, including computed
        properties, must match their names from the prebuilt module
        AND the order of the args in `__init__` must match the order of the
        bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
        DETAILS]

    `START_FLAG: bytes`
    :

`WatchdogCommandResponsePacketInterface(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.custom_payload.CustomPayloadPacket
    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC

    ### Descendants

    * IrisBackendv3.codec.packet_classes.watchdog_command_response.WatchdogCommandResponsePacket

    ### Class variables

    `CustomPayload`
    :   Core custom WatchdogCommandResponse payload.
        Members must have same names as corresponding telemetry channels in the
        `WatchdogCommandResponse` prebuilt module.
        Note: an error will get thrown by `WatchdogCommandResponsePacket.__init__`
        when building `payloads` from the `custom_payload` if all the channels
        in the `WatchdogCommandResponse` prebuilt module don't have a corresponding
        attr in this `CustomPayload`.
        
        *NOTE:* For this to work effectively, all fields, including computed
        properties, must match their names from the prebuilt module
        AND the order of the args in `__init__` must match the order of the
        bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
        DETAILS]

    `PREBUILT_MODULE_NAME: ClassVar[str]`
    :

`WCR_PI(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.custom_payload.CustomPayloadPacket
    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC

    ### Descendants

    * IrisBackendv3.codec.packet_classes.watchdog_command_response.WatchdogCommandResponsePacket

    ### Class variables

    `CustomPayload`
    :   Core custom WatchdogCommandResponse payload.
        Members must have same names as corresponding telemetry channels in the
        `WatchdogCommandResponse` prebuilt module.
        Note: an error will get thrown by `WatchdogCommandResponsePacket.__init__`
        when building `payloads` from the `custom_payload` if all the channels
        in the `WatchdogCommandResponse` prebuilt module don't have a corresponding
        attr in this `CustomPayload`.
        
        *NOTE:* For this to work effectively, all fields, including computed
        properties, must match their names from the prebuilt module
        AND the order of the args in `__init__` must match the order of the
        bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
        DETAILS]

    `PREBUILT_MODULE_NAME: ClassVar[str]`
    :

`WCR_CP(CommandId: int, ErrorFlag: Union[int, str])`
:   Core custom WatchdogCommandResponse payload.
    Members must have same names as corresponding telemetry channels in the
    `WatchdogCommandResponse` prebuilt module.
    Note: an error will get thrown by `WatchdogCommandResponsePacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `WatchdogCommandResponse` prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively, all fields, including computed
    properties, must match their names from the prebuilt module
    AND the order of the args in `__init__` must match the order of the
    bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
    DETAILS]

    ### Instance variables

    `CommandId: int`
    :

    `CommandName: str`
    :   Look up the Command Name corresponding to the Command ID given in 
        this packet in the *current ground software* copy of the 
        datastandards (that is, it's not a 100% guarantee that this is how 
        the WD code was interpreting the command ID - *but* appropriate 
        systems controls and version alignment should prevent them from 
        being out of sync).

    `ErrorFlag: int`
    :

    `ErrorFlagComment: str`
    :

    `ErrorFlagName: str`
    :