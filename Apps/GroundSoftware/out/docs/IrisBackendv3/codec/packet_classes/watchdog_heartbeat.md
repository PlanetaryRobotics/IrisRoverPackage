Module IrisBackendv3.codec.packet_classes.watchdog_heartbeat
============================================================
Implementation of Watchdog TVAC Heartbeat Packet and its Interface.
This is used as a dense and minimally sized way to communicate the most
important Watchdog statuses during cis-lunar transit.

@author: Connor W. Colombo (CMU)
@last-updated: 12/31/2022

Classes
-------

`WatchdogHeartbeatPacket(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.watchdog_heartbeat.WatchdogHeartbeatPacketInterface
    * IrisBackendv3.codec.packet_classes.custom_payload.CustomPayloadPacket
    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC

    ### Class variables

    `CUSTOM_PAYLOAD_CLASS: Optional[Type[IrisBackendv3.codec.packet_classes.watchdog_heartbeat.WatchdogHeartbeatPacketInterface.CustomPayload]]`
    :   Core custom WatchdogHeartbeatPacket payload.
        Members must have same names as corresponding telemetry channels in the
        `WatchdogHeartbeat` prebuilt module.
        Note: an error will get thrown by `WatchdogHeartbeatPacket.__init__`
        when building `payloads` from the `custom_payload` if all the channels
        in the `WatchdogHeartbeat` prebuilt module don't have a corresponding
        attr in this `CustomPayload`.
        
        *NOTE:* For this to work effectively, all fields, including computed
        properties, must match their names from the prebuilt module
        AND the order of the args in `__init__` must match the order of the
        bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
        DETAILS]

    `START_FLAG: bytes`
    :

`WatchdogHeartbeatPacketInterface(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.custom_payload.CustomPayloadPacket
    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC

    ### Descendants

    * IrisBackendv3.codec.packet_classes.watchdog_heartbeat.WatchdogHeartbeatPacket

    ### Class variables

    `CustomPayload`
    :   Core custom WatchdogHeartbeatPacket payload.
        Members must have same names as corresponding telemetry channels in the
        `WatchdogHeartbeat` prebuilt module.
        Note: an error will get thrown by `WatchdogHeartbeatPacket.__init__`
        when building `payloads` from the `custom_payload` if all the channels
        in the `WatchdogHeartbeat` prebuilt module don't have a corresponding
        attr in this `CustomPayload`.
        
        *NOTE:* For this to work effectively, all fields, including computed
        properties, must match their names from the prebuilt module
        AND the order of the args in `__init__` must match the order of the
        bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
        DETAILS]

    `PREBUILT_MODULE_NAME: ClassVar[str]`
    :

`WHB_PI(custom_payload: Optional[CPCT] = None, payloads: Optional[EnhancedPayloadCollection] = None, raw: Optional[bytes] = None, endianness_code: str = '<')`
:   Superclass for a special **non**-Iris Common Packet packet
    (e.g. generated by the Watchdog) which contains items which would normally
    be in separate telemetry channels but instead are contained in one
    continuous `CustomPayload`. This class maps the extracts the values in the
    `CustomPayload` and stores them in traditional `TelemetryPayload`s linked to
    a custom `TelemetryChannel`.
    All of these telemetry channels must be found
    in a `DataStandards` module, typically a `prebuilt` one.
    
    **The subclass must specify a `PREBUILT_MODULE_NAME` which links the subclass
    to the `DataStandards` module it represents.**
    
    Members of the custom payload must have same names as the corresponding
    telemetry channels in the prebuilt `DataStandards` module.
    Note: an error will get thrown by `CustomPayloadPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `PREBUILT_MODULE_NAME prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively:
    1. All fields, including computed properties, in the custom payload must
        match the names of the corresponding telemetry channels from the
        prebuilt module.
    2. Although the custom payload class can have fields that don't appear as
        telemetry channels in the linked datastandards module, all telemetry
        channels in the module must have matching fields in the custom payload
        class.
    3. All args to `__init__` of the custom payload must have corresponding
        channels in the linked datastandards module.
    4. The order of the args in `__init__` of the custom payload must
        match the order of the bytes/bits in the packet.
    
    Constructs an instance of this `CustomPayloadPacket`. If a
    `custom_payload` (`CPCT`) object is given (e.g. when decoding), it will
    be unpacked into a `EnhancedPayloadCollection`. If a `payloads`
    `EnhancedPayloadCollection` is given, it will just be loaded.
    NOTE: `custom_payload` XOR `payloads` must be given. Not neither, not
    both.

    ### Ancestors (in MRO)

    * IrisBackendv3.codec.packet_classes.custom_payload.CustomPayloadPacket
    * IrisBackendv3.codec.packet_classes.packet.Packet
    * IrisBackendv3.codec.container.ContainerCodec
    * typing.Generic
    * abc.ABC

    ### Descendants

    * IrisBackendv3.codec.packet_classes.watchdog_heartbeat.WatchdogHeartbeatPacket

    ### Class variables

    `CustomPayload`
    :   Core custom WatchdogHeartbeatPacket payload.
        Members must have same names as corresponding telemetry channels in the
        `WatchdogHeartbeat` prebuilt module.
        Note: an error will get thrown by `WatchdogHeartbeatPacket.__init__`
        when building `payloads` from the `custom_payload` if all the channels
        in the `WatchdogHeartbeat` prebuilt module don't have a corresponding
        attr in this `CustomPayload`.
        
        *NOTE:* For this to work effectively, all fields, including computed
        properties, must match their names from the prebuilt module
        AND the order of the args in `__init__` must match the order of the
        bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
        DETAILS]

    `PREBUILT_MODULE_NAME: ClassVar[str]`
    :

`WHB_CP(ChargeRaw: int, HeaterStatus: int, CurrentRaw: int, BatteryVoltageOk: int, BattAdcTempRaw: int)`
:   Core custom WatchdogHeartbeatPacket payload.
    Members must have same names as corresponding telemetry channels in the
    `WatchdogHeartbeat` prebuilt module.
    Note: an error will get thrown by `WatchdogHeartbeatPacket.__init__`
    when building `payloads` from the `custom_payload` if all the channels
    in the `WatchdogHeartbeat` prebuilt module don't have a corresponding
    attr in this `CustomPayload`.
    
    *NOTE:* For this to work effectively, all fields, including computed
    properties, must match their names from the prebuilt module
    AND the order of the args in `__init__` must match the order of the
    bytes in the packet. [SEE THE NOTE IN `CustomPayloadPacket` FOR MORE
    DETAILS]

    ### Static methods

    `despan(span: int, num_bits: int, min_val: float, max_val: float, span_min: int = 0, span_max: Optional[int] = None) ‑> float`
    :   Converts a given `span` value can span from 0 to 2**`num_bits`
        back to its original value in its original range from `min_val` to
        `max_val`.
        This is just basic linear interpolation over a given bit range.
        Data is transmitted as a `span` value to maximize the number of
        useful values which can occupy a given number of bits.
        
        Optionally, `span_min` and `span_max` can be given which will limit
        the lower and upper bound value for `span` used in the conversion
        process. `span` values below `span_min` will plateau and correspond to
        `min_val` and `span` values above `span_max` will plateau and
        correspond to `max_val`. This is necessary since, if floating point
        arithmetic is to be avoided in the FSW, it's not always possible to
        map a value from its original range to an exact power of 2.
        
        **Note:** `max_val` is the value which makes `span` take its highest
        value (2^n-1) and `min_val` is the value which makes `span` 0.
        If the range is inverted (say, 0xFF corresponds to 0 and 0x00
        corresponds to 100), then `max_val` will be smaller than `min_val`.

    `span(val: float, num_bits: int, min_val: float, max_val: float, span_min: int = 0, span_max: Optional[int] = None) ‑> float`
    :   Converts a given value, `val`, which ranges from `min_val` to
        `max_val`, to a `span` value which ranges from 0 to 2**`num_bits`.
        This is just basic linear interpolation over a given bit range.
        Data is transmitted as a `span` value to maximize the number of
        useful values which can occupy a given number of bits.
        
        Optionally, `span_min` and `span_max` can be given which will limit
        the lower and upper bound value for `span` used in the conversion
        process. `span` values below `span_min` will plateau and correspond to
        `min_val` and `span` values above `span_max` will plateau and
        correspond to `max_val`. This is necessary since, if floating point
        arithmetic is to be avoided in the FSW, it's not always possible to
        map a value from its original range to an exact power of 2.
        
        **Note:** `max_val` is the value which makes `span` take its highest
        value (2^n-1) and `min_val` is the value which makes `span` 0.
        If the range is inverted (say, 0xFF corresponds to 0 and 0x00
        corresponds to 100), then `max_val` will be smaller than `min_val`.

    ### Instance variables

    `BattAdcTempKelvin: float`
    :

    `BattAdcTempRaw: int`
    :

    `BatteryVoltageOk: bool`
    :

    `ChargeMah: float`
    :

    `ChargePercent: float`
    :

    `ChargeRaw: int`
    :

    `CurrentMilliamps: float`
    :

    `CurrentRaw: int`
    :

    `HeaterStatus: bool`
    :