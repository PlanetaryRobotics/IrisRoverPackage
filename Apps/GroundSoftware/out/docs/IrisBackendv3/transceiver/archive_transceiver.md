Module IrisBackendv3.transceiver.archive_transceiver
====================================================
Defines the Transceiver class for reading telemetry from an archive file
(e.g. Mission `parquet` file or iTVAC h5 file from `_peregrine_tvac_fetcher.py`).

Includes any supporting functions necessary for processing an archive file (h5,
parquet, etc).

Formerly: `h5_transceiver.py`.

TODO: Read COMMAND columns from YAMCS archive, build command payloads, and
replay into Uplink pathway (low priority b/c that wouldn't really go anywhere
besides right back into the transceivers, which are likely just this one, and
some displays.

@author: Connor W. Colombo (CMU)
@last-updated: 10/01/2024

Functions
---------

    
`filter_archive_by_time(archive: pandas.core.frame.DataFrame, opts) ‑> pandas.core.frame.DataFrame`
:   Filters out all records that aren't within the time window specified by
    the given options.
    
    If desired, further filters out any records before Iris was first powered
    on after the start time.

    
`load_raw_yamcs_data(opts: IrisBackendv3.transceiver.archive_transceiver.ArchiveParseOpts) ‑> pandas.core.frame.DataFrame | None`
:   Loads raw YAMCS data from the Archive and returns it.

    
`records_to_packets(records: pandas.core.frame.DataFrame, rx_is_generation_time: bool = False) ‑> List[IrisBackendv3.codec.packet_classes.packet.Packet]`
:   Creates all packets that should be generated from the given records,
    sorted chronologically.

Classes
-------

`ArchiveParseOpts(name: str = 'fm1_mission_archive.yamcs', db_dir: str = './out/databases', ext: str = 'parquet', playback_speed: float = 1.0, loop: bool = True, start_time_utc: datetime.datetime | None = datetime.datetime(2020, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), end_time_utc: datetime.datetime | None = None, jump_to_iris: bool = True, rx_is_generation_time: bool = True)`
:   Method generated by attrs for class ArchiveParseOpts.

    ### Class variables

    `db_dir: str`
    :

    `end_time_utc: datetime.datetime | None`
    :

    `ext: str`
    :

    `jump_to_iris: bool`
    :

    `loop: bool`
    :

    `name: str`
    :

    `playback_speed: float`
    :

    `rx_is_generation_time: bool`
    :

    `start_time_utc: datetime.datetime | None`
    :

    ### Static methods

    `field_names() ‑> List[str]`
    :

`ArchiveTransceiver(parser_opts: IrisBackendv3.transceiver.archive_transceiver.ArchiveParseOpts, endecs: Optional[List[IrisBackendv3.transceiver.endecs.endec.Endec]] = None, pathway: IrisBackendv3.codec.metadata.DataPathway = DataPathway.NONE, source: IrisBackendv3.codec.metadata.DataSource = DataSource.NONE, **kwargs)`
:   Abstract base class for all `Transceivers`. This class handles all
    logic interfacing with `Packet` classes and `Endec`s so the implementation
    of the subclasses can be as simple as possible (just handling how to get
    and send packet bytes.)
    
    Initializes an `ArchiveTransceiver`.
    
    NOTE: You'll need to supply the appropriate list of `endecs` which were
    used to encode the data that was put into the Archive (likely none).

    ### Ancestors (in MRO)

    * IrisBackendv3.transceiver.transceiver.Transceiver
    * abc.ABC

    ### Class variables

    `parser_opts: IrisBackendv3.transceiver.archive_transceiver.ArchiveParseOpts`
    :

    ### Methods

    `async_read(self) ‑> List[IrisBackendv3.codec.packet_classes.packet.Packet]`
    :   Asynchronously awaits the next available packet(s) on the
        transceiver input.

    `begin(self) ‑> None`
    :   Initialize any special registers, etc. for this transceiver.
        Can also be used to reset the state of the transceiver.

    `read(self) ‑> List[IrisBackendv3.codec.packet_classes.packet.Packet]`
    :   Reads all available packets on the transceiver input.
        Synchronous wrapper for `async_read`.

    `restart(self) ‑> None`
    :   Resets the state of the transceiver.