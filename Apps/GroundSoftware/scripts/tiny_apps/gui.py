import attr
from typing import Tuple, List, Dict

from datetime import datetime, timezone
import random

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
import plotly.io as pio

# plt.rcParams['text.usetex'] = True
sns.set()  # Initialize Seaborn. Use default theme.

pd.options.plotting.backend = 'plotly'
pio.templates.default = 'plotly_dark'


@attr.define
class GuiTelemetryItem:
    """
    Mock the way `TelemetryPayloads` will be extracted from received packets
    (one at a time, with a module name, channel name, value, and timestamp).
    """
    module_name: str
    channel_name: str
    value: float
    timestamp: datetime

    @property
    def simple_str(self) -> str:
        return f"{self.module_name}::{self.channel_name}[{self.timestamp}] = {self.value}"


@attr.define
class FakeChannel:
    """
    Container for data about a fake module (used for `gen_fake_telem`).
    """
    name: str
    latest_value: float
    scale: float
    lin_bias: float


# List of fake modules and the telemetry channels that belong to them:
fake_telem_channels: List[Tuple[str, List[FakeChannel]]] = [
    ('IMU', [
        FakeChannel('XAcc', 0.0, 0.1, 1.0),
        FakeChannel('YAcc', 0.0, 0.1, 2.0),
        FakeChannel('ZAcc', 0.0, 0.1, 3.0),
        FakeChannel('XAng', 0.0, 0.1, 4.0),
        FakeChannel('YAng', 0.0, 0.1, 5.0),
        FakeChannel('ZAng', 0.0, 0.1, 6.0)
    ]),
    ('Network', [
        FakeChannel('Rssi', 0.0, 0.1, 7.0),
        FakeChannel('Snr', 0.0, 0.1, 8.0),
        FakeChannel('SentPackets', 0.0, 0.1, 9.0),
        FakeChannel('ReceivedPackets', 0.0, 0.1, 10.0)
    ]),
    ('Vitals', [
        FakeChannel('Temperature', 0.0, 0.1, 11.0),
        FakeChannel('BatteryLevel', 0.0, 0.1, 12.0),
        FakeChannel('SystemVoltage', 0.0, 0.1, 13.0)
    ])
]


def gen_fake_telem() -> GuiTelemetryItem:
    """
    Generate a Random Fake `GuiTelemetryItem` by picking a random `FakeChannel` 
    from a random module from `fake_telem_channels`. The value of the
    `GuiTelemetryItem` will be generated by starting with the `FakeChannel`'s  
    currently (secretly) stored `latest_value` and adding a fixed value (its 
    `lin_bias`) and a random value between `-scale` and `+scale`.
    Uses a timestamp of `now()`.
    """
    # Grab a random module:
    module_idx = random.randint(0, len(fake_telem_channels)-1)
    module_tuple = fake_telem_channels[module_idx]
    module_name = module_tuple[0]
    fake_channels = module_tuple[1]

    # Grab a random channel:
    channel_idx = random.randint(0, len(fake_channels)-1)
    channel = fake_channels[channel_idx]
    channel_name = channel.name

    # Increment its stored secret value:
    value = channel.latest_value + channel.lin_bias
    value += random.triangular(-channel.scale, channel.scale, 0.0)
    # And store the newly generated value:
    channel.latest_value = value

    return GuiTelemetryItem(
        module_name=module_name,
        channel_name=channel_name,
        value=value,
        timestamp=datetime.now(timezone.utc)
    )


@attr.define
class TelemetryStream:
    times: List[datetime] = attr.Factory(list)
    values: List[float] = attr.Factory(list)

    def append(self, time: datetime, value: float) -> None:
        """
        Appends a value at the given time to the stream. Wrapped to allow adding 
        safeties later.
        """
        self.times.append(time)
        self.values.append(value)


class TelemetryStreamCollection:
    # Map between stream names and `TelemetryStream`s:
    streams: Dict[str, TelemetryStream]

    def __init__(self) -> None:
        self.streams = dict()

    def add(self, stream_name: str, time: datetime, value: float) -> bool:
        """
        Adds an entry with the given `value` at the given `time` to the 
        `TelemetryStream` with the given name. If a stream with the given name 
        does not yet exist, it will be created and initialized with the given 
        data.

        Args:
            stream_name (str): name of the stream
            time (datetime): timestamp of the value to be added
            value (float): value to be added

        Returns:
            bool: Whether a new `TelemetryStream` had to be created.
        """
        if stream_name in self.streams:
            # Append the logs if there's already an entry for that channel:
            self.streams[stream_name].append(time, value)
            return False
        else:
            # Create a new entry since there isn't one yet:
            self.streams[stream_name] = TelemetryStream([time], [value])
            return True

    def add_item(self, item: GuiTelemetryItem) -> bool:
        """
        Adds an entry with the given value at the given time to the 
        `TelemetryStream` with the given name, as determined by the given 
        `GuiTelemetryItem` `item`.
        If a stream with the given name does not yet exist, it will be created 
        and initialized with the given data.

        Returns:
            bool: Whether a new `TelemetryStream` had to be created.
        """
        stream_name = f"{item.module_name}_{item.channel_name}"
        return self.add(stream_name, item.timestamp, item.value)

    def plot(self) -> None:
        plt.figure(figsize=(10, 6), dpi=100)
        for stream_name, stream in self.streams.items():
            plt.plot(stream.times, stream.values, label=stream_name)

        plt.legend()
        plt.show()


# Collection of Telemetry Data (vector of times and vector of values) for Each Telemetry Channel for which data's been seen:
telemetry_streams = TelemetryStreamCollection()


def fake_update_telemetry_streams() -> None:
    """
    Generate a new random fake telemetry data point for a randomly selected 
    fake telemetry channel and add it to the `telemetry_streams`.
    """
    # Generate a random fake data point:
    datum: GuiTelemetryItem = gen_fake_telem()
    key = f"{datum.module_name}_{datum.channel_name}"

    telemetry_streams.add_item(datum)


if __name__ == '__main__':
    pass
